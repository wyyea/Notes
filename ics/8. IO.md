# I/O操作的实现

## I/O子系统
![[IO_subsystem.jpg]]

### 特点：

+ 共享性：IO子系统被多个进程共享，操作系统对共享的IO资源统一调度
+ 异步性：IO设备和主机之间信息交换使用异步中断方式
### 过程：

+ CPU执行到执行到陷阱指令时，陷入内核态，根据系统调用号，选择相应的系统调用服务例程
+ 调用对应设备的驱动程序，驱动程序启动外设
+ 外设准备好后发出中断请求，CPU响应中断，调出中断服务程序执行，进行具体的数据交换
---
## 文件
### 特点：

+ IO操作抽象成对文件的读写操作
+ 字符设备：以字符为单位向主机收发字符流的设备，无法定位和寻址，如大多数IO设备
+ 块设备：以一个固定数据块为单位与主机交换信息，可寻址，如磁盘
### 相关操作：

+ 创建/打开：返回文件描述符fd，用于标识被创建或打开的文件，std ioe分别为012
+ 设置文件读写位置：即相对文件最开始位置的偏移量
+ 读写文件：从当前读写位置k读出n个字节，读出后读写位置为k+n
+ 关闭文件：释放文件所占有的数据结构和存储，***回收*** 文件描述符。进程终止时，会关闭所有打开的文件
---
## 系统级IO函数
### `int creat(char *name, mode_t perms);`

+ 创建指定路径名和访问权限的文件，返回文件描述符，出错时返回-1
+ 若已经存在，则将长度截断为0，即将原有内容全部丢弃

### `int open(char *name, int flags, mode_t perms);`

+ 使用指定方式（由flags指定）打开文件，返回文件描述符，出错返回-1
+ flags可用值：O_RDONLY, O_WRONLY, O_RDDWR | O_CREAT ...
+ 不以创建方式打开，文件不存在则发生错误；以创建方式打开，文件存在则截断为空文件

### `ssize_t read(int fd, void *buf, size_t n);`
### `ssize_t write(int fd, void *buf, size_t n);`

+ 从当前读写位置k开始读写n个字符，读写位置变为k+n
+ 设文件长度为m，`k + n > m`时，读写字节数为`m - k < n`
+ 读写字节数小于n可能是：遇到EOF，读写的是终端设备文件，socket，UNIX管道等

### `long lseek(int fd, long offset, int origin);`

+ 调整文件读写位置，返回调整后的读写位置，出错返回-1
+ origin可取`SEEK_SET(0), SEEK_CUR(1), SEEK_END(2)`

### `int stat(const *name, struct stat *buf);`
### `int fstat(int fd, struct stat *buf);`

+ 查看文件的属性信息（元数据），如文件描述符，文件名，大小，创建时间，当前读写位置

### `int close(int fd);`

+ 关闭文件fd
---
## C标准IO库函数
### 特点：

+ 优点： 移植性好，可在不同架构和操作系统下运行
+ 使用了文件缓冲区，使系统调用次数减少
+ 不足：所有IO操作都是同步的，程序必须等待IO操作完成后才能继续进行
+ 有些IO操作无法通过C标准IO库函数完成
### 缓冲

+ `stdio.h`中截取的相关内容
![[FILE_1.jpg]]
![[FILE_2.jpg]]

+ 使用FILE结构表示打开的文件，包含文件描述符，缓冲区
+ 可使用全缓冲，行缓冲（如stdio），非缓冲（如stderr）
+ 对全缓冲：优先对缓冲区进行读写，在缓冲区满后进行一次系统调用
+ 对列缓冲，会检查本次写的字节流中是否含有换行符，有则将缓冲区信息一次性写到文件中

### `FILE *fopen(char *name, char *mode);`

+ 使用指定方式（通过mode指定）打开文件
+ mode可取：'r', 'w', 'r', 'a', 'a + b'等
---
## IO接口(设备控制器)
### 结构

+ 数据缓冲寄存器：用于CPU和设备异步交换数据
+ 状态寄存器：CPU从中读取，用于判断设备是否出错或就绪等
+ 控制寄存器：CPU写入控制信号，对外设进行控制
+ 控制寄存器和状态寄存器可以合二为一，在访问时间上错开即可
+ 数据缓冲寄存器称为数据端口，状态/控制寄存器称为状态/控制端口，两者统称IO端口
### 编址

+ 统一编址（存储器映射方式）：IO地址空间与主存地址空间统一编址
	使用更复杂的译码电路，译码时间较长，但编程灵活性较好（任何对内存的存取指令都可用于访问IO端口）
+ 独立编址：IO地址空间和主存地址空间相互独立，使用专门的IO指令进行IO操作
	译码电路较简单，寻址速度快，但编程灵活性较差
---
## IO控制方式
### 程序直接控制

+ 又被称为程序 **查询** 或 **轮询** (polling)
+ 在查询程序中安排相应的IO指令，通过指令向设备控制器传送控制命令，从状态寄存器中获取状态后，根据状态来控制数据交换
+ 在设备未就绪时一直忙等待，浪费大量CPU时间
### 中断控制

+ 需要IO操作时，首先启动第一个数据的IO操作，然后阻塞当前进程，转去执行其他进程
+ 外设完成IO操作后，向CPU发送中断请求信号，CPU检测到后，暂停正在执行的进程，调出中断服务程序，启动随后数据的IO操作，再回到被打断的进程（如逐个打印字符）
### DMA控制

+ 直接存储器访问(Direct Memory Access)
+ 首先对DMA控制器(包含主存地址寄存器，设备地址寄存器，字计数器，控制寄存器等)进行初始化，然后启动DMA传送，CPU转去其他进程，当前进程被阻塞
+ 字计数器为０时，DMA控制器发送中断请求信号，CPU暂停当前进程，调出中断服务程序，解除原有进程的阻塞状态，中断返回
---
## 设备无关的IO软件

### 设备驱动程序的统一接口

+ 所有外设抽象成一个文件，设备名能确定一个特殊文件的i节点（包括主设备号，次设备号），主设备号用于定位设备驱动程序，次设备号用于确定具体设备
### 缓冲区处理

+ 内核空间会开辟缓冲区用于存放IO数据
	+ 这样在IO过程中用户进程被挂起也不会影响IO操作(缓冲区页面不会被替换)
	+ 可解决不同块设备读写单位不一致的问题
+ 缓冲区的申请和管理是所有设备公共的
### 错误报告

+ 编程错误（如请求某个不可能的IO操作）：由设备无关IO软件检测出，直接返回
+ IO操作错误（如写一个已被破环的磁盘扇区，打印机缺纸等）：由设备驱动程序检测出并处理，将错误信息返回给设备无关IO软件，由其返回给用户进程
### 打开/关闭文件

+ 只是修改数据结构，不涉及具体IO操作
---
## 中断嵌套
### 中断屏蔽
![[iterrupt_sys.jpg]]

+ 设置中断屏蔽字，禁止被某些中断打断
+ 每条指令执行完后，先看是否有中断请求信号，有则启动中断查询线，通过中断判优电路获取中断类型号
### 多重中断的中断服务程序
![[recursive_interrupt.jpg|300]]
+ 准备阶段：保存现场和旧屏蔽字，并设置新屏蔽字，需关中断
+ 处理阶段：开中断
+ 恢复阶段：恢复现场和旧屏蔽字，清除中断请求，需关中断
+ 保存现场和旧屏蔽字通过栈实现，设置新屏蔽字和清除中断请求通过IO指令实现





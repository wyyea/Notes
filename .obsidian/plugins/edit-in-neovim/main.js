/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@msgpack/msgpack/dist/utils/int.js
var require_int = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUint64 = exports.getInt64 = exports.setInt64 = exports.setUint64 = exports.UINT32_MAX = void 0;
    exports.UINT32_MAX = 4294967295;
    function setUint64(view, offset, value) {
      const high = value / 4294967296;
      const low = value;
      view.setUint32(offset, high);
      view.setUint32(offset + 4, low);
    }
    exports.setUint64 = setUint64;
    function setInt64(view, offset, value) {
      const high = Math.floor(value / 4294967296);
      const low = value;
      view.setUint32(offset, high);
      view.setUint32(offset + 4, low);
    }
    exports.setInt64 = setInt64;
    function getInt64(view, offset) {
      const high = view.getInt32(offset);
      const low = view.getUint32(offset + 4);
      return high * 4294967296 + low;
    }
    exports.getInt64 = getInt64;
    function getUint64(view, offset) {
      const high = view.getUint32(offset);
      const low = view.getUint32(offset + 4);
      return high * 4294967296 + low;
    }
    exports.getUint64 = getUint64;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/utf8.js
var require_utf8 = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/utf8.js"(exports) {
    "use strict";
    var _a;
    var _b;
    var _c;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utf8DecodeTD = exports.TEXT_DECODER_THRESHOLD = exports.utf8DecodeJs = exports.utf8EncodeTE = exports.TEXT_ENCODER_THRESHOLD = exports.utf8EncodeJs = exports.utf8Count = void 0;
    var int_1 = require_int();
    var TEXT_ENCODING_AVAILABLE = (typeof process === "undefined" || ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a["TEXT_ENCODING"]) !== "never") && typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined";
    function utf8Count(str) {
      const strLength = str.length;
      let byteLength = 0;
      let pos = 0;
      while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 4294967168) === 0) {
          byteLength++;
          continue;
        } else if ((value & 4294965248) === 0) {
          byteLength += 2;
        } else {
          if (value >= 55296 && value <= 56319) {
            if (pos < strLength) {
              const extra = str.charCodeAt(pos);
              if ((extra & 64512) === 56320) {
                ++pos;
                value = ((value & 1023) << 10) + (extra & 1023) + 65536;
              }
            }
          }
          if ((value & 4294901760) === 0) {
            byteLength += 3;
          } else {
            byteLength += 4;
          }
        }
      }
      return byteLength;
    }
    exports.utf8Count = utf8Count;
    function utf8EncodeJs(str, output, outputOffset) {
      const strLength = str.length;
      let offset = outputOffset;
      let pos = 0;
      while (pos < strLength) {
        let value = str.charCodeAt(pos++);
        if ((value & 4294967168) === 0) {
          output[offset++] = value;
          continue;
        } else if ((value & 4294965248) === 0) {
          output[offset++] = value >> 6 & 31 | 192;
        } else {
          if (value >= 55296 && value <= 56319) {
            if (pos < strLength) {
              const extra = str.charCodeAt(pos);
              if ((extra & 64512) === 56320) {
                ++pos;
                value = ((value & 1023) << 10) + (extra & 1023) + 65536;
              }
            }
          }
          if ((value & 4294901760) === 0) {
            output[offset++] = value >> 12 & 15 | 224;
            output[offset++] = value >> 6 & 63 | 128;
          } else {
            output[offset++] = value >> 18 & 7 | 240;
            output[offset++] = value >> 12 & 63 | 128;
            output[offset++] = value >> 6 & 63 | 128;
          }
        }
        output[offset++] = value & 63 | 128;
      }
    }
    exports.utf8EncodeJs = utf8EncodeJs;
    var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;
    exports.TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? int_1.UINT32_MAX : typeof process !== "undefined" && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b["TEXT_ENCODING"]) !== "force" ? 200 : 0;
    function utf8EncodeTEencode(str, output, outputOffset) {
      output.set(sharedTextEncoder.encode(str), outputOffset);
    }
    function utf8EncodeTEencodeInto(str, output, outputOffset) {
      sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
    }
    exports.utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;
    var CHUNK_SIZE = 4096;
    function utf8DecodeJs(bytes, inputOffset, byteLength) {
      let offset = inputOffset;
      const end = offset + byteLength;
      const units = [];
      let result = "";
      while (offset < end) {
        const byte1 = bytes[offset++];
        if ((byte1 & 128) === 0) {
          units.push(byte1);
        } else if ((byte1 & 224) === 192) {
          const byte2 = bytes[offset++] & 63;
          units.push((byte1 & 31) << 6 | byte2);
        } else if ((byte1 & 240) === 224) {
          const byte2 = bytes[offset++] & 63;
          const byte3 = bytes[offset++] & 63;
          units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
        } else if ((byte1 & 248) === 240) {
          const byte2 = bytes[offset++] & 63;
          const byte3 = bytes[offset++] & 63;
          const byte4 = bytes[offset++] & 63;
          let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
          if (unit > 65535) {
            unit -= 65536;
            units.push(unit >>> 10 & 1023 | 55296);
            unit = 56320 | unit & 1023;
          }
          units.push(unit);
        } else {
          units.push(byte1);
        }
        if (units.length >= CHUNK_SIZE) {
          result += String.fromCharCode(...units);
          units.length = 0;
        }
      }
      if (units.length > 0) {
        result += String.fromCharCode(...units);
      }
      return result;
    }
    exports.utf8DecodeJs = utf8DecodeJs;
    var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;
    exports.TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? int_1.UINT32_MAX : typeof process !== "undefined" && ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c["TEXT_DECODER"]) !== "force" ? 200 : 0;
    function utf8DecodeTD(bytes, inputOffset, byteLength) {
      const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
      return sharedTextDecoder.decode(stringBytes);
    }
    exports.utf8DecodeTD = utf8DecodeTD;
  }
});

// node_modules/@msgpack/msgpack/dist/ExtData.js
var require_ExtData = __commonJS({
  "node_modules/@msgpack/msgpack/dist/ExtData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtData = void 0;
    var ExtData = class {
      constructor(type, data) {
        this.type = type;
        this.data = data;
      }
    };
    exports.ExtData = ExtData;
  }
});

// node_modules/@msgpack/msgpack/dist/DecodeError.js
var require_DecodeError = __commonJS({
  "node_modules/@msgpack/msgpack/dist/DecodeError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecodeError = void 0;
    var DecodeError = class extends Error {
      constructor(message) {
        super(message);
        const proto = Object.create(DecodeError.prototype);
        Object.setPrototypeOf(this, proto);
        Object.defineProperty(this, "name", {
          configurable: true,
          enumerable: false,
          value: DecodeError.name
        });
      }
    };
    exports.DecodeError = DecodeError;
  }
});

// node_modules/@msgpack/msgpack/dist/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/@msgpack/msgpack/dist/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timestampExtension = exports.decodeTimestampExtension = exports.decodeTimestampToTimeSpec = exports.encodeTimestampExtension = exports.encodeDateToTimeSpec = exports.encodeTimeSpecToTimestamp = exports.EXT_TIMESTAMP = void 0;
    var DecodeError_1 = require_DecodeError();
    var int_1 = require_int();
    exports.EXT_TIMESTAMP = -1;
    var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
    var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
    function encodeTimeSpecToTimestamp({ sec, nsec }) {
      if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
          const rv = new Uint8Array(4);
          const view = new DataView(rv.buffer);
          view.setUint32(0, sec);
          return rv;
        } else {
          const secHigh = sec / 4294967296;
          const secLow = sec & 4294967295;
          const rv = new Uint8Array(8);
          const view = new DataView(rv.buffer);
          view.setUint32(0, nsec << 2 | secHigh & 3);
          view.setUint32(4, secLow);
          return rv;
        }
      } else {
        const rv = new Uint8Array(12);
        const view = new DataView(rv.buffer);
        view.setUint32(0, nsec);
        (0, int_1.setInt64)(view, 4, sec);
        return rv;
      }
    }
    exports.encodeTimeSpecToTimestamp = encodeTimeSpecToTimestamp;
    function encodeDateToTimeSpec(date) {
      const msec = date.getTime();
      const sec = Math.floor(msec / 1e3);
      const nsec = (msec - sec * 1e3) * 1e6;
      const nsecInSec = Math.floor(nsec / 1e9);
      return {
        sec: sec + nsecInSec,
        nsec: nsec - nsecInSec * 1e9
      };
    }
    exports.encodeDateToTimeSpec = encodeDateToTimeSpec;
    function encodeTimestampExtension(object) {
      if (object instanceof Date) {
        const timeSpec = encodeDateToTimeSpec(object);
        return encodeTimeSpecToTimestamp(timeSpec);
      } else {
        return null;
      }
    }
    exports.encodeTimestampExtension = encodeTimestampExtension;
    function decodeTimestampToTimeSpec(data) {
      const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
      switch (data.byteLength) {
        case 4: {
          const sec = view.getUint32(0);
          const nsec = 0;
          return { sec, nsec };
        }
        case 8: {
          const nsec30AndSecHigh2 = view.getUint32(0);
          const secLow32 = view.getUint32(4);
          const sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
          const nsec = nsec30AndSecHigh2 >>> 2;
          return { sec, nsec };
        }
        case 12: {
          const sec = (0, int_1.getInt64)(view, 4);
          const nsec = view.getUint32(0);
          return { sec, nsec };
        }
        default:
          throw new DecodeError_1.DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);
      }
    }
    exports.decodeTimestampToTimeSpec = decodeTimestampToTimeSpec;
    function decodeTimestampExtension(data) {
      const timeSpec = decodeTimestampToTimeSpec(data);
      return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
    }
    exports.decodeTimestampExtension = decodeTimestampExtension;
    exports.timestampExtension = {
      type: exports.EXT_TIMESTAMP,
      encode: encodeTimestampExtension,
      decode: decodeTimestampExtension
    };
  }
});

// node_modules/@msgpack/msgpack/dist/ExtensionCodec.js
var require_ExtensionCodec = __commonJS({
  "node_modules/@msgpack/msgpack/dist/ExtensionCodec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtensionCodec = void 0;
    var ExtData_1 = require_ExtData();
    var timestamp_1 = require_timestamp();
    var ExtensionCodec = class {
      constructor() {
        this.builtInEncoders = [];
        this.builtInDecoders = [];
        this.encoders = [];
        this.decoders = [];
        this.register(timestamp_1.timestampExtension);
      }
      register({ type, encode, decode }) {
        if (type >= 0) {
          this.encoders[type] = encode;
          this.decoders[type] = decode;
        } else {
          const index = 1 + type;
          this.builtInEncoders[index] = encode;
          this.builtInDecoders[index] = decode;
        }
      }
      tryToEncode(object, context) {
        for (let i = 0; i < this.builtInEncoders.length; i++) {
          const encodeExt = this.builtInEncoders[i];
          if (encodeExt != null) {
            const data = encodeExt(object, context);
            if (data != null) {
              const type = -1 - i;
              return new ExtData_1.ExtData(type, data);
            }
          }
        }
        for (let i = 0; i < this.encoders.length; i++) {
          const encodeExt = this.encoders[i];
          if (encodeExt != null) {
            const data = encodeExt(object, context);
            if (data != null) {
              const type = i;
              return new ExtData_1.ExtData(type, data);
            }
          }
        }
        if (object instanceof ExtData_1.ExtData) {
          return object;
        }
        return null;
      }
      decode(data, type, context) {
        const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
        if (decodeExt) {
          return decodeExt(data, type, context);
        } else {
          return new ExtData_1.ExtData(type, data);
        }
      }
    };
    exports.ExtensionCodec = ExtensionCodec;
    ExtensionCodec.defaultCodec = new ExtensionCodec();
  }
});

// node_modules/@msgpack/msgpack/dist/utils/typedArrays.js
var require_typedArrays = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/typedArrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDataView = exports.ensureUint8Array = void 0;
    function ensureUint8Array(buffer) {
      if (buffer instanceof Uint8Array) {
        return buffer;
      } else if (ArrayBuffer.isView(buffer)) {
        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      } else if (buffer instanceof ArrayBuffer) {
        return new Uint8Array(buffer);
      } else {
        return Uint8Array.from(buffer);
      }
    }
    exports.ensureUint8Array = ensureUint8Array;
    function createDataView(buffer) {
      if (buffer instanceof ArrayBuffer) {
        return new DataView(buffer);
      }
      const bufferView = ensureUint8Array(buffer);
      return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
    }
    exports.createDataView = createDataView;
  }
});

// node_modules/@msgpack/msgpack/dist/Encoder.js
var require_Encoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/Encoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Encoder = exports.DEFAULT_INITIAL_BUFFER_SIZE = exports.DEFAULT_MAX_DEPTH = void 0;
    var utf8_1 = require_utf8();
    var ExtensionCodec_1 = require_ExtensionCodec();
    var int_1 = require_int();
    var typedArrays_1 = require_typedArrays();
    exports.DEFAULT_MAX_DEPTH = 100;
    exports.DEFAULT_INITIAL_BUFFER_SIZE = 2048;
    var Encoder = class {
      constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = void 0, maxDepth = exports.DEFAULT_MAX_DEPTH, initialBufferSize = exports.DEFAULT_INITIAL_BUFFER_SIZE, sortKeys = false, forceFloat32 = false, ignoreUndefined = false, forceIntegerToFloat = false) {
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxDepth = maxDepth;
        this.initialBufferSize = initialBufferSize;
        this.sortKeys = sortKeys;
        this.forceFloat32 = forceFloat32;
        this.ignoreUndefined = ignoreUndefined;
        this.forceIntegerToFloat = forceIntegerToFloat;
        this.pos = 0;
        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
        this.bytes = new Uint8Array(this.view.buffer);
      }
      reinitializeState() {
        this.pos = 0;
      }
      /**
       * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
       *
       * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
       */
      encodeSharedRef(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.subarray(0, this.pos);
      }
      /**
       * @returns Encodes the object and returns a copy of the encoder's internal buffer.
       */
      encode(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.slice(0, this.pos);
      }
      doEncode(object, depth) {
        if (depth > this.maxDepth) {
          throw new Error(`Too deep objects in depth ${depth}`);
        }
        if (object == null) {
          this.encodeNil();
        } else if (typeof object === "boolean") {
          this.encodeBoolean(object);
        } else if (typeof object === "number") {
          this.encodeNumber(object);
        } else if (typeof object === "string") {
          this.encodeString(object);
        } else {
          this.encodeObject(object, depth);
        }
      }
      ensureBufferSizeToWrite(sizeToWrite) {
        const requiredSize = this.pos + sizeToWrite;
        if (this.view.byteLength < requiredSize) {
          this.resizeBuffer(requiredSize * 2);
        }
      }
      resizeBuffer(newSize) {
        const newBuffer = new ArrayBuffer(newSize);
        const newBytes = new Uint8Array(newBuffer);
        const newView = new DataView(newBuffer);
        newBytes.set(this.bytes);
        this.view = newView;
        this.bytes = newBytes;
      }
      encodeNil() {
        this.writeU8(192);
      }
      encodeBoolean(object) {
        if (object === false) {
          this.writeU8(194);
        } else {
          this.writeU8(195);
        }
      }
      encodeNumber(object) {
        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {
          if (object >= 0) {
            if (object < 128) {
              this.writeU8(object);
            } else if (object < 256) {
              this.writeU8(204);
              this.writeU8(object);
            } else if (object < 65536) {
              this.writeU8(205);
              this.writeU16(object);
            } else if (object < 4294967296) {
              this.writeU8(206);
              this.writeU32(object);
            } else {
              this.writeU8(207);
              this.writeU64(object);
            }
          } else {
            if (object >= -32) {
              this.writeU8(224 | object + 32);
            } else if (object >= -128) {
              this.writeU8(208);
              this.writeI8(object);
            } else if (object >= -32768) {
              this.writeU8(209);
              this.writeI16(object);
            } else if (object >= -2147483648) {
              this.writeU8(210);
              this.writeI32(object);
            } else {
              this.writeU8(211);
              this.writeI64(object);
            }
          }
        } else {
          if (this.forceFloat32) {
            this.writeU8(202);
            this.writeF32(object);
          } else {
            this.writeU8(203);
            this.writeF64(object);
          }
        }
      }
      writeStringHeader(byteLength) {
        if (byteLength < 32) {
          this.writeU8(160 + byteLength);
        } else if (byteLength < 256) {
          this.writeU8(217);
          this.writeU8(byteLength);
        } else if (byteLength < 65536) {
          this.writeU8(218);
          this.writeU16(byteLength);
        } else if (byteLength < 4294967296) {
          this.writeU8(219);
          this.writeU32(byteLength);
        } else {
          throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);
        }
      }
      encodeString(object) {
        const maxHeaderSize = 1 + 4;
        const strLength = object.length;
        if (strLength > utf8_1.TEXT_ENCODER_THRESHOLD) {
          const byteLength = (0, utf8_1.utf8Count)(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          (0, utf8_1.utf8EncodeTE)(object, this.bytes, this.pos);
          this.pos += byteLength;
        } else {
          const byteLength = (0, utf8_1.utf8Count)(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          (0, utf8_1.utf8EncodeJs)(object, this.bytes, this.pos);
          this.pos += byteLength;
        }
      }
      encodeObject(object, depth) {
        const ext = this.extensionCodec.tryToEncode(object, this.context);
        if (ext != null) {
          this.encodeExtension(ext);
        } else if (Array.isArray(object)) {
          this.encodeArray(object, depth);
        } else if (ArrayBuffer.isView(object)) {
          this.encodeBinary(object);
        } else if (typeof object === "object") {
          this.encodeMap(object, depth);
        } else {
          throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);
        }
      }
      encodeBinary(object) {
        const size = object.byteLength;
        if (size < 256) {
          this.writeU8(196);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(197);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(198);
          this.writeU32(size);
        } else {
          throw new Error(`Too large binary: ${size}`);
        }
        const bytes = (0, typedArrays_1.ensureUint8Array)(object);
        this.writeU8a(bytes);
      }
      encodeArray(object, depth) {
        const size = object.length;
        if (size < 16) {
          this.writeU8(144 + size);
        } else if (size < 65536) {
          this.writeU8(220);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(221);
          this.writeU32(size);
        } else {
          throw new Error(`Too large array: ${size}`);
        }
        for (const item of object) {
          this.doEncode(item, depth + 1);
        }
      }
      countWithoutUndefined(object, keys) {
        let count = 0;
        for (const key of keys) {
          if (object[key] !== void 0) {
            count++;
          }
        }
        return count;
      }
      encodeMap(object, depth) {
        const keys = Object.keys(object);
        if (this.sortKeys) {
          keys.sort();
        }
        const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
        if (size < 16) {
          this.writeU8(128 + size);
        } else if (size < 65536) {
          this.writeU8(222);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(223);
          this.writeU32(size);
        } else {
          throw new Error(`Too large map object: ${size}`);
        }
        for (const key of keys) {
          const value = object[key];
          if (!(this.ignoreUndefined && value === void 0)) {
            this.encodeString(key);
            this.doEncode(value, depth + 1);
          }
        }
      }
      encodeExtension(ext) {
        const size = ext.data.length;
        if (size === 1) {
          this.writeU8(212);
        } else if (size === 2) {
          this.writeU8(213);
        } else if (size === 4) {
          this.writeU8(214);
        } else if (size === 8) {
          this.writeU8(215);
        } else if (size === 16) {
          this.writeU8(216);
        } else if (size < 256) {
          this.writeU8(199);
          this.writeU8(size);
        } else if (size < 65536) {
          this.writeU8(200);
          this.writeU16(size);
        } else if (size < 4294967296) {
          this.writeU8(201);
          this.writeU32(size);
        } else {
          throw new Error(`Too large extension object: ${size}`);
        }
        this.writeI8(ext.type);
        this.writeU8a(ext.data);
      }
      writeU8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setUint8(this.pos, value);
        this.pos++;
      }
      writeU8a(values) {
        const size = values.length;
        this.ensureBufferSizeToWrite(size);
        this.bytes.set(values, this.pos);
        this.pos += size;
      }
      writeI8(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setInt8(this.pos, value);
        this.pos++;
      }
      writeU16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setUint16(this.pos, value);
        this.pos += 2;
      }
      writeI16(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setInt16(this.pos, value);
        this.pos += 2;
      }
      writeU32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setUint32(this.pos, value);
        this.pos += 4;
      }
      writeI32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setInt32(this.pos, value);
        this.pos += 4;
      }
      writeF32(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setFloat32(this.pos, value);
        this.pos += 4;
      }
      writeF64(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setFloat64(this.pos, value);
        this.pos += 8;
      }
      writeU64(value) {
        this.ensureBufferSizeToWrite(8);
        (0, int_1.setUint64)(this.view, this.pos, value);
        this.pos += 8;
      }
      writeI64(value) {
        this.ensureBufferSizeToWrite(8);
        (0, int_1.setInt64)(this.view, this.pos, value);
        this.pos += 8;
      }
    };
    exports.Encoder = Encoder;
  }
});

// node_modules/@msgpack/msgpack/dist/encode.js
var require_encode = __commonJS({
  "node_modules/@msgpack/msgpack/dist/encode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = void 0;
    var Encoder_1 = require_Encoder();
    var defaultEncodeOptions = {};
    function encode(value, options = defaultEncodeOptions) {
      const encoder = new Encoder_1.Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);
      return encoder.encodeSharedRef(value);
    }
    exports.encode = encode;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/prettyByte.js
var require_prettyByte = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/prettyByte.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prettyByte = void 0;
    function prettyByte(byte) {
      return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
    }
    exports.prettyByte = prettyByte;
  }
});

// node_modules/@msgpack/msgpack/dist/CachedKeyDecoder.js
var require_CachedKeyDecoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/CachedKeyDecoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CachedKeyDecoder = void 0;
    var utf8_1 = require_utf8();
    var DEFAULT_MAX_KEY_LENGTH = 16;
    var DEFAULT_MAX_LENGTH_PER_KEY = 16;
    var CachedKeyDecoder = class {
      constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {
        this.maxKeyLength = maxKeyLength;
        this.maxLengthPerKey = maxLengthPerKey;
        this.hit = 0;
        this.miss = 0;
        this.caches = [];
        for (let i = 0; i < this.maxKeyLength; i++) {
          this.caches.push([]);
        }
      }
      canBeCached(byteLength) {
        return byteLength > 0 && byteLength <= this.maxKeyLength;
      }
      find(bytes, inputOffset, byteLength) {
        const records = this.caches[byteLength - 1];
        FIND_CHUNK:
          for (const record of records) {
            const recordBytes = record.bytes;
            for (let j = 0; j < byteLength; j++) {
              if (recordBytes[j] !== bytes[inputOffset + j]) {
                continue FIND_CHUNK;
              }
            }
            return record.str;
          }
        return null;
      }
      store(bytes, value) {
        const records = this.caches[bytes.length - 1];
        const record = { bytes, str: value };
        if (records.length >= this.maxLengthPerKey) {
          records[Math.random() * records.length | 0] = record;
        } else {
          records.push(record);
        }
      }
      decode(bytes, inputOffset, byteLength) {
        const cachedValue = this.find(bytes, inputOffset, byteLength);
        if (cachedValue != null) {
          this.hit++;
          return cachedValue;
        }
        this.miss++;
        const str = (0, utf8_1.utf8DecodeJs)(bytes, inputOffset, byteLength);
        const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
        this.store(slicedCopyOfBytes, str);
        return str;
      }
    };
    exports.CachedKeyDecoder = CachedKeyDecoder;
  }
});

// node_modules/@msgpack/msgpack/dist/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/@msgpack/msgpack/dist/Decoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Decoder = exports.DataViewIndexOutOfBoundsError = void 0;
    var prettyByte_1 = require_prettyByte();
    var ExtensionCodec_1 = require_ExtensionCodec();
    var int_1 = require_int();
    var utf8_1 = require_utf8();
    var typedArrays_1 = require_typedArrays();
    var CachedKeyDecoder_1 = require_CachedKeyDecoder();
    var DecodeError_1 = require_DecodeError();
    var isValidMapKeyType = (key) => {
      const keyType = typeof key;
      return keyType === "string" || keyType === "number";
    };
    var HEAD_BYTE_REQUIRED = -1;
    var EMPTY_VIEW = new DataView(new ArrayBuffer(0));
    var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
    exports.DataViewIndexOutOfBoundsError = (() => {
      try {
        EMPTY_VIEW.getInt8(0);
      } catch (e) {
        return e.constructor;
      }
      throw new Error("never reached");
    })();
    var MORE_DATA = new exports.DataViewIndexOutOfBoundsError("Insufficient data");
    var sharedCachedKeyDecoder = new CachedKeyDecoder_1.CachedKeyDecoder();
    var Decoder = class {
      constructor(extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = void 0, maxStrLength = int_1.UINT32_MAX, maxBinLength = int_1.UINT32_MAX, maxArrayLength = int_1.UINT32_MAX, maxMapLength = int_1.UINT32_MAX, maxExtLength = int_1.UINT32_MAX, keyDecoder = sharedCachedKeyDecoder) {
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxStrLength = maxStrLength;
        this.maxBinLength = maxBinLength;
        this.maxArrayLength = maxArrayLength;
        this.maxMapLength = maxMapLength;
        this.maxExtLength = maxExtLength;
        this.keyDecoder = keyDecoder;
        this.totalPos = 0;
        this.pos = 0;
        this.view = EMPTY_VIEW;
        this.bytes = EMPTY_BYTES;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack = [];
      }
      reinitializeState() {
        this.totalPos = 0;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack.length = 0;
      }
      setBuffer(buffer) {
        this.bytes = (0, typedArrays_1.ensureUint8Array)(buffer);
        this.view = (0, typedArrays_1.createDataView)(this.bytes);
        this.pos = 0;
      }
      appendBuffer(buffer) {
        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
          this.setBuffer(buffer);
        } else {
          const remainingData = this.bytes.subarray(this.pos);
          const newData = (0, typedArrays_1.ensureUint8Array)(buffer);
          const newBuffer = new Uint8Array(remainingData.length + newData.length);
          newBuffer.set(remainingData);
          newBuffer.set(newData, remainingData.length);
          this.setBuffer(newBuffer);
        }
      }
      hasRemaining(size) {
        return this.view.byteLength - this.pos >= size;
      }
      createExtraByteError(posToShow) {
        const { view, pos } = this;
        return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
      }
      /**
       * @throws {@link DecodeError}
       * @throws {@link RangeError}
       */
      decode(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        const object = this.doDecodeSync();
        if (this.hasRemaining(1)) {
          throw this.createExtraByteError(this.pos);
        }
        return object;
      }
      *decodeMulti(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        while (this.hasRemaining(1)) {
          yield this.doDecodeSync();
        }
      }
      async decodeAsync(stream) {
        let decoded = false;
        let object;
        for await (const buffer of stream) {
          if (decoded) {
            throw this.createExtraByteError(this.totalPos);
          }
          this.appendBuffer(buffer);
          try {
            object = this.doDecodeSync();
            decoded = true;
          } catch (e) {
            if (!(e instanceof exports.DataViewIndexOutOfBoundsError)) {
              throw e;
            }
          }
          this.totalPos += this.pos;
        }
        if (decoded) {
          if (this.hasRemaining(1)) {
            throw this.createExtraByteError(this.totalPos);
          }
          return object;
        }
        const { headByte, pos, totalPos } = this;
        throw new RangeError(`Insufficient data in parsing ${(0, prettyByte_1.prettyByte)(headByte)} at ${totalPos} (${pos} in the current buffer)`);
      }
      decodeArrayStream(stream) {
        return this.decodeMultiAsync(stream, true);
      }
      decodeStream(stream) {
        return this.decodeMultiAsync(stream, false);
      }
      async *decodeMultiAsync(stream, isArray) {
        let isArrayHeaderRequired = isArray;
        let arrayItemsLeft = -1;
        for await (const buffer of stream) {
          if (isArray && arrayItemsLeft === 0) {
            throw this.createExtraByteError(this.totalPos);
          }
          this.appendBuffer(buffer);
          if (isArrayHeaderRequired) {
            arrayItemsLeft = this.readArraySize();
            isArrayHeaderRequired = false;
            this.complete();
          }
          try {
            while (true) {
              yield this.doDecodeSync();
              if (--arrayItemsLeft === 0) {
                break;
              }
            }
          } catch (e) {
            if (!(e instanceof exports.DataViewIndexOutOfBoundsError)) {
              throw e;
            }
          }
          this.totalPos += this.pos;
        }
      }
      doDecodeSync() {
        DECODE:
          while (true) {
            const headByte = this.readHeadByte();
            let object;
            if (headByte >= 224) {
              object = headByte - 256;
            } else if (headByte < 192) {
              if (headByte < 128) {
                object = headByte;
              } else if (headByte < 144) {
                const size = headByte - 128;
                if (size !== 0) {
                  this.pushMapState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = {};
                }
              } else if (headByte < 160) {
                const size = headByte - 144;
                if (size !== 0) {
                  this.pushArrayState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = [];
                }
              } else {
                const byteLength = headByte - 160;
                object = this.decodeUtf8String(byteLength, 0);
              }
            } else if (headByte === 192) {
              object = null;
            } else if (headByte === 194) {
              object = false;
            } else if (headByte === 195) {
              object = true;
            } else if (headByte === 202) {
              object = this.readF32();
            } else if (headByte === 203) {
              object = this.readF64();
            } else if (headByte === 204) {
              object = this.readU8();
            } else if (headByte === 205) {
              object = this.readU16();
            } else if (headByte === 206) {
              object = this.readU32();
            } else if (headByte === 207) {
              object = this.readU64();
            } else if (headByte === 208) {
              object = this.readI8();
            } else if (headByte === 209) {
              object = this.readI16();
            } else if (headByte === 210) {
              object = this.readI32();
            } else if (headByte === 211) {
              object = this.readI64();
            } else if (headByte === 217) {
              const byteLength = this.lookU8();
              object = this.decodeUtf8String(byteLength, 1);
            } else if (headByte === 218) {
              const byteLength = this.lookU16();
              object = this.decodeUtf8String(byteLength, 2);
            } else if (headByte === 219) {
              const byteLength = this.lookU32();
              object = this.decodeUtf8String(byteLength, 4);
            } else if (headByte === 220) {
              const size = this.readU16();
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else if (headByte === 221) {
              const size = this.readU32();
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else if (headByte === 222) {
              const size = this.readU16();
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte === 223) {
              const size = this.readU32();
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte === 196) {
              const size = this.lookU8();
              object = this.decodeBinary(size, 1);
            } else if (headByte === 197) {
              const size = this.lookU16();
              object = this.decodeBinary(size, 2);
            } else if (headByte === 198) {
              const size = this.lookU32();
              object = this.decodeBinary(size, 4);
            } else if (headByte === 212) {
              object = this.decodeExtension(1, 0);
            } else if (headByte === 213) {
              object = this.decodeExtension(2, 0);
            } else if (headByte === 214) {
              object = this.decodeExtension(4, 0);
            } else if (headByte === 215) {
              object = this.decodeExtension(8, 0);
            } else if (headByte === 216) {
              object = this.decodeExtension(16, 0);
            } else if (headByte === 199) {
              const size = this.lookU8();
              object = this.decodeExtension(size, 1);
            } else if (headByte === 200) {
              const size = this.lookU16();
              object = this.decodeExtension(size, 2);
            } else if (headByte === 201) {
              const size = this.lookU32();
              object = this.decodeExtension(size, 4);
            } else {
              throw new DecodeError_1.DecodeError(`Unrecognized type byte: ${(0, prettyByte_1.prettyByte)(headByte)}`);
            }
            this.complete();
            const stack = this.stack;
            while (stack.length > 0) {
              const state = stack[stack.length - 1];
              if (state.type === 0) {
                state.array[state.position] = object;
                state.position++;
                if (state.position === state.size) {
                  stack.pop();
                  object = state.array;
                } else {
                  continue DECODE;
                }
              } else if (state.type === 1) {
                if (!isValidMapKeyType(object)) {
                  throw new DecodeError_1.DecodeError("The type of key must be string or number but " + typeof object);
                }
                if (object === "__proto__") {
                  throw new DecodeError_1.DecodeError("The key __proto__ is not allowed");
                }
                state.key = object;
                state.type = 2;
                continue DECODE;
              } else {
                state.map[state.key] = object;
                state.readCount++;
                if (state.readCount === state.size) {
                  stack.pop();
                  object = state.map;
                } else {
                  state.key = null;
                  state.type = 1;
                  continue DECODE;
                }
              }
            }
            return object;
          }
      }
      readHeadByte() {
        if (this.headByte === HEAD_BYTE_REQUIRED) {
          this.headByte = this.readU8();
        }
        return this.headByte;
      }
      complete() {
        this.headByte = HEAD_BYTE_REQUIRED;
      }
      readArraySize() {
        const headByte = this.readHeadByte();
        switch (headByte) {
          case 220:
            return this.readU16();
          case 221:
            return this.readU32();
          default: {
            if (headByte < 160) {
              return headByte - 144;
            } else {
              throw new DecodeError_1.DecodeError(`Unrecognized array type byte: ${(0, prettyByte_1.prettyByte)(headByte)}`);
            }
          }
        }
      }
      pushMapState(size) {
        if (size > this.maxMapLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);
        }
        this.stack.push({
          type: 1,
          size,
          key: null,
          readCount: 0,
          map: {}
        });
      }
      pushArrayState(size) {
        if (size > this.maxArrayLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);
        }
        this.stack.push({
          type: 0,
          size,
          array: new Array(size),
          position: 0
        });
      }
      decodeUtf8String(byteLength, headerOffset) {
        var _a;
        if (byteLength > this.maxStrLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
        }
        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
          throw MORE_DATA;
        }
        const offset = this.pos + headerOffset;
        let object;
        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
          object = this.keyDecoder.decode(this.bytes, offset, byteLength);
        } else if (byteLength > utf8_1.TEXT_DECODER_THRESHOLD) {
          object = (0, utf8_1.utf8DecodeTD)(this.bytes, offset, byteLength);
        } else {
          object = (0, utf8_1.utf8DecodeJs)(this.bytes, offset, byteLength);
        }
        this.pos += headerOffset + byteLength;
        return object;
      }
      stateIsMapKey() {
        if (this.stack.length > 0) {
          const state = this.stack[this.stack.length - 1];
          return state.type === 1;
        }
        return false;
      }
      decodeBinary(byteLength, headOffset) {
        if (byteLength > this.maxBinLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
        }
        if (!this.hasRemaining(byteLength + headOffset)) {
          throw MORE_DATA;
        }
        const offset = this.pos + headOffset;
        const object = this.bytes.subarray(offset, offset + byteLength);
        this.pos += headOffset + byteLength;
        return object;
      }
      decodeExtension(size, headOffset) {
        if (size > this.maxExtLength) {
          throw new DecodeError_1.DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);
        }
        const extType = this.view.getInt8(this.pos + headOffset);
        const data = this.decodeBinary(
          size,
          headOffset + 1
          /* extType */
        );
        return this.extensionCodec.decode(data, extType, this.context);
      }
      lookU8() {
        return this.view.getUint8(this.pos);
      }
      lookU16() {
        return this.view.getUint16(this.pos);
      }
      lookU32() {
        return this.view.getUint32(this.pos);
      }
      readU8() {
        const value = this.view.getUint8(this.pos);
        this.pos++;
        return value;
      }
      readI8() {
        const value = this.view.getInt8(this.pos);
        this.pos++;
        return value;
      }
      readU16() {
        const value = this.view.getUint16(this.pos);
        this.pos += 2;
        return value;
      }
      readI16() {
        const value = this.view.getInt16(this.pos);
        this.pos += 2;
        return value;
      }
      readU32() {
        const value = this.view.getUint32(this.pos);
        this.pos += 4;
        return value;
      }
      readI32() {
        const value = this.view.getInt32(this.pos);
        this.pos += 4;
        return value;
      }
      readU64() {
        const value = (0, int_1.getUint64)(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readI64() {
        const value = (0, int_1.getInt64)(this.view, this.pos);
        this.pos += 8;
        return value;
      }
      readF32() {
        const value = this.view.getFloat32(this.pos);
        this.pos += 4;
        return value;
      }
      readF64() {
        const value = this.view.getFloat64(this.pos);
        this.pos += 8;
        return value;
      }
    };
    exports.Decoder = Decoder;
  }
});

// node_modules/@msgpack/msgpack/dist/decode.js
var require_decode = __commonJS({
  "node_modules/@msgpack/msgpack/dist/decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeMulti = exports.decode = exports.defaultDecodeOptions = void 0;
    var Decoder_1 = require_Decoder();
    exports.defaultDecodeOptions = {};
    function decode(buffer, options = exports.defaultDecodeOptions) {
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decode(buffer);
    }
    exports.decode = decode;
    function decodeMulti(buffer, options = exports.defaultDecodeOptions) {
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeMulti(buffer);
    }
    exports.decodeMulti = decodeMulti;
  }
});

// node_modules/@msgpack/msgpack/dist/utils/stream.js
var require_stream = __commonJS({
  "node_modules/@msgpack/msgpack/dist/utils/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ensureAsyncIterable = exports.asyncIterableFromStream = exports.isAsyncIterable = void 0;
    function isAsyncIterable(object) {
      return object[Symbol.asyncIterator] != null;
    }
    exports.isAsyncIterable = isAsyncIterable;
    function assertNonNull(value) {
      if (value == null) {
        throw new Error("Assertion Failure: value must not be null nor undefined");
      }
    }
    async function* asyncIterableFromStream(stream) {
      const reader = stream.getReader();
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            return;
          }
          assertNonNull(value);
          yield value;
        }
      } finally {
        reader.releaseLock();
      }
    }
    exports.asyncIterableFromStream = asyncIterableFromStream;
    function ensureAsyncIterable(streamLike) {
      if (isAsyncIterable(streamLike)) {
        return streamLike;
      } else {
        return asyncIterableFromStream(streamLike);
      }
    }
    exports.ensureAsyncIterable = ensureAsyncIterable;
  }
});

// node_modules/@msgpack/msgpack/dist/decodeAsync.js
var require_decodeAsync = __commonJS({
  "node_modules/@msgpack/msgpack/dist/decodeAsync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeStream = exports.decodeMultiStream = exports.decodeArrayStream = exports.decodeAsync = void 0;
    var Decoder_1 = require_Decoder();
    var stream_1 = require_stream();
    var decode_1 = require_decode();
    async function decodeAsync(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeAsync(stream);
    }
    exports.decodeAsync = decodeAsync;
    function decodeArrayStream(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeArrayStream(stream);
    }
    exports.decodeArrayStream = decodeArrayStream;
    function decodeMultiStream(streamLike, options = decode_1.defaultDecodeOptions) {
      const stream = (0, stream_1.ensureAsyncIterable)(streamLike);
      const decoder = new Decoder_1.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
      return decoder.decodeStream(stream);
    }
    exports.decodeMultiStream = decodeMultiStream;
    function decodeStream(streamLike, options = decode_1.defaultDecodeOptions) {
      return decodeMultiStream(streamLike, options);
    }
    exports.decodeStream = decodeStream;
  }
});

// node_modules/@msgpack/msgpack/dist/index.js
var require_dist = __commonJS({
  "node_modules/@msgpack/msgpack/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeTimestampExtension = exports.encodeTimestampExtension = exports.decodeTimestampToTimeSpec = exports.encodeTimeSpecToTimestamp = exports.encodeDateToTimeSpec = exports.EXT_TIMESTAMP = exports.ExtData = exports.ExtensionCodec = exports.Encoder = exports.DataViewIndexOutOfBoundsError = exports.DecodeError = exports.Decoder = exports.decodeStream = exports.decodeMultiStream = exports.decodeArrayStream = exports.decodeAsync = exports.decodeMulti = exports.decode = exports.encode = void 0;
    var encode_1 = require_encode();
    Object.defineProperty(exports, "encode", { enumerable: true, get: function() {
      return encode_1.encode;
    } });
    var decode_1 = require_decode();
    Object.defineProperty(exports, "decode", { enumerable: true, get: function() {
      return decode_1.decode;
    } });
    Object.defineProperty(exports, "decodeMulti", { enumerable: true, get: function() {
      return decode_1.decodeMulti;
    } });
    var decodeAsync_1 = require_decodeAsync();
    Object.defineProperty(exports, "decodeAsync", { enumerable: true, get: function() {
      return decodeAsync_1.decodeAsync;
    } });
    Object.defineProperty(exports, "decodeArrayStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeArrayStream;
    } });
    Object.defineProperty(exports, "decodeMultiStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeMultiStream;
    } });
    Object.defineProperty(exports, "decodeStream", { enumerable: true, get: function() {
      return decodeAsync_1.decodeStream;
    } });
    var Decoder_1 = require_Decoder();
    Object.defineProperty(exports, "Decoder", { enumerable: true, get: function() {
      return Decoder_1.Decoder;
    } });
    Object.defineProperty(exports, "DataViewIndexOutOfBoundsError", { enumerable: true, get: function() {
      return Decoder_1.DataViewIndexOutOfBoundsError;
    } });
    var DecodeError_1 = require_DecodeError();
    Object.defineProperty(exports, "DecodeError", { enumerable: true, get: function() {
      return DecodeError_1.DecodeError;
    } });
    var Encoder_1 = require_Encoder();
    Object.defineProperty(exports, "Encoder", { enumerable: true, get: function() {
      return Encoder_1.Encoder;
    } });
    var ExtensionCodec_1 = require_ExtensionCodec();
    Object.defineProperty(exports, "ExtensionCodec", { enumerable: true, get: function() {
      return ExtensionCodec_1.ExtensionCodec;
    } });
    var ExtData_1 = require_ExtData();
    Object.defineProperty(exports, "ExtData", { enumerable: true, get: function() {
      return ExtData_1.ExtData;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports, "EXT_TIMESTAMP", { enumerable: true, get: function() {
      return timestamp_1.EXT_TIMESTAMP;
    } });
    Object.defineProperty(exports, "encodeDateToTimeSpec", { enumerable: true, get: function() {
      return timestamp_1.encodeDateToTimeSpec;
    } });
    Object.defineProperty(exports, "encodeTimeSpecToTimestamp", { enumerable: true, get: function() {
      return timestamp_1.encodeTimeSpecToTimestamp;
    } });
    Object.defineProperty(exports, "decodeTimestampToTimeSpec", { enumerable: true, get: function() {
      return timestamp_1.decodeTimestampToTimeSpec;
    } });
    Object.defineProperty(exports, "encodeTimestampExtension", { enumerable: true, get: function() {
      return timestamp_1.encodeTimestampExtension;
    } });
    Object.defineProperty(exports, "decodeTimestampExtension", { enumerable: true, get: function() {
      return timestamp_1.decodeTimestampExtension;
    } });
  }
});

// node_modules/neovim/lib/utils/util.js
var require_util = __commonJS({
  "node_modules/neovim/lib/utils/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.partialClone = void 0;
    function partialClone(obj, depth = 3, omitKeys = [], replacement = void 0) {
      if (typeof obj !== "object" || obj === null || Object.getOwnPropertyNames(obj).length === 0) {
        return obj;
      }
      const clonedObj = Array.isArray(obj) ? [] : {};
      if (depth === 0) {
        return replacement || clonedObj;
      }
      for (const key of Object.keys(obj)) {
        if (omitKeys.includes(key)) {
          clonedObj[key] = replacement || (Array.isArray(obj) ? [] : {});
        } else if (Object.prototype.hasOwnProperty.call(obj, key)) {
          clonedObj[key] = partialClone(obj[key], depth - 1, omitKeys, replacement);
        }
      }
      return clonedObj;
    }
    exports.partialClone = partialClone;
  }
});

// node_modules/logform/format.js
var require_format = __commonJS({
  "node_modules/logform/format.js"(exports, module2) {
    "use strict";
    var InvalidFormatError = class extends Error {
      constructor(formatFn) {
        super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split("\n")[0]}
`);
        Error.captureStackTrace(this, InvalidFormatError);
      }
    };
    module2.exports = (formatFn) => {
      if (formatFn.length > 2) {
        throw new InvalidFormatError(formatFn);
      }
      function Format(options = {}) {
        this.options = options;
      }
      Format.prototype.transform = formatFn;
      function createFormatWrap(opts) {
        return new Format(opts);
      }
      createFormatWrap.Format = Format;
      return createFormatWrap;
    };
  }
});

// node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS({
  "node_modules/@colors/colors/lib/styles.js"(exports, module2) {
    var styles = {};
    module2["exports"] = styles;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag = __commonJS({
  "node_modules/@colors/colors/lib/system/has-flag.js"(exports, module2) {
    "use strict";
    module2.exports = function(flag, argv) {
      argv = argv || process.argv || [];
      var terminatorPos = argv.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "node_modules/@colors/colors/lib/system/supports-colors.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor = void 0;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      var min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
          return sign in env;
        }) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env) {
        var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      var level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "node_modules/@colors/colors/lib/custom/trap.js"(exports, module2) {
    module2["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "node_modules/@colors/colors/lib/custom/zalgo.js"(exports, module2) {
    module2["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function isChar(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "";
        var counts;
        var l;
        options2 = options2 || {};
        options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
        options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
        options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
        options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text, options);
    };
  }
});

// node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS({
  "node_modules/@colors/colors/lib/maps/america.js"(exports, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        if (letter === " ")
          return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "node_modules/@colors/colors/lib/maps/zebra.js"(exports, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        return i % 2 === 0 ? letter : colors.inverse(letter);
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "node_modules/@colors/colors/lib/maps/rainbow.js"(exports, module2) {
    module2["exports"] = function(colors) {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS({
  "node_modules/@colors/colors/lib/maps/random.js"(exports, module2) {
    module2["exports"] = function(colors) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
      };
    };
  }
});

// node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS({
  "node_modules/@colors/colors/lib/colors.js"(exports, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var util = require("util");
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors.supportsColor = require_supports_colors().supportsColor;
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor() !== false;
    }
    colors.enable = function() {
      colors.enabled = true;
    };
    colors.disable = function() {
      colors.enabled = false;
    };
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      if (!colors.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors) {
        return colors[style](str);
      }
      return styleMap.open + str + styleMap.close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util.inspect(arg);
        }
      }).join(" ");
      if (!colors.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i in theme[style2]) {
                out = colors[theme[style2][i]](out);
              }
              return out;
            }
            return colors[theme[style2]](str);
          };
        })(style);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {
          get: function() {
            return build([name]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split("");
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america()(colors);
    colors.maps.zebra = require_zebra()(colors);
    colors.maps.rainbow = require_rainbow()(colors);
    colors.maps.random = require_random()(colors);
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init());
  }
});

// node_modules/@colors/colors/safe.js
var require_safe = __commonJS({
  "node_modules/@colors/colors/safe.js"(exports, module2) {
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// node_modules/triple-beam/config/cli.js
var require_cli = __commonJS({
  "node_modules/triple-beam/config/cli.js"(exports) {
    "use strict";
    exports.levels = {
      error: 0,
      warn: 1,
      help: 2,
      data: 3,
      info: 4,
      debug: 5,
      prompt: 6,
      verbose: 7,
      input: 8,
      silly: 9
    };
    exports.colors = {
      error: "red",
      warn: "yellow",
      help: "cyan",
      data: "grey",
      info: "green",
      debug: "blue",
      prompt: "grey",
      verbose: "cyan",
      input: "grey",
      silly: "magenta"
    };
  }
});

// node_modules/triple-beam/config/npm.js
var require_npm = __commonJS({
  "node_modules/triple-beam/config/npm.js"(exports) {
    "use strict";
    exports.levels = {
      error: 0,
      warn: 1,
      info: 2,
      http: 3,
      verbose: 4,
      debug: 5,
      silly: 6
    };
    exports.colors = {
      error: "red",
      warn: "yellow",
      info: "green",
      http: "green",
      verbose: "cyan",
      debug: "blue",
      silly: "magenta"
    };
  }
});

// node_modules/triple-beam/config/syslog.js
var require_syslog = __commonJS({
  "node_modules/triple-beam/config/syslog.js"(exports) {
    "use strict";
    exports.levels = {
      emerg: 0,
      alert: 1,
      crit: 2,
      error: 3,
      warning: 4,
      notice: 5,
      info: 6,
      debug: 7
    };
    exports.colors = {
      emerg: "red",
      alert: "yellow",
      crit: "red",
      error: "red",
      warning: "red",
      notice: "yellow",
      info: "green",
      debug: "blue"
    };
  }
});

// node_modules/triple-beam/config/index.js
var require_config = __commonJS({
  "node_modules/triple-beam/config/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "cli", {
      value: require_cli()
    });
    Object.defineProperty(exports, "npm", {
      value: require_npm()
    });
    Object.defineProperty(exports, "syslog", {
      value: require_syslog()
    });
  }
});

// node_modules/triple-beam/index.js
var require_triple_beam = __commonJS({
  "node_modules/triple-beam/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "LEVEL", {
      value: Symbol.for("level")
    });
    Object.defineProperty(exports, "MESSAGE", {
      value: Symbol.for("message")
    });
    Object.defineProperty(exports, "SPLAT", {
      value: Symbol.for("splat")
    });
    Object.defineProperty(exports, "configs", {
      value: require_config()
    });
  }
});

// node_modules/logform/colorize.js
var require_colorize = __commonJS({
  "node_modules/logform/colorize.js"(exports, module2) {
    "use strict";
    var colors = require_safe();
    var { LEVEL, MESSAGE } = require_triple_beam();
    colors.enabled = true;
    var hasSpace = /\s+/;
    var Colorizer = class {
      constructor(opts = {}) {
        if (opts.colors) {
          this.addColors(opts.colors);
        }
        this.options = opts;
      }
      /*
       * Adds the colors Object to the set of allColors
       * known by the Colorizer
       *
       * @param {Object} colors Set of color mappings to add.
       */
      static addColors(clrs) {
        const nextColors = Object.keys(clrs).reduce((acc, level) => {
          acc[level] = hasSpace.test(clrs[level]) ? clrs[level].split(hasSpace) : clrs[level];
          return acc;
        }, {});
        Colorizer.allColors = Object.assign({}, Colorizer.allColors || {}, nextColors);
        return Colorizer.allColors;
      }
      /*
       * Adds the colors Object to the set of allColors
       * known by the Colorizer
       *
       * @param {Object} colors Set of color mappings to add.
       */
      addColors(clrs) {
        return Colorizer.addColors(clrs);
      }
      /*
       * function colorize (lookup, level, message)
       * Performs multi-step colorization using @colors/colors/safe
       */
      colorize(lookup, level, message) {
        if (typeof message === "undefined") {
          message = level;
        }
        if (!Array.isArray(Colorizer.allColors[lookup])) {
          return colors[Colorizer.allColors[lookup]](message);
        }
        for (let i = 0, len = Colorizer.allColors[lookup].length; i < len; i++) {
          message = colors[Colorizer.allColors[lookup][i]](message);
        }
        return message;
      }
      /*
       * function transform (info, opts)
       * Attempts to colorize the { level, message } of the given
       * `logform` info object.
       */
      transform(info, opts) {
        if (opts.all && typeof info[MESSAGE] === "string") {
          info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
        }
        if (opts.level || opts.all || !opts.message) {
          info.level = this.colorize(info[LEVEL], info.level);
        }
        if (opts.all || opts.message) {
          info.message = this.colorize(info[LEVEL], info.level, info.message);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Colorizer(opts);
    module2.exports.Colorizer = module2.exports.Format = Colorizer;
  }
});

// node_modules/logform/levels.js
var require_levels = __commonJS({
  "node_modules/logform/levels.js"(exports, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    module2.exports = (config) => {
      Colorizer.addColors(config.colors || config);
      return config;
    };
  }
});

// node_modules/logform/align.js
var require_align = __commonJS({
  "node_modules/logform/align.js"(exports, module2) {
    "use strict";
    var format = require_format();
    module2.exports = format((info) => {
      info.message = `	${info.message}`;
      return info;
    });
  }
});

// node_modules/logform/errors.js
var require_errors = __commonJS({
  "node_modules/logform/errors.js"(exports, module2) {
    "use strict";
    var format = require_format();
    var { LEVEL, MESSAGE } = require_triple_beam();
    module2.exports = format((einfo, { stack, cause }) => {
      if (einfo instanceof Error) {
        const info = Object.assign({}, einfo, {
          level: einfo.level,
          [LEVEL]: einfo[LEVEL] || einfo.level,
          message: einfo.message,
          [MESSAGE]: einfo[MESSAGE] || einfo.message
        });
        if (stack)
          info.stack = einfo.stack;
        if (cause)
          info.cause = einfo.cause;
        return info;
      }
      if (!(einfo.message instanceof Error))
        return einfo;
      const err = einfo.message;
      Object.assign(einfo, err);
      einfo.message = err.message;
      einfo[MESSAGE] = err.message;
      if (stack)
        einfo.stack = err.stack;
      if (cause)
        einfo.cause = err.cause;
      return einfo;
    });
  }
});

// node_modules/logform/pad-levels.js
var require_pad_levels = __commonJS({
  "node_modules/logform/pad-levels.js"(exports, module2) {
    "use strict";
    var { configs, LEVEL, MESSAGE } = require_triple_beam();
    var Padder = class {
      constructor(opts = { levels: configs.npm.levels }) {
        this.paddings = Padder.paddingForLevels(opts.levels, opts.filler);
        this.options = opts;
      }
      /**
       * Returns the maximum length of keys in the specified `levels` Object.
       * @param  {Object} levels Set of all levels to calculate longest level against.
       * @returns {Number} Maximum length of the longest level string.
       */
      static getLongestLevel(levels) {
        const lvls = Object.keys(levels).map((level) => level.length);
        return Math.max(...lvls);
      }
      /**
       * Returns the padding for the specified `level` assuming that the
       * maximum length of all levels it's associated with is `maxLength`.
       * @param  {String} level Level to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @param  {Number} maxLength Length of the longest level
       * @returns {String} Padding string for the `level`
       */
      static paddingForLevel(level, filler, maxLength) {
        const targetLen = maxLength + 1 - level.length;
        const rep = Math.floor(targetLen / filler.length);
        const padding = `${filler}${filler.repeat(rep)}`;
        return padding.slice(0, targetLen);
      }
      /**
       * Returns an object with the string paddings for the given `levels`
       * using the specified `filler`.
       * @param  {Object} levels Set of all levels to calculate padding for.
       * @param  {String} filler Repeatable text to use for padding.
       * @returns {Object} Mapping of level to desired padding.
       */
      static paddingForLevels(levels, filler = " ") {
        const maxLength = Padder.getLongestLevel(levels);
        return Object.keys(levels).reduce((acc, level) => {
          acc[level] = Padder.paddingForLevel(level, filler, maxLength);
          return acc;
        }, {});
      }
      /**
       * Prepends the padding onto the `message` based on the `LEVEL` of
       * the `info`. This is based on the behavior of `winston@2` which also
       * prepended the level onto the message.
       *
       * See: https://github.com/winstonjs/winston/blob/2.x/lib/winston/logger.js#L198-L201
       *
       * @param  {Info} info Logform info object
       * @param  {Object} opts Options passed along to this instance.
       * @returns {Info} Modified logform info object.
       */
      transform(info, opts) {
        info.message = `${this.paddings[info[LEVEL]]}${info.message}`;
        if (info[MESSAGE]) {
          info[MESSAGE] = `${this.paddings[info[LEVEL]]}${info[MESSAGE]}`;
        }
        return info;
      }
    };
    module2.exports = (opts) => new Padder(opts);
    module2.exports.Padder = module2.exports.Format = Padder;
  }
});

// node_modules/logform/cli.js
var require_cli2 = __commonJS({
  "node_modules/logform/cli.js"(exports, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    var { Padder } = require_pad_levels();
    var { configs, MESSAGE } = require_triple_beam();
    var CliFormat = class {
      constructor(opts = {}) {
        if (!opts.levels) {
          opts.levels = configs.cli.levels;
        }
        this.colorizer = new Colorizer(opts);
        this.padder = new Padder(opts);
        this.options = opts;
      }
      /*
       * function transform (info, opts)
       * Attempts to both:
       * 1. Pad the { level }
       * 2. Colorize the { level, message }
       * of the given `logform` info object depending on the `opts`.
       */
      transform(info, opts) {
        this.colorizer.transform(
          this.padder.transform(info, opts),
          opts
        );
        info[MESSAGE] = `${info.level}:${info.message}`;
        return info;
      }
    };
    module2.exports = (opts) => new CliFormat(opts);
    module2.exports.Format = CliFormat;
  }
});

// node_modules/logform/combine.js
var require_combine = __commonJS({
  "node_modules/logform/combine.js"(exports, module2) {
    "use strict";
    var format = require_format();
    function cascade(formats) {
      if (!formats.every(isValidFormat)) {
        return;
      }
      return (info) => {
        let obj = info;
        for (let i = 0; i < formats.length; i++) {
          obj = formats[i].transform(obj, formats[i].options);
          if (!obj) {
            return false;
          }
        }
        return obj;
      };
    }
    function isValidFormat(fmt) {
      if (typeof fmt.transform !== "function") {
        throw new Error([
          "No transform function found on format. Did you create a format instance?",
          "const myFormat = format(formatFn);",
          "const instance = myFormat();"
        ].join("\n"));
      }
      return true;
    }
    module2.exports = (...formats) => {
      const combinedFormat = format(cascade(formats));
      const instance = combinedFormat();
      instance.Format = combinedFormat.Format;
      return instance;
    };
    module2.exports.cascade = cascade;
  }
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "node_modules/safe-stable-stringify/index.js"(exports, module2) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports.stringify = stringify;
    exports.configure = configure;
    module2.exports = stringify;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function insertSort(array) {
      if (array.length > 200) {
        return array.sort();
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function")
              message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getBooleanOption(options, "deterministic");
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join2;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join;
            }
            if (deterministic) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  }
});

// node_modules/logform/json.js
var require_json = __commonJS({
  "node_modules/logform/json.js"(exports, module2) {
    "use strict";
    var format = require_format();
    var { MESSAGE } = require_triple_beam();
    var stringify = require_safe_stable_stringify();
    function replacer(key, value) {
      if (typeof value === "bigint")
        return value.toString();
      return value;
    }
    module2.exports = format((info, opts) => {
      const jsonStringify = stringify.configure(opts);
      info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
      return info;
    });
  }
});

// node_modules/logform/label.js
var require_label = __commonJS({
  "node_modules/logform/label.js"(exports, module2) {
    "use strict";
    var format = require_format();
    module2.exports = format((info, opts) => {
      if (opts.message) {
        info.message = `[${opts.label}] ${info.message}`;
        return info;
      }
      info.label = opts.label;
      return info;
    });
  }
});

// node_modules/logform/logstash.js
var require_logstash = __commonJS({
  "node_modules/logform/logstash.js"(exports, module2) {
    "use strict";
    var format = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format((info) => {
      const logstash = {};
      if (info.message) {
        logstash["@message"] = info.message;
        delete info.message;
      }
      if (info.timestamp) {
        logstash["@timestamp"] = info.timestamp;
        delete info.timestamp;
      }
      logstash["@fields"] = info;
      info[MESSAGE] = jsonStringify(logstash);
      return info;
    });
  }
});

// node_modules/logform/metadata.js
var require_metadata = __commonJS({
  "node_modules/logform/metadata.js"(exports, module2) {
    "use strict";
    var format = require_format();
    function fillExcept(info, fillExceptKeys, metadataKey) {
      const savedKeys = fillExceptKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      const metadata = Object.keys(info).reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      Object.assign(info, savedKeys, {
        [metadataKey]: metadata
      });
      return info;
    }
    function fillWith(info, fillWithKeys, metadataKey) {
      info[metadataKey] = fillWithKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      return info;
    }
    module2.exports = format((info, opts = {}) => {
      let metadataKey = "metadata";
      if (opts.key) {
        metadataKey = opts.key;
      }
      let fillExceptKeys = [];
      if (!opts.fillExcept && !opts.fillWith) {
        fillExceptKeys.push("level");
        fillExceptKeys.push("message");
      }
      if (opts.fillExcept) {
        fillExceptKeys = opts.fillExcept;
      }
      if (fillExceptKeys.length > 0) {
        return fillExcept(info, fillExceptKeys, metadataKey);
      }
      if (opts.fillWith) {
        return fillWith(info, opts.fillWith, metadataKey);
      }
      return info;
    });
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/logform/ms.js
var require_ms2 = __commonJS({
  "node_modules/logform/ms.js"(exports, module2) {
    "use strict";
    var format = require_format();
    var ms = require_ms();
    module2.exports = format((info) => {
      const curr = +new Date();
      exports.diff = curr - (exports.prevTime || curr);
      exports.prevTime = curr;
      info.ms = `+${ms(exports.diff)}`;
      return info;
    });
  }
});

// node_modules/logform/pretty-print.js
var require_pretty_print = __commonJS({
  "node_modules/logform/pretty-print.js"(exports, module2) {
    "use strict";
    var inspect = require("util").inspect;
    var format = require_format();
    var { LEVEL, MESSAGE, SPLAT } = require_triple_beam();
    module2.exports = format((info, opts = {}) => {
      const stripped = Object.assign({}, info);
      delete stripped[LEVEL];
      delete stripped[MESSAGE];
      delete stripped[SPLAT];
      info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
      return info;
    });
  }
});

// node_modules/logform/printf.js
var require_printf = __commonJS({
  "node_modules/logform/printf.js"(exports, module2) {
    "use strict";
    var { MESSAGE } = require_triple_beam();
    var Printf = class {
      constructor(templateFn) {
        this.template = templateFn;
      }
      transform(info) {
        info[MESSAGE] = this.template(info);
        return info;
      }
    };
    module2.exports = (opts) => new Printf(opts);
    module2.exports.Printf = module2.exports.Format = Printf;
  }
});

// node_modules/logform/simple.js
var require_simple = __commonJS({
  "node_modules/logform/simple.js"(exports, module2) {
    "use strict";
    var format = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format((info) => {
      const stringifiedRest = jsonStringify(Object.assign({}, info, {
        level: void 0,
        message: void 0,
        splat: void 0
      }));
      const padding = info.padding && info.padding[info.level] || "";
      if (stringifiedRest !== "{}") {
        info[MESSAGE] = `${info.level}:${padding} ${info.message} ${stringifiedRest}`;
      } else {
        info[MESSAGE] = `${info.level}:${padding} ${info.message}`;
      }
      return info;
    });
  }
});

// node_modules/logform/splat.js
var require_splat = __commonJS({
  "node_modules/logform/splat.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var { SPLAT } = require_triple_beam();
    var formatRegExp = /%[scdjifoO%]/g;
    var escapedPercent = /%%/g;
    var Splatter = class {
      constructor(opts) {
        this.options = opts;
      }
      /**
         * Check to see if tokens <= splat.length, assign { splat, meta } into the
         * `info` accordingly, and write to this instance.
         *
         * @param  {Info} info Logform info message.
         * @param  {String[]} tokens Set of string interpolation tokens.
         * @returns {Info} Modified info message
         * @private
         */
      _splat(info, tokens) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat || [];
        const percents = msg.match(escapedPercent);
        const escapes = percents && percents.length || 0;
        const expectedSplat = tokens.length - escapes;
        const extraSplat = expectedSplat - splat.length;
        const metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : [];
        const metalen = metas.length;
        if (metalen) {
          for (let i = 0; i < metalen; i++) {
            Object.assign(info, metas[i]);
          }
        }
        info.message = util.format(msg, ...splat);
        return info;
      }
      /**
        * Transforms the `info` message by using `util.format` to complete
        * any `info.message` provided it has string interpolation tokens.
        * If no tokens exist then `info` is immutable.
        *
        * @param  {Info} info Logform info message.
        * @param  {Object} opts Options for this instance.
        * @returns {Info} Modified info message
        */
      transform(info) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat;
        if (!splat || !splat.length) {
          return info;
        }
        const tokens = msg && msg.match && msg.match(formatRegExp);
        if (!tokens && (splat || splat.length)) {
          const metas = splat.length > 1 ? splat.splice(0) : splat;
          const metalen = metas.length;
          if (metalen) {
            for (let i = 0; i < metalen; i++) {
              Object.assign(info, metas[i]);
            }
          }
          return info;
        }
        if (tokens) {
          return this._splat(info, tokens);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Splatter(opts);
  }
});

// node_modules/fecha/lib/fecha.umd.js
var require_fecha_umd = __commonJS({
  "node_modules/fecha/lib/fecha.umd.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.fecha = {});
    })(exports, function(exports2) {
      "use strict";
      var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
      var twoDigitsOptional = "\\d\\d?";
      var twoDigits = "\\d\\d";
      var threeDigits = "\\d{3}";
      var fourDigits = "\\d{4}";
      var word = "[^\\s]+";
      var literal = /\[([^]*?)\]/gm;
      function shorten(arr, sLen) {
        var newArr = [];
        for (var i = 0, len = arr.length; i < len; i++) {
          newArr.push(arr[i].substr(0, sLen));
        }
        return newArr;
      }
      var monthUpdate = function(arrName) {
        return function(v, i18n) {
          var lowerCaseArr = i18n[arrName].map(function(v2) {
            return v2.toLowerCase();
          });
          var index = lowerCaseArr.indexOf(v.toLowerCase());
          if (index > -1) {
            return index;
          }
          return null;
        };
      };
      function assign(origObj) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
          var obj = args_1[_a];
          for (var key in obj) {
            origObj[key] = obj[key];
          }
        }
        return origObj;
      }
      var dayNames = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ];
      var monthNames = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ];
      var monthNamesShort = shorten(monthNames, 3);
      var dayNamesShort = shorten(dayNames, 3);
      var defaultI18n = {
        dayNamesShort,
        dayNames,
        monthNamesShort,
        monthNames,
        amPm: ["am", "pm"],
        DoFn: function(dayOfMonth) {
          return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
        }
      };
      var globalI18n = assign({}, defaultI18n);
      var setGlobalDateI18n = function(i18n) {
        return globalI18n = assign(globalI18n, i18n);
      };
      var regexEscape = function(str) {
        return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
      };
      var pad = function(val, len) {
        if (len === void 0) {
          len = 2;
        }
        val = String(val);
        while (val.length < len) {
          val = "0" + val;
        }
        return val;
      };
      var formatFlags = {
        D: function(dateObj) {
          return String(dateObj.getDate());
        },
        DD: function(dateObj) {
          return pad(dateObj.getDate());
        },
        Do: function(dateObj, i18n) {
          return i18n.DoFn(dateObj.getDate());
        },
        d: function(dateObj) {
          return String(dateObj.getDay());
        },
        dd: function(dateObj) {
          return pad(dateObj.getDay());
        },
        ddd: function(dateObj, i18n) {
          return i18n.dayNamesShort[dateObj.getDay()];
        },
        dddd: function(dateObj, i18n) {
          return i18n.dayNames[dateObj.getDay()];
        },
        M: function(dateObj) {
          return String(dateObj.getMonth() + 1);
        },
        MM: function(dateObj) {
          return pad(dateObj.getMonth() + 1);
        },
        MMM: function(dateObj, i18n) {
          return i18n.monthNamesShort[dateObj.getMonth()];
        },
        MMMM: function(dateObj, i18n) {
          return i18n.monthNames[dateObj.getMonth()];
        },
        YY: function(dateObj) {
          return pad(String(dateObj.getFullYear()), 4).substr(2);
        },
        YYYY: function(dateObj) {
          return pad(dateObj.getFullYear(), 4);
        },
        h: function(dateObj) {
          return String(dateObj.getHours() % 12 || 12);
        },
        hh: function(dateObj) {
          return pad(dateObj.getHours() % 12 || 12);
        },
        H: function(dateObj) {
          return String(dateObj.getHours());
        },
        HH: function(dateObj) {
          return pad(dateObj.getHours());
        },
        m: function(dateObj) {
          return String(dateObj.getMinutes());
        },
        mm: function(dateObj) {
          return pad(dateObj.getMinutes());
        },
        s: function(dateObj) {
          return String(dateObj.getSeconds());
        },
        ss: function(dateObj) {
          return pad(dateObj.getSeconds());
        },
        S: function(dateObj) {
          return String(Math.round(dateObj.getMilliseconds() / 100));
        },
        SS: function(dateObj) {
          return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
        },
        SSS: function(dateObj) {
          return pad(dateObj.getMilliseconds(), 3);
        },
        a: function(dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
        },
        A: function(dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
        },
        ZZ: function(dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
        },
        Z: function(dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
        }
      };
      var monthParse = function(v) {
        return +v - 1;
      };
      var emptyDigits = [null, twoDigitsOptional];
      var emptyWord = [null, word];
      var amPm = [
        "isPm",
        word,
        function(v, i18n) {
          var val = v.toLowerCase();
          if (val === i18n.amPm[0]) {
            return 0;
          } else if (val === i18n.amPm[1]) {
            return 1;
          }
          return null;
        }
      ];
      var timezoneOffset = [
        "timezoneOffset",
        "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
        function(v) {
          var parts = (v + "").match(/([+-]|\d\d)/gi);
          if (parts) {
            var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
            return parts[0] === "+" ? minutes : -minutes;
          }
          return 0;
        }
      ];
      var parseFlags = {
        D: ["day", twoDigitsOptional],
        DD: ["day", twoDigits],
        Do: ["day", twoDigitsOptional + word, function(v) {
          return parseInt(v, 10);
        }],
        M: ["month", twoDigitsOptional, monthParse],
        MM: ["month", twoDigits, monthParse],
        YY: [
          "year",
          twoDigits,
          function(v) {
            var now = new Date();
            var cent = +("" + now.getFullYear()).substr(0, 2);
            return +("" + (+v > 68 ? cent - 1 : cent) + v);
          }
        ],
        h: ["hour", twoDigitsOptional, void 0, "isPm"],
        hh: ["hour", twoDigits, void 0, "isPm"],
        H: ["hour", twoDigitsOptional],
        HH: ["hour", twoDigits],
        m: ["minute", twoDigitsOptional],
        mm: ["minute", twoDigits],
        s: ["second", twoDigitsOptional],
        ss: ["second", twoDigits],
        YYYY: ["year", fourDigits],
        S: ["millisecond", "\\d", function(v) {
          return +v * 100;
        }],
        SS: ["millisecond", twoDigits, function(v) {
          return +v * 10;
        }],
        SSS: ["millisecond", threeDigits],
        d: emptyDigits,
        dd: emptyDigits,
        ddd: emptyWord,
        dddd: emptyWord,
        MMM: ["month", word, monthUpdate("monthNamesShort")],
        MMMM: ["month", word, monthUpdate("monthNames")],
        a: amPm,
        A: amPm,
        ZZ: timezoneOffset,
        Z: timezoneOffset
      };
      var globalMasks = {
        default: "ddd MMM DD YYYY HH:mm:ss",
        shortDate: "M/D/YY",
        mediumDate: "MMM D, YYYY",
        longDate: "MMMM D, YYYY",
        fullDate: "dddd, MMMM D, YYYY",
        isoDate: "YYYY-MM-DD",
        isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
        shortTime: "HH:mm",
        mediumTime: "HH:mm:ss",
        longTime: "HH:mm:ss.SSS"
      };
      var setGlobalDateMasks = function(masks) {
        return assign(globalMasks, masks);
      };
      var format = function(dateObj, mask, i18n) {
        if (mask === void 0) {
          mask = globalMasks["default"];
        }
        if (i18n === void 0) {
          i18n = {};
        }
        if (typeof dateObj === "number") {
          dateObj = new Date(dateObj);
        }
        if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
          throw new Error("Invalid Date pass to format");
        }
        mask = globalMasks[mask] || mask;
        var literals = [];
        mask = mask.replace(literal, function($0, $1) {
          literals.push($1);
          return "@@@";
        });
        var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
        mask = mask.replace(token, function($0) {
          return formatFlags[$0](dateObj, combinedI18nSettings);
        });
        return mask.replace(/@@@/g, function() {
          return literals.shift();
        });
      };
      function parse(dateStr, format2, i18n) {
        if (i18n === void 0) {
          i18n = {};
        }
        if (typeof format2 !== "string") {
          throw new Error("Invalid format in fecha parse");
        }
        format2 = globalMasks[format2] || format2;
        if (dateStr.length > 1e3) {
          return null;
        }
        var today = new Date();
        var dateInfo = {
          year: today.getFullYear(),
          month: 0,
          day: 1,
          hour: 0,
          minute: 0,
          second: 0,
          millisecond: 0,
          isPm: null,
          timezoneOffset: null
        };
        var parseInfo = [];
        var literals = [];
        var newFormat = format2.replace(literal, function($0, $1) {
          literals.push(regexEscape($1));
          return "@@@";
        });
        var specifiedFields = {};
        var requiredFields = {};
        newFormat = regexEscape(newFormat).replace(token, function($0) {
          var info = parseFlags[$0];
          var field2 = info[0], regex = info[1], requiredField = info[3];
          if (specifiedFields[field2]) {
            throw new Error("Invalid format. " + field2 + " specified twice in format");
          }
          specifiedFields[field2] = true;
          if (requiredField) {
            requiredFields[requiredField] = true;
          }
          parseInfo.push(info);
          return "(" + regex + ")";
        });
        Object.keys(requiredFields).forEach(function(field2) {
          if (!specifiedFields[field2]) {
            throw new Error("Invalid format. " + field2 + " is required in specified format");
          }
        });
        newFormat = newFormat.replace(/@@@/g, function() {
          return literals.shift();
        });
        var matches = dateStr.match(new RegExp(newFormat, "i"));
        if (!matches) {
          return null;
        }
        var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
        for (var i = 1; i < matches.length; i++) {
          var _a = parseInfo[i - 1], field = _a[0], parser = _a[2];
          var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
          if (value == null) {
            return null;
          }
          dateInfo[field] = value;
        }
        if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
          dateInfo.hour = +dateInfo.hour + 12;
        } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
          dateInfo.hour = 0;
        }
        var dateTZ;
        if (dateInfo.timezoneOffset == null) {
          dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
          var validateFields = [
            ["month", "getMonth"],
            ["day", "getDate"],
            ["hour", "getHours"],
            ["minute", "getMinutes"],
            ["second", "getSeconds"]
          ];
          for (var i = 0, len = validateFields.length; i < len; i++) {
            if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
              return null;
            }
          }
        } else {
          dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
          if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
            return null;
          }
        }
        return dateTZ;
      }
      var fecha = {
        format,
        parse,
        defaultI18n,
        setGlobalDateI18n,
        setGlobalDateMasks
      };
      exports2.assign = assign;
      exports2.default = fecha;
      exports2.format = format;
      exports2.parse = parse;
      exports2.defaultI18n = defaultI18n;
      exports2.setGlobalDateI18n = setGlobalDateI18n;
      exports2.setGlobalDateMasks = setGlobalDateMasks;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/logform/timestamp.js
var require_timestamp2 = __commonJS({
  "node_modules/logform/timestamp.js"(exports, module2) {
    "use strict";
    var fecha = require_fecha_umd();
    var format = require_format();
    module2.exports = format((info, opts = {}) => {
      if (opts.format) {
        info.timestamp = typeof opts.format === "function" ? opts.format() : fecha.format(new Date(), opts.format);
      }
      if (!info.timestamp) {
        info.timestamp = new Date().toISOString();
      }
      if (opts.alias) {
        info[opts.alias] = info.timestamp;
      }
      return info;
    });
  }
});

// node_modules/logform/uncolorize.js
var require_uncolorize = __commonJS({
  "node_modules/logform/uncolorize.js"(exports, module2) {
    "use strict";
    var colors = require_safe();
    var format = require_format();
    var { MESSAGE } = require_triple_beam();
    module2.exports = format((info, opts) => {
      if (opts.level !== false) {
        info.level = colors.strip(info.level);
      }
      if (opts.message !== false) {
        info.message = colors.strip(String(info.message));
      }
      if (opts.raw !== false && info[MESSAGE]) {
        info[MESSAGE] = colors.strip(String(info[MESSAGE]));
      }
      return info;
    });
  }
});

// node_modules/logform/index.js
var require_logform = __commonJS({
  "node_modules/logform/index.js"(exports) {
    "use strict";
    var format = exports.format = require_format();
    exports.levels = require_levels();
    function exposeFormat(name, requireFormat) {
      Object.defineProperty(format, name, {
        get() {
          return requireFormat();
        },
        configurable: true
      });
    }
    exposeFormat("align", function() {
      return require_align();
    });
    exposeFormat("errors", function() {
      return require_errors();
    });
    exposeFormat("cli", function() {
      return require_cli2();
    });
    exposeFormat("combine", function() {
      return require_combine();
    });
    exposeFormat("colorize", function() {
      return require_colorize();
    });
    exposeFormat("json", function() {
      return require_json();
    });
    exposeFormat("label", function() {
      return require_label();
    });
    exposeFormat("logstash", function() {
      return require_logstash();
    });
    exposeFormat("metadata", function() {
      return require_metadata();
    });
    exposeFormat("ms", function() {
      return require_ms2();
    });
    exposeFormat("padLevels", function() {
      return require_pad_levels();
    });
    exposeFormat("prettyPrint", function() {
      return require_pretty_print();
    });
    exposeFormat("printf", function() {
      return require_printf();
    });
    exposeFormat("simple", function() {
      return require_simple();
    });
    exposeFormat("splat", function() {
      return require_splat();
    });
    exposeFormat("timestamp", function() {
      return require_timestamp2();
    });
    exposeFormat("uncolorize", function() {
      return require_uncolorize();
    });
  }
});

// node_modules/winston/lib/winston/common.js
var require_common = __commonJS({
  "node_modules/winston/lib/winston/common.js"(exports) {
    "use strict";
    var { format } = require("util");
    exports.warn = {
      deprecated(prop) {
        return () => {
          throw new Error(format("{ %s } was removed in winston@3.0.0.", prop));
        };
      },
      useFormat(prop) {
        return () => {
          throw new Error([
            format("{ %s } was removed in winston@3.0.0.", prop),
            "Use a custom winston.format = winston.format(function) instead."
          ].join("\n"));
        };
      },
      forFunctions(obj, type, props) {
        props.forEach((prop) => {
          obj[prop] = exports.warn[type](prop);
        });
      },
      forProperties(obj, type, props) {
        props.forEach((prop) => {
          const notice = exports.warn[type](prop);
          Object.defineProperty(obj, prop, {
            get: notice,
            set: notice
          });
        });
      }
    };
  }
});

// node_modules/winston/package.json
var require_package = __commonJS({
  "node_modules/winston/package.json"(exports, module2) {
    module2.exports = {
      name: "winston",
      description: "A logger for just about everything.",
      version: "3.11.0",
      author: "Charlie Robbins <charlie.robbins@gmail.com>",
      maintainers: [
        "David Hyde <dabh@alumni.stanford.edu>"
      ],
      repository: {
        type: "git",
        url: "https://github.com/winstonjs/winston.git"
      },
      keywords: [
        "winston",
        "logger",
        "logging",
        "logs",
        "sysadmin",
        "bunyan",
        "pino",
        "loglevel",
        "tools",
        "json",
        "stream"
      ],
      dependencies: {
        "@dabh/diagnostics": "^2.0.2",
        "@colors/colors": "^1.6.0",
        async: "^3.2.3",
        "is-stream": "^2.0.0",
        logform: "^2.4.0",
        "one-time": "^1.0.0",
        "readable-stream": "^3.4.0",
        "safe-stable-stringify": "^2.3.1",
        "stack-trace": "0.0.x",
        "triple-beam": "^1.3.0",
        "winston-transport": "^4.5.0"
      },
      devDependencies: {
        "@babel/cli": "^7.17.0",
        "@babel/core": "^7.17.2",
        "@babel/preset-env": "^7.16.7",
        "@dabh/eslint-config-populist": "^5.0.0",
        "@types/node": "^20.3.1",
        "abstract-winston-transport": "^0.5.1",
        assume: "^2.2.0",
        "cross-spawn-async": "^2.2.5",
        eslint: "^8.9.0",
        hock: "^1.4.1",
        mocha: "8.1.3",
        nyc: "^15.1.0",
        rimraf: "^5.0.5",
        split2: "^4.1.0",
        "std-mocks": "^1.0.1",
        through2: "^4.0.2",
        "winston-compat": "^0.1.5"
      },
      main: "./lib/winston.js",
      browser: "./dist/winston",
      types: "./index.d.ts",
      scripts: {
        lint: "eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist",
        test: "mocha",
        "test:coverage": "nyc npm run test:unit",
        "test:unit": "mocha test/unit",
        "test:integration": "mocha test/integration",
        build: "rimraf dist && babel lib -d dist",
        prepublishOnly: "npm run build"
      },
      engines: {
        node: ">= 12.0.0"
      },
      license: "MIT"
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream2 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors.js
var require_errors2 = __commonJS({
  "node_modules/readable-stream/errors.js"(exports, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors2().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors2().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ERR_INVALID_ARG_TYPE = require_errors2().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream2();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require("string_decoder/").StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream2();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/winston-transport/modern.js
var require_modern = __commonJS({
  "node_modules/winston-transport/modern.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var Writable = require_stream_writable();
    var { LEVEL } = require_triple_beam();
    var TransportStream = module2.exports = function TransportStream2(options = {}) {
      Writable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
      this.format = options.format;
      this.level = options.level;
      this.handleExceptions = options.handleExceptions;
      this.handleRejections = options.handleRejections;
      this.silent = options.silent;
      if (options.log)
        this.log = options.log;
      if (options.logv)
        this.logv = options.logv;
      if (options.close)
        this.close = options.close;
      this.once("pipe", (logger) => {
        this.levels = logger.levels;
        this.parent = logger;
      });
      this.once("unpipe", (src) => {
        if (src === this.parent) {
          this.parent = null;
          if (this.close) {
            this.close();
          }
        }
      });
    };
    util.inherits(TransportStream, Writable);
    TransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      const level = this.level || this.parent && this.parent.level;
      if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (info && !this.format) {
          return this.log(info, callback);
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(Object.assign({}, info), this.format.options);
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          callback();
          if (errState)
            throw errState;
          return;
        }
        return this.log(transformed, callback);
      }
      this._writableState.sync = false;
      return callback(null);
    };
    TransportStream.prototype._writev = function _writev(chunks, callback) {
      if (this.logv) {
        const infos = chunks.filter(this._accept, this);
        if (!infos.length) {
          return callback(null);
        }
        return this.logv(infos, callback);
      }
      for (let i = 0; i < chunks.length; i++) {
        if (!this._accept(chunks[i]))
          continue;
        if (chunks[i].chunk && !this.format) {
          this.log(chunks[i].chunk, chunks[i].callback);
          continue;
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(
            Object.assign({}, chunks[i].chunk),
            this.format.options
          );
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          chunks[i].callback();
          if (errState) {
            callback(null);
            throw errState;
          }
        } else {
          this.log(transformed, chunks[i].callback);
        }
      }
      return callback(null);
    };
    TransportStream.prototype._accept = function _accept(write) {
      const info = write.chunk;
      if (this.silent) {
        return false;
      }
      const level = this.level || this.parent && this.parent.level;
      if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (this.handleExceptions || info.exception !== true) {
          return true;
        }
      }
      return false;
    };
    TransportStream.prototype._nop = function _nop() {
      return void 0;
    };
  }
});

// node_modules/winston-transport/legacy.js
var require_legacy = __commonJS({
  "node_modules/winston-transport/legacy.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var { LEVEL } = require_triple_beam();
    var TransportStream = require_modern();
    var LegacyTransportStream = module2.exports = function LegacyTransportStream2(options = {}) {
      TransportStream.call(this, options);
      if (!options.transport || typeof options.transport.log !== "function") {
        throw new Error("Invalid transport, must be an object with a log method.");
      }
      this.transport = options.transport;
      this.level = this.level || options.transport.level;
      this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;
      this._deprecated();
      function transportError(err) {
        this.emit("error", err, this.transport);
      }
      if (!this.transport.__winstonError) {
        this.transport.__winstonError = transportError.bind(this);
        this.transport.on("error", this.transport.__winstonError);
      }
    };
    util.inherits(LegacyTransportStream, TransportStream);
    LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
        this.transport.log(info[LEVEL], info.message, info, this._nop);
      }
      callback(null);
    };
    LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
      for (let i = 0; i < chunks.length; i++) {
        if (this._accept(chunks[i])) {
          this.transport.log(
            chunks[i].chunk[LEVEL],
            chunks[i].chunk.message,
            chunks[i].chunk,
            this._nop
          );
          chunks[i].callback();
        }
      }
      return callback(null);
    };
    LegacyTransportStream.prototype._deprecated = function _deprecated() {
      console.error([
        `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
        "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
      ].join("\n"));
    };
    LegacyTransportStream.prototype.close = function close() {
      if (this.transport.close) {
        this.transport.close();
      }
      if (this.transport.__winstonError) {
        this.transport.removeListener("error", this.transport.__winstonError);
        this.transport.__winstonError = null;
      }
    };
  }
});

// node_modules/winston-transport/index.js
var require_winston_transport = __commonJS({
  "node_modules/winston-transport/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_modern();
    module2.exports.LegacyTransportStream = require_legacy();
  }
});

// node_modules/winston/lib/winston/transports/console.js
var require_console = __commonJS({
  "node_modules/winston/lib/winston/transports/console.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var { LEVEL, MESSAGE } = require_triple_beam();
    var TransportStream = require_winston_transport();
    module2.exports = class Console extends TransportStream {
      /**
       * Constructor function for the Console transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "console";
        this.stderrLevels = this._stringArrayToSet(options.stderrLevels);
        this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.setMaxListeners(30);
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.stderrLevels[info[LEVEL]]) {
          if (console._stderr) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            console.error(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        } else if (this.consoleWarnLevels[info[LEVEL]]) {
          if (console._stderr) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            console.warn(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        }
        if (console._stdout) {
          console._stdout.write(`${info[MESSAGE]}${this.eol}`);
        } else {
          console.log(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
      }
      /**
       * Returns a Set-like object with strArray's elements as keys (each with the
       * value true).
       * @param {Array} strArray - Array of Set-elements as strings.
       * @param {?string} [errMsg] - Custom error message thrown on invalid input.
       * @returns {Object} - TODO: add return description.
       * @private
       */
      _stringArrayToSet(strArray, errMsg) {
        if (!strArray)
          return {};
        errMsg = errMsg || "Cannot make set from type other than Array of string elements";
        if (!Array.isArray(strArray)) {
          throw new Error(errMsg);
        }
        return strArray.reduce((set, el) => {
          if (typeof el !== "string") {
            throw new Error(errMsg);
          }
          set[el] = true;
          return set;
        }, {});
      }
    };
  }
});

// node_modules/async/internal/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/async/internal/isArrayLike.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isArrayLike;
    function isArrayLike(value) {
      return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS({
  "node_modules/async/internal/initialParams.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(fn) {
      return function(...args) {
        var callback = args.pop();
        return fn.call(this, args, callback);
      };
    };
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/async/internal/setImmediate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.fallback = fallback;
    exports.wrap = wrap;
    var hasQueueMicrotask = exports.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = exports.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return (fn, ...args) => defer(() => fn(...args));
    }
    var _defer;
    if (hasQueueMicrotask) {
      _defer = queueMicrotask;
    } else if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    exports.default = wrap(_defer);
  }
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS({
  "node_modules/async/asyncify.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = asyncify;
    var _initialParams = require_initialParams();
    var _initialParams2 = _interopRequireDefault(_initialParams);
    var _setImmediate = require_setImmediate();
    var _setImmediate2 = _interopRequireDefault(_setImmediate);
    var _wrapAsync = require_wrapAsync();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncify(func) {
      if ((0, _wrapAsync.isAsync)(func)) {
        return function(...args) {
          const callback = args.pop();
          const promise = func.apply(this, args);
          return handlePromise(promise, callback);
        };
      }
      return (0, _initialParams2.default)(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (result && typeof result.then === "function") {
          return handlePromise(result, callback);
        } else {
          callback(null, result);
        }
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value) => {
        invokeCallback(callback, null, value);
      }, (err) => {
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (err) {
        (0, _setImmediate2.default)((e) => {
          throw e;
        }, err);
      }
    }
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS({
  "node_modules/async/internal/wrapAsync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = void 0;
    var _asyncify = require_asyncify();
    var _asyncify2 = _interopRequireDefault(_asyncify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function")
        throw new Error("expected a function");
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
    }
    exports.default = wrapAsync;
    exports.isAsync = isAsync;
    exports.isAsyncGenerator = isAsyncGenerator;
    exports.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS({
  "node_modules/async/internal/awaitify.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = awaitify;
    function awaitify(asyncFn, arity) {
      if (!arity)
        arity = asyncFn.length;
      if (!arity)
        throw new Error("arity is undefined");
      function awaitable(...args) {
        if (typeof args[arity - 1] === "function") {
          return asyncFn.apply(this, args);
        }
        return new Promise((resolve, reject) => {
          args[arity - 1] = (err, ...cbArgs) => {
            if (err)
              return reject(err);
            resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args);
        });
      }
      return awaitable;
    }
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/parallel.js
var require_parallel = __commonJS({
  "node_modules/async/internal/parallel.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
      var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
      eachfn(tasks, (task, key, taskCb) => {
        (0, _wrapAsync2.default)(task)((err, ...result) => {
          if (result.length < 2) {
            [result] = result;
          }
          results[key] = result;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/once.js
var require_once = __commonJS({
  "node_modules/async/internal/once.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = once;
    function once(fn) {
      function wrapper(...args) {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      }
      Object.assign(wrapper, fn);
      return wrapper;
    }
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS({
  "node_modules/async/internal/getIterator.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    };
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/iterator.js
var require_iterator = __commonJS({
  "node_modules/async/internal/iterator.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = createIterator;
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _getIterator = require_getIterator();
    var _getIterator2 = _interopRequireDefault(_getIterator);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
        var item = iterator.next();
        if (item.done)
          return null;
        i++;
        return { value: item.value, key: i };
      };
    }
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [];
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i];
        if (key === "__proto__") {
          return next();
        }
        return i < len ? { value: obj[key], key } : null;
      };
    }
    function createIterator(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = (0, _getIterator2.default)(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS({
  "node_modules/async/internal/onlyOnce.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = onlyOnce;
    function onlyOnce(fn) {
      return function(...args) {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      };
    }
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS({
  "node_modules/async/internal/breakLoop.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var breakLoop = {};
    exports.default = breakLoop;
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS({
  "node_modules/async/internal/asyncEachOfLimit.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = asyncEachOfLimit;
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done)
          return;
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
          if (canceled || done)
            return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result) {
        running -= 1;
        if (canceled)
          return;
        if (err)
          return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      function handleError(err) {
        if (canceled)
          return;
        awaiting = false;
        done = true;
        callback(err);
      }
      replenish();
    }
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS({
  "node_modules/async/internal/eachOfLimit.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _iterator = require_iterator();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _asyncEachOfLimit = require_asyncEachOfLimit();
    var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = (limit) => {
      return (obj, iteratee, callback) => {
        callback = (0, _once2.default)(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
        }
        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled)
            return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === _breakLoop2.default || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    module2.exports = exports.default;
  }
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS({
  "node_modules/async/eachOfLimit.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _eachOfLimit2 = require_eachOfLimit();
    var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
      return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports.default = (0, _awaitify2.default)(eachOfLimit, 4);
    module2.exports = exports.default;
  }
});

// node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS({
  "node_modules/async/eachOfSeries.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfSeries(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
    }
    exports.default = (0, _awaitify2.default)(eachOfSeries, 3);
    module2.exports = exports.default;
  }
});

// node_modules/async/series.js
var require_series = __commonJS({
  "node_modules/async/series.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = series;
    var _parallel2 = require_parallel();
    var _parallel3 = _interopRequireDefault(_parallel2);
    var _eachOfSeries = require_eachOfSeries();
    var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function series(tasks, callback) {
      return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
    }
    module2.exports = exports.default;
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors2().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors2().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports = module2.exports = require_stream_readable();
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable();
      exports.Duplex = require_stream_duplex();
      exports.Transform = require_stream_transform();
      exports.PassThrough = require_stream_passthrough();
      exports.finished = require_end_of_stream();
      exports.pipeline = require_pipeline();
    }
  }
});

// node_modules/@dabh/diagnostics/diagnostics.js
var require_diagnostics = __commonJS({
  "node_modules/@dabh/diagnostics/diagnostics.js"(exports, module2) {
    var adapters = [];
    var modifiers = [];
    var logger = function devnull() {
    };
    function use(adapter) {
      if (~adapters.indexOf(adapter))
        return false;
      adapters.push(adapter);
      return true;
    }
    function set(custom) {
      logger = custom;
    }
    function enabled(namespace) {
      var async = [];
      for (var i = 0; i < adapters.length; i++) {
        if (adapters[i].async) {
          async.push(adapters[i]);
          continue;
        }
        if (adapters[i](namespace))
          return true;
      }
      if (!async.length)
        return false;
      return new Promise(function pinky(resolve) {
        Promise.all(
          async.map(function prebind(fn) {
            return fn(namespace);
          })
        ).then(function resolved(values) {
          resolve(values.some(Boolean));
        });
      });
    }
    function modify(fn) {
      if (~modifiers.indexOf(fn))
        return false;
      modifiers.push(fn);
      return true;
    }
    function write() {
      logger.apply(logger, arguments);
    }
    function process2(message) {
      for (var i = 0; i < modifiers.length; i++) {
        message = modifiers[i].apply(modifiers[i], arguments);
      }
      return message;
    }
    function introduce(fn, options) {
      var has = Object.prototype.hasOwnProperty;
      for (var key in options) {
        if (has.call(options, key)) {
          fn[key] = options[key];
        }
      }
      return fn;
    }
    function nope(options) {
      options.enabled = false;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(function diagnopes() {
        return false;
      }, options);
    }
    function yep(options) {
      function diagnostics() {
        var args = Array.prototype.slice.call(arguments, 0);
        write.call(write, options, process2(args, options));
        return true;
      }
      options.enabled = true;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(diagnostics, options);
    }
    module2.exports = function create(diagnostics) {
      diagnostics.introduce = introduce;
      diagnostics.enabled = enabled;
      diagnostics.process = process2;
      diagnostics.modify = modify;
      diagnostics.write = write;
      diagnostics.nope = nope;
      diagnostics.yep = yep;
      diagnostics.set = set;
      diagnostics.use = use;
      return diagnostics;
    };
  }
});

// node_modules/@dabh/diagnostics/node/production.js
var require_production = __commonJS({
  "node_modules/@dabh/diagnostics/node/production.js"(exports, module2) {
    var create = require_diagnostics();
    var diagnostics = create(function prod(namespace, options) {
      options = options || {};
      options.namespace = namespace;
      options.prod = true;
      options.dev = false;
      if (!(options.force || prod.force))
        return prod.nope(options);
      return prod.yep(options);
    });
    module2.exports = diagnostics;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports, module2) {
    module2.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports, module2) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module2.exports = function swizzle2(args) {
      var results = [];
      for (var i = 0, len = args.length; i < len; i++) {
        var arg = args[i];
        if (isArrayish(arg)) {
          results = concat.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports, module2) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module2.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match;
      var i;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty.call(colorNames, match[1])) {
          return null;
        }
        rgb = colorNames[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] = clamp(rgb[i], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var s = clamp(parseFloat(match[2]), 0, 100);
        var l = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match[2]), 0, 100);
        var b = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r = Math.round(rgba[0] / 255 * 100);
      var g = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// node_modules/color/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/color/node_modules/color-name/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color/node_modules/color-convert/conversions.js"(exports, module2) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color/node_modules/color-convert/route.js"(exports, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color/node_modules/color-convert/index.js"(exports, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/color/index.js
var require_color = __commonJS({
  "node_modules/color/index.js"(exports, module2) {
    "use strict";
    var colorString = require_color_string();
    var convert = require_color_convert();
    var _slice = [].slice;
    var skippedModels = [
      // to be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // gray conflicts with some method names, and has its own method defined.
      "gray",
      // shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    Object.keys(convert).forEach(function(model) {
      hashedModelKeys[_slice.call(convert[model].labels).sort().join("")] = model;
    });
    var limiters = {};
    function Color(obj, model) {
      if (!(this instanceof Color)) {
        return new Color(obj, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      var i;
      var channels;
      if (obj == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (obj instanceof Color) {
        this.model = obj.model;
        this.color = obj.color.slice();
        this.valpha = obj.valpha;
      } else if (typeof obj === "string") {
        var result = colorString.get(obj);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + obj);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (obj.length) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        var newArr = _slice.call(obj, 0, channels);
        this.color = zeroArray(newArr, channels);
        this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
      } else if (typeof obj === "number") {
        obj &= 16777215;
        this.model = "rgb";
        this.color = [
          obj >> 16 & 255,
          obj >> 8 & 255,
          obj & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        var keys = Object.keys(obj);
        if ("alpha" in obj) {
          keys.splice(keys.indexOf("alpha"), 1);
          this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
        }
        var hashedKeys = keys.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
        }
        this.model = hashedModelKeys[hashedKeys];
        var labels = convert[this.model].labels;
        var color = [];
        for (i = 0; i < labels.length; i++) {
          color.push(obj[labels[i]]);
        }
        this.color = zeroArray(color);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i = 0; i < channels; i++) {
          var limit = limiters[this.model][i];
          if (limit) {
            this.color[i] = limit(this.color[i]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color.prototype = {
      toString: function() {
        return this.string();
      },
      toJSON: function() {
        return this[this.model]();
      },
      string: function(places) {
        var self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to[self2.model](args);
      },
      percentString: function(places) {
        var self2 = this.rgb().round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to.rgb.percent(args);
      },
      array: function() {
        return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
      },
      object: function() {
        var result = {};
        var channels = convert[this.model].channels;
        var labels = convert[this.model].labels;
        for (var i = 0; i < channels; i++) {
          result[labels[i]] = this.color[i];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray: function() {
        var rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject: function() {
        var rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round: function(places) {
        places = Math.max(places || 0, 0);
        return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
      },
      alpha: function(val) {
        if (arguments.length) {
          return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
        }
        return this.valpha;
      },
      // rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
        return (val % 360 + 360) % 360;
      }),
      // eslint-disable-line brace-style
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(100)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(100)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return convert[this.model].keyword(this.color);
      },
      hex: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      rgbNumber: function() {
        var rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity: function() {
        var rgb = this.rgb().color;
        var lum = [];
        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function(color2) {
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function(color2) {
        var contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7.1) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark: function() {
        var rgb = this.rgb().color;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
        return yiq < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      negate: function() {
        var rgb = this.rgb();
        for (var i = 0; i < 3; i++) {
          rgb.color[i] = 255 - rgb.color[i];
        }
        return rgb;
      },
      lighten: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten: function(ratio) {
        var hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken: function(ratio) {
        var hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale: function() {
        var rgb = this.rgb().color;
        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(val, val, val);
      },
      fade: function(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer: function(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate: function(degrees) {
        var hsl = this.hsl();
        var hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix: function(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        var color1 = mixinColor.rgb();
        var color2 = this.rgb();
        var p = weight === void 0 ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        var w2 = 1 - w1;
        return Color.rgb(
          w1 * color1.red() + w2 * color2.red(),
          w1 * color1.green() + w2 * color2.green(),
          w1 * color1.blue() + w2 * color2.blue(),
          color1.alpha() * p + color2.alpha() * (1 - p)
        );
      }
    };
    Object.keys(convert).forEach(function(model) {
      if (skippedModels.indexOf(model) !== -1) {
        return;
      }
      var channels = convert[model].channels;
      Color.prototype[model] = function() {
        if (this.model === model) {
          return new Color(this);
        }
        if (arguments.length) {
          return new Color(arguments, model);
        }
        var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
        return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
      };
      Color[model] = function(color) {
        if (typeof color === "number") {
          color = zeroArray(_slice.call(arguments), channels);
        }
        return new Color(color, model);
      };
    });
    function roundTo(num, places) {
      return Number(num.toFixed(places));
    }
    function roundToPlace(places) {
      return function(num) {
        return roundTo(num, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      model.forEach(function(m) {
        (limiters[m] || (limiters[m] = []))[channel] = modifier;
      });
      model = model[0];
      return function(val) {
        var result;
        if (arguments.length) {
          if (modifier) {
            val = modifier(val);
          }
          result = this[model]();
          result.color[channel] = val;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max) {
      return function(v) {
        return Math.max(0, Math.min(max, v));
      };
    }
    function assertArray(val) {
      return Array.isArray(val) ? val : [val];
    }
    function zeroArray(arr, length) {
      for (var i = 0; i < length; i++) {
        if (typeof arr[i] !== "number") {
          arr[i] = 0;
        }
      }
      return arr;
    }
    module2.exports = Color;
  }
});

// node_modules/text-hex/index.js
var require_text_hex = __commonJS({
  "node_modules/text-hex/index.js"(exports, module2) {
    "use strict";
    module2.exports = function hex(str) {
      for (var i = 0, hash = 0; i < str.length; hash = str.charCodeAt(i++) + ((hash << 5) - hash))
        ;
      var color = Math.floor(
        Math.abs(
          Math.sin(hash) * 1e4 % 1 * 16777216
        )
      ).toString(16);
      return "#" + Array(6 - color.length + 1).join("0") + color;
    };
  }
});

// node_modules/colorspace/index.js
var require_colorspace = __commonJS({
  "node_modules/colorspace/index.js"(exports, module2) {
    "use strict";
    var color = require_color();
    var hex = require_text_hex();
    module2.exports = function colorspace(namespace, delimiter) {
      var split = namespace.split(delimiter || ":");
      var base = hex(split[0]);
      if (!split.length)
        return base;
      for (var i = 0, l = split.length - 1; i < l; i++) {
        base = color(base).mix(color(hex(split[i + 1]))).saturate(1).hex();
      }
      return base;
    };
  }
});

// node_modules/kuler/index.js
var require_kuler = __commonJS({
  "node_modules/kuler/index.js"(exports, module2) {
    "use strict";
    function Kuler(text, color) {
      if (color)
        return new Kuler(text).style(color);
      if (!(this instanceof Kuler))
        return new Kuler(text);
      this.text = text;
    }
    Kuler.prototype.prefix = "\x1B[";
    Kuler.prototype.suffix = "m";
    Kuler.prototype.hex = function hex(color) {
      color = color[0] === "#" ? color.substring(1) : color;
      if (color.length === 3) {
        color = color.split("");
        color[5] = color[2];
        color[4] = color[2];
        color[3] = color[1];
        color[2] = color[1];
        color[1] = color[0];
        color = color.join("");
      }
      var r = color.substring(0, 2), g = color.substring(2, 4), b = color.substring(4, 6);
      return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
    };
    Kuler.prototype.rgb = function rgb(r, g, b) {
      var red = r / 255 * 5, green = g / 255 * 5, blue = b / 255 * 5;
      return this.ansi(red, green, blue);
    };
    Kuler.prototype.ansi = function ansi(r, g, b) {
      var red = Math.round(r), green = Math.round(g), blue = Math.round(b);
      return 16 + red * 36 + green * 6 + blue;
    };
    Kuler.prototype.reset = function reset() {
      return this.prefix + "39;49" + this.suffix;
    };
    Kuler.prototype.style = function style(color) {
      return this.prefix + "38;5;" + this.rgb.apply(this, this.hex(color)) + this.suffix + this.text + this.reset();
    };
    module2.exports = Kuler;
  }
});

// node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js
var require_namespace_ansi = __commonJS({
  "node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js"(exports, module2) {
    var colorspace = require_colorspace();
    var kuler = require_kuler();
    module2.exports = function ansiModifier(args, options) {
      var namespace = options.namespace;
      var ansi = options.colors !== false ? kuler(namespace + ":", colorspace(namespace)) : namespace + ":";
      args[0] = ansi + " " + args[0];
      return args;
    };
  }
});

// node_modules/enabled/index.js
var require_enabled = __commonJS({
  "node_modules/enabled/index.js"(exports, module2) {
    "use strict";
    module2.exports = function enabled(name, variable) {
      if (!variable)
        return false;
      var variables = variable.split(/[\s,]+/), i = 0;
      for (; i < variables.length; i++) {
        variable = variables[i].replace("*", ".*?");
        if ("-" === variable.charAt(0)) {
          if (new RegExp("^" + variable.substr(1) + "$").test(name)) {
            return false;
          }
          continue;
        }
        if (new RegExp("^" + variable + "$").test(name)) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/@dabh/diagnostics/adapters/index.js
var require_adapters = __commonJS({
  "node_modules/@dabh/diagnostics/adapters/index.js"(exports, module2) {
    var enabled = require_enabled();
    module2.exports = function create(fn) {
      return function adapter(namespace) {
        try {
          return enabled(namespace, fn());
        } catch (e) {
        }
        return false;
      };
    };
  }
});

// node_modules/@dabh/diagnostics/adapters/process.env.js
var require_process_env = __commonJS({
  "node_modules/@dabh/diagnostics/adapters/process.env.js"(exports, module2) {
    var adapter = require_adapters();
    module2.exports = adapter(function processenv() {
      return process.env.DEBUG || process.env.DIAGNOSTICS;
    });
  }
});

// node_modules/@dabh/diagnostics/logger/console.js
var require_console2 = __commonJS({
  "node_modules/@dabh/diagnostics/logger/console.js"(exports, module2) {
    module2.exports = function(meta, messages) {
      try {
        Function.prototype.apply.call(console.log, console, messages);
      } catch (e) {
      }
    };
  }
});

// node_modules/@dabh/diagnostics/node/development.js
var require_development = __commonJS({
  "node_modules/@dabh/diagnostics/node/development.js"(exports, module2) {
    var create = require_diagnostics();
    var tty = require("tty").isatty(1);
    var diagnostics = create(function dev(namespace, options) {
      options = options || {};
      options.colors = "colors" in options ? options.colors : tty;
      options.namespace = namespace;
      options.prod = false;
      options.dev = true;
      if (!dev.enabled(namespace) && !(options.force || dev.force)) {
        return dev.nope(options);
      }
      return dev.yep(options);
    });
    diagnostics.modify(require_namespace_ansi());
    diagnostics.use(require_process_env());
    diagnostics.set(require_console2());
    module2.exports = diagnostics;
  }
});

// node_modules/@dabh/diagnostics/node/index.js
var require_node2 = __commonJS({
  "node_modules/@dabh/diagnostics/node/index.js"(exports, module2) {
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_production();
    } else {
      module2.exports = require_development();
    }
  }
});

// node_modules/winston/lib/winston/tail-file.js
var require_tail_file = __commonJS({
  "node_modules/winston/lib/winston/tail-file.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var { StringDecoder } = require("string_decoder");
    var { Stream } = require_readable();
    function noop() {
    }
    module2.exports = (options, iter) => {
      const buffer = Buffer.alloc(64 * 1024);
      const decode = new StringDecoder("utf8");
      const stream = new Stream();
      let buff = "";
      let pos = 0;
      let row = 0;
      if (options.start === -1) {
        delete options.start;
      }
      stream.readable = true;
      stream.destroy = () => {
        stream.destroyed = true;
        stream.emit("end");
        stream.emit("close");
      };
      fs.open(options.file, "a+", "0644", (err, fd) => {
        if (err) {
          if (!iter) {
            stream.emit("error", err);
          } else {
            iter(err);
          }
          stream.destroy();
          return;
        }
        (function read() {
          if (stream.destroyed) {
            fs.close(fd, noop);
            return;
          }
          return fs.read(fd, buffer, 0, buffer.length, pos, (error, bytes) => {
            if (error) {
              if (!iter) {
                stream.emit("error", error);
              } else {
                iter(error);
              }
              stream.destroy();
              return;
            }
            if (!bytes) {
              if (buff) {
                if (options.start == null || row > options.start) {
                  if (!iter) {
                    stream.emit("line", buff);
                  } else {
                    iter(null, buff);
                  }
                }
                row++;
                buff = "";
              }
              return setTimeout(read, 1e3);
            }
            let data = decode.write(buffer.slice(0, bytes));
            if (!iter) {
              stream.emit("data", data);
            }
            data = (buff + data).split(/\n+/);
            const l = data.length - 1;
            let i = 0;
            for (; i < l; i++) {
              if (options.start == null || row > options.start) {
                if (!iter) {
                  stream.emit("line", data[i]);
                } else {
                  iter(null, data[i]);
                }
              }
              row++;
            }
            buff = data[l];
            pos += bytes;
            return read();
          });
        })();
      });
      if (!iter) {
        return stream;
      }
      return stream.destroy;
    };
  }
});

// node_modules/winston/lib/winston/transports/file.js
var require_file = __commonJS({
  "node_modules/winston/lib/winston/transports/file.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var asyncSeries = require_series();
    var zlib = require("zlib");
    var { MESSAGE } = require_triple_beam();
    var { Stream, PassThrough } = require_readable();
    var TransportStream = require_winston_transport();
    var debug = require_node2()("winston:file");
    var os = require("os");
    var tailFile = require_tail_file();
    module2.exports = class File extends TransportStream {
      /**
       * Constructor function for the File transport object responsible for
       * persisting log messages and metadata to one or more files.
       * @param {Object} options - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "file";
        function throwIf(target, ...args) {
          args.slice(1).forEach((name) => {
            if (options[name]) {
              throw new Error(`Cannot set ${name} and ${target} together`);
            }
          });
        }
        this._stream = new PassThrough();
        this._stream.setMaxListeners(30);
        this._onError = this._onError.bind(this);
        if (options.filename || options.dirname) {
          throwIf("filename or dirname", "stream");
          this._basename = this.filename = options.filename ? path.basename(options.filename) : "winston.log";
          this.dirname = options.dirname || path.dirname(options.filename);
          this.options = options.options || { flags: "a" };
        } else if (options.stream) {
          console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream");
          throwIf("stream", "filename", "maxsize");
          this._dest = this._stream.pipe(this._setupStream(options.stream));
          this.dirname = path.dirname(this._dest.path);
        } else {
          throw new Error("Cannot log to file without filename or stream.");
        }
        this.maxsize = options.maxsize || null;
        this.rotationFormat = options.rotationFormat || false;
        this.zippedArchive = options.zippedArchive || false;
        this.maxFiles = options.maxFiles || null;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.tailable = options.tailable || false;
        this.lazy = options.lazy || false;
        this._size = 0;
        this._pendingSize = 0;
        this._created = 0;
        this._drain = false;
        this._opening = false;
        this._ending = false;
        this._fileExist = false;
        if (this.dirname)
          this._createLogDirIfNotExist(this.dirname);
        if (!this.lazy)
          this.open();
      }
      finishIfEnding() {
        if (this._ending) {
          if (this._opening) {
            this.once("open", () => {
              this._stream.once("finish", () => this.emit("finish"));
              setImmediate(() => this._stream.end());
            });
          } else {
            this._stream.once("finish", () => this.emit("finish"));
            setImmediate(() => this._stream.end());
          }
        }
      }
      /**
       * Core logging method exposed to Winston. Metadata is optional.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback = () => {
      }) {
        if (this.silent) {
          callback();
          return true;
        }
        if (this._drain) {
          this._stream.once("drain", () => {
            this._drain = false;
            this.log(info, callback);
          });
          return;
        }
        if (this._rotate) {
          this._stream.once("rotate", () => {
            this._rotate = false;
            this.log(info, callback);
          });
          return;
        }
        if (this.lazy) {
          if (!this._fileExist) {
            if (!this._opening) {
              this.open();
            }
            this.once("open", () => {
              this._fileExist = true;
              this.log(info, callback);
              return;
            });
            return;
          }
          if (this._needsNewFile(this._pendingSize)) {
            this._dest.once("close", () => {
              if (!this._opening) {
                this.open();
              }
              this.once("open", () => {
                this.log(info, callback);
                return;
              });
              return;
            });
            return;
          }
        }
        const output = `${info[MESSAGE]}${this.eol}`;
        const bytes = Buffer.byteLength(output);
        function logged() {
          this._size += bytes;
          this._pendingSize -= bytes;
          debug("logged %s %s", this._size, output);
          this.emit("logged", info);
          if (this._rotate) {
            return;
          }
          if (this._opening) {
            return;
          }
          if (!this._needsNewFile()) {
            return;
          }
          if (this.lazy) {
            this._endStream(() => {
              this.emit("fileclosed");
            });
            return;
          }
          this._rotate = true;
          this._endStream(() => this._rotateFile());
        }
        this._pendingSize += bytes;
        if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {
          this.rotatedWhileOpening = true;
        }
        const written = this._stream.write(output, logged.bind(this));
        if (!written) {
          this._drain = true;
          this._stream.once("drain", () => {
            this._drain = false;
            callback();
          });
        } else {
          callback();
        }
        debug("written", written, this._drain);
        this.finishIfEnding();
        return written;
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options - Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * TODO: Refactor me.
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = normalizeQuery(options);
        const file = path.join(this.dirname, this.filename);
        let buff = "";
        let results = [];
        let row = 0;
        const stream = fs.createReadStream(file, {
          encoding: "utf8"
        });
        stream.on("error", (err) => {
          if (stream.readable) {
            stream.destroy();
          }
          if (!callback) {
            return;
          }
          return err.code !== "ENOENT" ? callback(err) : callback(null, results);
        });
        stream.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            if (!options.start || row >= options.start) {
              add(data[i]);
            }
            row++;
          }
          buff = data[l];
        });
        stream.on("close", () => {
          if (buff) {
            add(buff, true);
          }
          if (options.order === "desc") {
            results = results.reverse();
          }
          if (callback)
            callback(null, results);
        });
        function add(buff2, attempt) {
          try {
            const log = JSON.parse(buff2);
            if (check(log)) {
              push(log);
            }
          } catch (e) {
            if (!attempt) {
              stream.emit("error", e);
            }
          }
        }
        function push(log) {
          if (options.rows && results.length >= options.rows && options.order !== "desc") {
            if (stream.readable) {
              stream.destroy();
            }
            return;
          }
          if (options.fields) {
            log = options.fields.reduce((obj, key) => {
              obj[key] = log[key];
              return obj;
            }, {});
          }
          if (options.order === "desc") {
            if (results.length >= options.rows) {
              results.shift();
            }
          }
          results.push(log);
        }
        function check(log) {
          if (!log) {
            return;
          }
          if (typeof log !== "object") {
            return;
          }
          const time = new Date(log.timestamp);
          if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
            return;
          }
          return true;
        }
        function normalizeQuery(options2) {
          options2 = options2 || {};
          options2.rows = options2.rows || options2.limit || 10;
          options2.start = options2.start || 0;
          options2.until = options2.until || new Date();
          if (typeof options2.until !== "object") {
            options2.until = new Date(options2.until);
          }
          options2.from = options2.from || options2.until - 24 * 60 * 60 * 1e3;
          if (typeof options2.from !== "object") {
            options2.from = new Date(options2.from);
          }
          options2.order = options2.order || "desc";
          return options2;
        }
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       * TODO: Refactor me.
       */
      stream(options = {}) {
        const file = path.join(this.dirname, this.filename);
        const stream = new Stream();
        const tail = {
          file,
          start: options.start
        };
        stream.destroy = tailFile(tail, (err, line) => {
          if (err) {
            return stream.emit("error", err);
          }
          try {
            stream.emit("data", line);
            line = JSON.parse(line);
            stream.emit("log", line);
          } catch (e) {
            stream.emit("error", e);
          }
        });
        return stream;
      }
      /**
       * Checks to see the filesize of.
       * @returns {undefined}
       */
      open() {
        if (!this.filename)
          return;
        if (this._opening)
          return;
        this._opening = true;
        this.stat((err, size) => {
          if (err) {
            return this.emit("error", err);
          }
          debug("stat done: %s { size: %s }", this.filename, size);
          this._size = size;
          this._dest = this._createStream(this._stream);
          this._opening = false;
          this.once("open", () => {
            if (this._stream.eventNames().includes("rotate")) {
              this._stream.emit("rotate");
            } else {
              this._rotate = false;
            }
          });
        });
      }
      /**
       * Stat the file and assess information in order to create the proper stream.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      stat(callback) {
        const target = this._getFile();
        const fullpath = path.join(this.dirname, target);
        fs.stat(fullpath, (err, stat) => {
          if (err && err.code === "ENOENT") {
            debug("ENOENT\xA0ok", fullpath);
            this.filename = target;
            return callback(null, 0);
          }
          if (err) {
            debug(`err ${err.code} ${fullpath}`);
            return callback(err);
          }
          if (!stat || this._needsNewFile(stat.size)) {
            return this._incFile(() => this.stat(callback));
          }
          this.filename = target;
          callback(null, stat.size);
        });
      }
      /**
       * Closes the stream associated with this instance.
       * @param {function} cb - TODO: add param description.
       * @returns {undefined}
       */
      close(cb) {
        if (!this._stream) {
          return;
        }
        this._stream.end(() => {
          if (cb) {
            cb();
          }
          this.emit("flush");
          this.emit("closed");
        });
      }
      /**
       * TODO: add method description.
       * @param {number} size - TODO: add param description.
       * @returns {undefined}
       */
      _needsNewFile(size) {
        size = size || this._size;
        return this.maxsize && size >= this.maxsize;
      }
      /**
       * TODO: add method description.
       * @param {Error} err - TODO: add param description.
       * @returns {undefined}
       */
      _onError(err) {
        this.emit("error", err);
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      _setupStream(stream) {
        stream.on("error", this._onError);
        return stream;
      }
      /**
       * TODO: add method description.
       * @param {Stream} stream - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      _cleanupStream(stream) {
        stream.removeListener("error", this._onError);
        stream.destroy();
        return stream;
      }
      /**
       * TODO: add method description.
       */
      _rotateFile() {
        this._incFile(() => this.open());
      }
      /**
       * Unpipe from the stream that has been marked as full and end it so it
       * flushes to disk.
       *
       * @param {function} callback - Callback for when the current file has closed.
       * @private
       */
      _endStream(callback = () => {
      }) {
        if (this._dest) {
          this._stream.unpipe(this._dest);
          this._dest.end(() => {
            this._cleanupStream(this._dest);
            callback();
          });
        } else {
          callback();
        }
      }
      /**
       * Returns the WritableStream for the active file on this instance. If we
       * should gzip the file then a zlib stream is returned.
       *
       * @param {ReadableStream} source –PassThrough to pipe to the file when open.
       * @returns {WritableStream} Stream that writes to disk for the active file.
       */
      _createStream(source) {
        const fullpath = path.join(this.dirname, this.filename);
        debug("create stream start", fullpath, this.options);
        const dest = fs.createWriteStream(fullpath, this.options).on("error", (err) => debug(err)).on("close", () => debug("close", dest.path, dest.bytesWritten)).on("open", () => {
          debug("file open ok", fullpath);
          this.emit("open", fullpath);
          source.pipe(dest);
          if (this.rotatedWhileOpening) {
            this._stream = new PassThrough();
            this._stream.setMaxListeners(30);
            this._rotateFile();
            this.rotatedWhileOpening = false;
            this._cleanupStream(dest);
            source.end();
          }
        });
        debug("create stream ok", fullpath);
        if (this.zippedArchive) {
          const gzip = zlib.createGzip();
          gzip.pipe(dest);
          return gzip;
        }
        return dest;
      }
      /**
       * TODO: add method description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      _incFile(callback) {
        debug("_incFile", this.filename);
        const ext = path.extname(this._basename);
        const basename = path.basename(this._basename, ext);
        if (!this.tailable) {
          this._created += 1;
          this._checkMaxFilesIncrementing(ext, basename, callback);
        } else {
          this._checkMaxFilesTailable(ext, basename, callback);
        }
      }
      /**
       * Gets the next filename to use for this instance in the case that log
       * filesizes are being capped.
       * @returns {string} - TODO: add return description.
       * @private
       */
      _getFile() {
        const ext = path.extname(this._basename);
        const basename = path.basename(this._basename, ext);
        const isRotation = this.rotationFormat ? this.rotationFormat() : this._created;
        const target = !this.tailable && this._created ? `${basename}${isRotation}${ext}` : `${basename}${ext}`;
        return this.zippedArchive && !this.tailable ? `${target}.gz` : target;
      }
      /**
       * Increment the number of files created or checked by this instance.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
      _checkMaxFilesIncrementing(ext, basename, callback) {
        if (!this.maxFiles || this._created < this.maxFiles) {
          return setImmediate(callback);
        }
        const oldest = this._created - this.maxFiles;
        const isOldest = oldest !== 0 ? oldest : "";
        const isZipped = this.zippedArchive ? ".gz" : "";
        const filePath = `${basename}${isOldest}${ext}${isZipped}`;
        const target = path.join(this.dirname, filePath);
        fs.unlink(target, callback);
      }
      /**
       * Roll files forward based on integer, up to maxFiles. e.g. if base if
       * file.log and it becomes oversized, roll to file1.log, and allow file.log
       * to be re-used. If file is oversized again, roll file1.log to file2.log,
       * roll file.log to file1.log, and so on.
       * @param {mixed} ext - TODO: add param description.
       * @param {mixed} basename - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {undefined}
       * @private
       */
      _checkMaxFilesTailable(ext, basename, callback) {
        const tasks = [];
        if (!this.maxFiles) {
          return;
        }
        const isZipped = this.zippedArchive ? ".gz" : "";
        for (let x = this.maxFiles - 1; x > 1; x--) {
          tasks.push(function(i, cb) {
            let fileName = `${basename}${i - 1}${ext}${isZipped}`;
            const tmppath = path.join(this.dirname, fileName);
            fs.exists(tmppath, (exists) => {
              if (!exists) {
                return cb(null);
              }
              fileName = `${basename}${i}${ext}${isZipped}`;
              fs.rename(tmppath, path.join(this.dirname, fileName), cb);
            });
          }.bind(this, x));
        }
        asyncSeries(tasks, () => {
          fs.rename(
            path.join(this.dirname, `${basename}${ext}`),
            path.join(this.dirname, `${basename}1${ext}${isZipped}`),
            callback
          );
        });
      }
      _createLogDirIfNotExist(dirPath) {
        if (!fs.existsSync(dirPath)) {
          fs.mkdirSync(dirPath, { recursive: true });
        }
      }
    };
  }
});

// node_modules/winston/lib/winston/transports/http.js
var require_http = __commonJS({
  "node_modules/winston/lib/winston/transports/http.js"(exports, module2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var { Stream } = require_readable();
    var TransportStream = require_winston_transport();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = class Http extends TransportStream {
      /**
       * Constructor function for the Http transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      // eslint-disable-next-line max-statements
      constructor(options = {}) {
        super(options);
        this.options = options;
        this.name = options.name || "http";
        this.ssl = !!options.ssl;
        this.host = options.host || "localhost";
        this.port = options.port;
        this.auth = options.auth;
        this.path = options.path || "";
        this.agent = options.agent;
        this.headers = options.headers || {};
        this.headers["content-type"] = "application/json";
        this.batch = options.batch || false;
        this.batchInterval = options.batchInterval || 5e3;
        this.batchCount = options.batchCount || 10;
        this.batchOptions = [];
        this.batchTimeoutID = -1;
        this.batchCallback = {};
        if (!this.port) {
          this.port = this.ssl ? 443 : 80;
        }
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        this._request(info, null, null, (err, res) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            this.emit("warn", err);
          } else {
            this.emit("logged", info);
          }
        });
        if (callback) {
          setImmediate(callback);
        }
      }
      /**
       * Query the transport. Options object is optional.
       * @param {Object} options -  Loggly-like query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       * @returns {undefined}
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = {
          method: "query",
          params: this.normalizeQuery(options)
        };
        const auth = options.params.auth || null;
        delete options.params.auth;
        const path = options.params.path || null;
        delete options.params.path;
        this._request(options, auth, path, (err, res, body) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            return callback(err);
          }
          if (typeof body === "string") {
            try {
              body = JSON.parse(body);
            } catch (e) {
              return callback(e);
            }
          }
          callback(null, body);
        });
      }
      /**
       * Returns a log stream for this transport. Options object is optional.
       * @param {Object} options - Stream options for this instance.
       * @returns {Stream} - TODO: add return description
       */
      stream(options = {}) {
        const stream = new Stream();
        options = {
          method: "stream",
          params: options
        };
        const path = options.params.path || null;
        delete options.params.path;
        const auth = options.params.auth || null;
        delete options.params.auth;
        let buff = "";
        const req = this._request(options, auth, path);
        stream.destroy = () => req.destroy();
        req.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            try {
              stream.emit("log", JSON.parse(data[i]));
            } catch (e) {
              stream.emit("error", e);
            }
          }
          buff = data[l];
        });
        req.on("error", (err) => stream.emit("error", err));
        return stream;
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       * @param {function} callback - Continuation to respond to when complete.
       */
      _request(options, auth, path, callback) {
        options = options || {};
        auth = auth || this.auth;
        path = path || this.path || "";
        if (this.batch) {
          this._doBatch(options, callback, auth, path);
        } else {
          this._doRequest(options, callback, auth, path);
        }
      }
      /**
       * Send or memorize the options according to batch configuration
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doBatch(options, callback, auth, path) {
        this.batchOptions.push(options);
        if (this.batchOptions.length === 1) {
          const me = this;
          this.batchCallback = callback;
          this.batchTimeoutID = setTimeout(function() {
            me.batchTimeoutID = -1;
            me._doBatchRequest(me.batchCallback, auth, path);
          }, this.batchInterval);
        }
        if (this.batchOptions.length === this.batchCount) {
          this._doBatchRequest(this.batchCallback, auth, path);
        }
      }
      /**
       * Initiate a request with the memorized batch options, stop the batch timeout
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doBatchRequest(callback, auth, path) {
        if (this.batchTimeoutID > 0) {
          clearTimeout(this.batchTimeoutID);
          this.batchTimeoutID = -1;
        }
        const batchOptionsCopy = this.batchOptions.slice();
        this.batchOptions = [];
        this._doRequest(batchOptionsCopy, callback, auth, path);
      }
      /**
       * Make a request to a winstond server or any http server which can
       * handle json-rpc.
       * @param {function} options - Options to sent the request.
       * @param {function} callback - Continuation to respond to when complete.
       * @param {Object?} auth - authentication options
       * @param {string} path - request path
       */
      _doRequest(options, callback, auth, path) {
        const headers = Object.assign({}, this.headers);
        if (auth && auth.bearer) {
          headers.Authorization = `Bearer ${auth.bearer}`;
        }
        const req = (this.ssl ? https : http).request({
          ...this.options,
          method: "POST",
          host: this.host,
          port: this.port,
          path: `/${path.replace(/^\//, "")}`,
          headers,
          auth: auth && auth.username && auth.password ? `${auth.username}:${auth.password}` : "",
          agent: this.agent
        });
        req.on("error", callback);
        req.on("response", (res) => res.on("end", () => callback(null, res)).resume());
        req.end(Buffer.from(jsonStringify(options, this.options.replacer), "utf8"));
      }
    };
  }
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/is-stream/index.js"(exports, module2) {
    "use strict";
    var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
    isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
    module2.exports = isStream;
  }
});

// node_modules/winston/lib/winston/transports/stream.js
var require_stream3 = __commonJS({
  "node_modules/winston/lib/winston/transports/stream.js"(exports, module2) {
    "use strict";
    var isStream = require_is_stream();
    var { MESSAGE } = require_triple_beam();
    var os = require("os");
    var TransportStream = require_winston_transport();
    module2.exports = class Stream extends TransportStream {
      /**
       * Constructor function for the Console transport object responsible for
       * persisting log messages and metadata to a terminal or TTY.
       * @param {!Object} [options={}] - Options for this instance.
       */
      constructor(options = {}) {
        super(options);
        if (!options.stream || !isStream(options.stream)) {
          throw new Error("options.stream is required.");
        }
        this._stream = options.stream;
        this._stream.setMaxListeners(Infinity);
        this.isObjectMode = options.stream._writableState.objectMode;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      }
      /**
       * Core logging method exposed to Winston.
       * @param {Object} info - TODO: add param description.
       * @param {Function} callback - TODO: add param description.
       * @returns {undefined}
       */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.isObjectMode) {
          this._stream.write(info);
          if (callback) {
            callback();
          }
          return;
        }
        this._stream.write(`${info[MESSAGE]}${this.eol}`);
        if (callback) {
          callback();
        }
        return;
      }
    };
  }
});

// node_modules/winston/lib/winston/transports/index.js
var require_transports = __commonJS({
  "node_modules/winston/lib/winston/transports/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "Console", {
      configurable: true,
      enumerable: true,
      get() {
        return require_console();
      }
    });
    Object.defineProperty(exports, "File", {
      configurable: true,
      enumerable: true,
      get() {
        return require_file();
      }
    });
    Object.defineProperty(exports, "Http", {
      configurable: true,
      enumerable: true,
      get() {
        return require_http();
      }
    });
    Object.defineProperty(exports, "Stream", {
      configurable: true,
      enumerable: true,
      get() {
        return require_stream3();
      }
    });
  }
});

// node_modules/winston/lib/winston/config/index.js
var require_config2 = __commonJS({
  "node_modules/winston/lib/winston/config/index.js"(exports) {
    "use strict";
    var logform = require_logform();
    var { configs } = require_triple_beam();
    exports.cli = logform.levels(configs.cli);
    exports.npm = logform.levels(configs.npm);
    exports.syslog = logform.levels(configs.syslog);
    exports.addColors = logform.levels;
  }
});

// node_modules/async/eachOf.js
var require_eachOf = __commonJS({
  "node_modules/async/eachOf.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = (0, _once2.default)(callback);
      var index = 0, completed = 0, { length } = coll, canceled = false;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err === false) {
          canceled = true;
        }
        if (canceled === true)
          return;
        if (err) {
          callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
          callback(null);
        }
      }
      for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
      }
    }
    function eachOfGeneric(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
    }
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports.default = (0, _awaitify2.default)(eachOf, 3);
    module2.exports = exports.default;
  }
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS({
  "node_modules/async/internal/withoutIndex.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _withoutIndex;
    function _withoutIndex(iteratee) {
      return (value, index, callback) => iteratee(value, callback);
    }
    module2.exports = exports.default;
  }
});

// node_modules/async/forEach.js
var require_forEach = __commonJS({
  "node_modules/async/forEach.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _withoutIndex = require_withoutIndex();
    var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachLimit(coll, iteratee, callback) {
      return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
    }
    exports.default = (0, _awaitify2.default)(eachLimit, 3);
    module2.exports = exports.default;
  }
});

// node_modules/fn.name/index.js
var require_fn = __commonJS({
  "node_modules/fn.name/index.js"(exports, module2) {
    "use strict";
    var toString = Object.prototype.toString;
    module2.exports = function name(fn) {
      if ("string" === typeof fn.displayName && fn.constructor.name) {
        return fn.displayName;
      } else if ("string" === typeof fn.name && fn.name) {
        return fn.name;
      }
      if ("object" === typeof fn && fn.constructor && "string" === typeof fn.constructor.name)
        return fn.constructor.name;
      var named = fn.toString(), type = toString.call(fn).slice(8, -1);
      if ("Function" === type) {
        named = named.substring(named.indexOf("(") + 1, named.indexOf(")"));
      } else {
        named = type;
      }
      return named || "anonymous";
    };
  }
});

// node_modules/one-time/index.js
var require_one_time = __commonJS({
  "node_modules/one-time/index.js"(exports, module2) {
    "use strict";
    var name = require_fn();
    module2.exports = function one(fn) {
      var called = 0, value;
      function onetime() {
        if (called)
          return value;
        called = 1;
        value = fn.apply(this, arguments);
        fn = null;
        return value;
      }
      onetime.displayName = name(fn);
      return onetime;
    };
  }
});

// node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS({
  "node_modules/stack-trace/lib/stack-trace.js"(exports) {
    exports.get = function(belowFn) {
      var oldLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Infinity;
      var dummyObject = {};
      var v8Handler = Error.prepareStackTrace;
      Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
        return v8StackTrace2;
      };
      Error.captureStackTrace(dummyObject, belowFn || exports.get);
      var v8StackTrace = dummyObject.stack;
      Error.prepareStackTrace = v8Handler;
      Error.stackTraceLimit = oldLimit;
      return v8StackTrace;
    };
    exports.parse = function(err) {
      if (!err.stack) {
        return [];
      }
      var self2 = this;
      var lines = err.stack.split("\n").slice(1);
      return lines.map(function(line) {
        if (line.match(/^\s*[-]{4,}$/)) {
          return self2._createParsedCallSite({
            fileName: line,
            lineNumber: null,
            functionName: null,
            typeName: null,
            methodName: null,
            columnNumber: null,
            "native": null
          });
        }
        var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        if (!lineMatch) {
          return;
        }
        var object = null;
        var method = null;
        var functionName = null;
        var typeName = null;
        var methodName = null;
        var isNative = lineMatch[5] === "native";
        if (lineMatch[1]) {
          functionName = lineMatch[1];
          var methodStart = functionName.lastIndexOf(".");
          if (functionName[methodStart - 1] == ".")
            methodStart--;
          if (methodStart > 0) {
            object = functionName.substr(0, methodStart);
            method = functionName.substr(methodStart + 1);
            var objectEnd = object.indexOf(".Module");
            if (objectEnd > 0) {
              functionName = functionName.substr(objectEnd + 1);
              object = object.substr(0, objectEnd);
            }
          }
          typeName = null;
        }
        if (method) {
          typeName = object;
          methodName = method;
        }
        if (method === "<anonymous>") {
          methodName = null;
          functionName = null;
        }
        var properties = {
          fileName: lineMatch[2] || null,
          lineNumber: parseInt(lineMatch[3], 10) || null,
          functionName,
          typeName,
          methodName,
          columnNumber: parseInt(lineMatch[4], 10) || null,
          "native": isNative
        };
        return self2._createParsedCallSite(properties);
      }).filter(function(callSite) {
        return !!callSite;
      });
    };
    function CallSite(properties) {
      for (var property in properties) {
        this[property] = properties[property];
      }
    }
    var strProperties = [
      "this",
      "typeName",
      "functionName",
      "methodName",
      "fileName",
      "lineNumber",
      "columnNumber",
      "function",
      "evalOrigin"
    ];
    var boolProperties = [
      "topLevel",
      "eval",
      "native",
      "constructor"
    ];
    strProperties.forEach(function(property) {
      CallSite.prototype[property] = null;
      CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    boolProperties.forEach(function(property) {
      CallSite.prototype[property] = false;
      CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    exports._createParsedCallSite = function(properties) {
      return new CallSite(properties);
    };
  }
});

// node_modules/winston/lib/winston/exception-stream.js
var require_exception_stream = __commonJS({
  "node_modules/winston/lib/winston/exception-stream.js"(exports, module2) {
    "use strict";
    var { Writable } = require_readable();
    module2.exports = class ExceptionStream extends Writable {
      /**
       * Constructor function for the ExceptionStream responsible for wrapping a
       * TransportStream; only allowing writes of `info` objects with
       * `info.exception` set to true.
       * @param {!TransportStream} transport - Stream to filter to exceptions
       */
      constructor(transport) {
        super({ objectMode: true });
        if (!transport) {
          throw new Error("ExceptionStream requires a TransportStream instance.");
        }
        this.handleExceptions = true;
        this.transport = transport;
      }
      /**
       * Writes the info object to our transport instance if (and only if) the
       * `exception` property is set on the info.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _write(info, enc, callback) {
        if (info.exception) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    };
  }
});

// node_modules/winston/lib/winston/exception-handler.js
var require_exception_handler = __commonJS({
  "node_modules/winston/lib/winston/exception-handler.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach();
    var debug = require_node2()("winston:exception");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var ExceptionStream = require_exception_stream();
    module2.exports = class ExceptionHandler {
      /**
       * TODO: add contructor description
       * @param {!Logger} logger - TODO: add param description
       */
      constructor(logger) {
        if (!logger) {
          throw new Error("Logger is required to handle exceptions");
        }
        this.logger = logger;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
       * Handles `uncaughtException` events for the current process by adding any
       * handlers passed in.
       * @returns {undefined}
       */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._uncaughtException.bind(this);
          process.on("uncaughtException", this.catcher);
        }
      }
      /**
       * Removes any handlers to `uncaughtException` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
      unhandle() {
        if (this.catcher) {
          process.removeListener("uncaughtException", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
        }
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
      getAllInfo(err) {
        let message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `uncaughtException: ${message || "(no error message)"}`,
            err && err.stack || "  No stack trace"
          ].join("\n"),
          stack: err && err.stack,
          exception: true,
          date: new Date().toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleExceptions = true;
          const wrapper = new ExceptionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _uncaughtException(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getExceptionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no exception handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(handlers, (handler, next) => {
          const done = once(next);
          const transport = handler.transport || handler;
          function onDone(event) {
            return () => {
              debug(event);
              done();
            };
          }
          transport._ending = true;
          transport.once("finish", onDone("finished"));
          transport.once("error", onDone("error"));
        }, () => doExit && gracefulExit());
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
      _getExceptionHandlers() {
        return this.logger.transports.filter((wrap) => {
          const transport = wrap.transport || wrap;
          return transport.handleExceptions;
        });
      }
    };
  }
});

// node_modules/winston/lib/winston/rejection-handler.js
var require_rejection_handler = __commonJS({
  "node_modules/winston/lib/winston/rejection-handler.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach();
    var debug = require_node2()("winston:rejection");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var ExceptionStream = require_exception_stream();
    module2.exports = class RejectionHandler {
      /**
       * TODO: add contructor description
       * @param {!Logger} logger - TODO: add param description
       */
      constructor(logger) {
        if (!logger) {
          throw new Error("Logger is required to handle rejections");
        }
        this.logger = logger;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
       * Handles `unhandledRejection` events for the current process by adding any
       * handlers passed in.
       * @returns {undefined}
       */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._unhandledRejection.bind(this);
          process.on("unhandledRejection", this.catcher);
        }
      }
      /**
       * Removes any handlers to `unhandledRejection` events for the current
       * process. This does not modify the state of the `this.handlers` set.
       * @returns {undefined}
       */
      unhandle() {
        if (this.catcher) {
          process.removeListener("unhandledRejection", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach(
            (wrapper) => this.logger.unpipe(wrapper)
          );
        }
      }
      /**
       * TODO: add method description
       * @param {Error} err - Error to get information about.
       * @returns {mixed} - TODO: add return description.
       */
      getAllInfo(err) {
        let message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `unhandledRejection: ${message || "(no error message)"}`,
            err && err.stack || "  No stack trace"
          ].join("\n"),
          stack: err && err.stack,
          exception: true,
          date: new Date().toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
       * Gets all relevant process information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
       * Gets all relevant OS information for the currently running process.
       * @returns {mixed} - TODO: add return description.
       */
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      /**
       * Gets a stack trace for the specified error.
       * @param {mixed} err - TODO: add param description.
       * @returns {mixed} - TODO: add return description.
       */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
       * Helper method to add a transport as an exception handler.
       * @param {Transport} handler - The transport to add as an exception handler.
       * @returns {void}
       */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleRejections = true;
          const wrapper = new ExceptionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
       * Logs all relevant information around the `err` and exits the current
       * process.
       * @param {Error} err - Error to handle
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      _unhandledRejection(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getRejectionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no rejection handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(
          handlers,
          (handler, next) => {
            const done = once(next);
            const transport = handler.transport || handler;
            function onDone(event) {
              return () => {
                debug(event);
                done();
              };
            }
            transport._ending = true;
            transport.once("finish", onDone("finished"));
            transport.once("error", onDone("error"));
          },
          () => doExit && gracefulExit()
        );
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
       * Returns the list of transports and exceptionHandlers for this instance.
       * @returns {Array} - List of transports and exceptionHandlers for this
       * instance.
       * @private
       */
      _getRejectionHandlers() {
        return this.logger.transports.filter((wrap) => {
          const transport = wrap.transport || wrap;
          return transport.handleRejections;
        });
      }
    };
  }
});

// node_modules/winston/lib/winston/profiler.js
var require_profiler = __commonJS({
  "node_modules/winston/lib/winston/profiler.js"(exports, module2) {
    "use strict";
    var Profiler = class {
      /**
       * Constructor function for the Profiler instance used by
       * `Logger.prototype.startTimer`. When done is called the timer will finish
       * and log the duration.
       * @param {!Logger} logger - TODO: add param description.
       * @private
       */
      constructor(logger) {
        const Logger = require_logger();
        if (typeof logger !== "object" || Array.isArray(logger) || !(logger instanceof Logger)) {
          throw new Error("Logger is required for profiling");
        } else {
          this.logger = logger;
          this.start = Date.now();
        }
      }
      /**
       * Ends the current timer (i.e. Profiler) instance and logs the `msg` along
       * with the duration since creation.
       * @returns {mixed} - TODO: add return description.
       * @private
       */
      done(...args) {
        if (typeof args[args.length - 1] === "function") {
          console.warn("Callback function no longer supported as of winston@3.0.0");
          args.pop();
        }
        const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
        info.level = info.level || "info";
        info.durationMs = Date.now() - this.start;
        return this.logger.write(info);
      }
    };
    module2.exports = Profiler;
  }
});

// node_modules/winston/lib/winston/logger.js
var require_logger = __commonJS({
  "node_modules/winston/lib/winston/logger.js"(exports, module2) {
    "use strict";
    var { Stream, Transform } = require_readable();
    var asyncForEach = require_forEach();
    var { LEVEL, SPLAT } = require_triple_beam();
    var isStream = require_is_stream();
    var ExceptionHandler = require_exception_handler();
    var RejectionHandler = require_rejection_handler();
    var LegacyTransportStream = require_legacy();
    var Profiler = require_profiler();
    var { warn } = require_common();
    var config = require_config2();
    var formatRegExp = /%[scdjifoO%]/g;
    var Logger = class extends Transform {
      /**
       * Constructor function for the Logger object responsible for persisting log
       * messages and metadata to one or more transports.
       * @param {!Object} options - foo
       */
      constructor(options) {
        super({ objectMode: true });
        this.configure(options);
      }
      child(defaultRequestMetadata) {
        const logger = this;
        return Object.create(logger, {
          write: {
            value: function(info) {
              const infoClone = Object.assign(
                {},
                defaultRequestMetadata,
                info
              );
              if (info instanceof Error) {
                infoClone.stack = info.stack;
                infoClone.message = info.message;
              }
              logger.write(infoClone);
            }
          }
        });
      }
      /**
       * This will wholesale reconfigure this instance by:
       * 1. Resetting all transports. Older transports will be removed implicitly.
       * 2. Set all other options including levels, colors, rewriters, filters,
       *    exceptionHandlers, etc.
       * @param {!Object} options - TODO: add param description.
       * @returns {undefined}
       */
      configure({
        silent,
        format,
        defaultMeta,
        levels,
        level = "info",
        exitOnError = true,
        transports,
        colors,
        emitErrs,
        formatters,
        padLevels,
        rewriters,
        stripColors,
        exceptionHandlers,
        rejectionHandlers
      } = {}) {
        if (this.transports.length) {
          this.clear();
        }
        this.silent = silent;
        this.format = format || this.format || require_json()();
        this.defaultMeta = defaultMeta || null;
        this.levels = levels || this.levels || config.npm.levels;
        this.level = level;
        if (this.exceptions) {
          this.exceptions.unhandle();
        }
        if (this.rejections) {
          this.rejections.unhandle();
        }
        this.exceptions = new ExceptionHandler(this);
        this.rejections = new RejectionHandler(this);
        this.profilers = {};
        this.exitOnError = exitOnError;
        if (transports) {
          transports = Array.isArray(transports) ? transports : [transports];
          transports.forEach((transport) => this.add(transport));
        }
        if (colors || emitErrs || formatters || padLevels || rewriters || stripColors) {
          throw new Error(
            [
              "{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.",
              "Use a custom winston.format(function) instead.",
              "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
            ].join("\n")
          );
        }
        if (exceptionHandlers) {
          this.exceptions.handle(exceptionHandlers);
        }
        if (rejectionHandlers) {
          this.rejections.handle(rejectionHandlers);
        }
      }
      isLevelEnabled(level) {
        const givenLevelValue = getLevelValue(this.levels, level);
        if (givenLevelValue === null) {
          return false;
        }
        const configuredLevelValue = getLevelValue(this.levels, this.level);
        if (configuredLevelValue === null) {
          return false;
        }
        if (!this.transports || this.transports.length === 0) {
          return configuredLevelValue >= givenLevelValue;
        }
        const index = this.transports.findIndex((transport) => {
          let transportLevelValue = getLevelValue(this.levels, transport.level);
          if (transportLevelValue === null) {
            transportLevelValue = configuredLevelValue;
          }
          return transportLevelValue >= givenLevelValue;
        });
        return index !== -1;
      }
      /* eslint-disable valid-jsdoc */
      /**
       * Ensure backwards compatibility with a `log` method
       * @param {mixed} level - Level the log message is written at.
       * @param {mixed} msg - TODO: add param description.
       * @param {mixed} meta - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       *
       * @example
       *    // Supports the existing API:
       *    logger.log('info', 'Hello world', { custom: true });
       *    logger.log('info', new Error('Yo, it\'s on fire'));
       *
       *    // Requires winston.format.splat()
       *    logger.log('info', '%s %d%%', 'A string', 50, { thisIsMeta: true });
       *
       *    // And the new API with a single JSON literal:
       *    logger.log({ level: 'info', message: 'Hello world', custom: true });
       *    logger.log({ level: 'info', message: new Error('Yo, it\'s on fire') });
       *
       *    // Also requires winston.format.splat()
       *    logger.log({
       *      level: 'info',
       *      message: '%s %d%%',
       *      [SPLAT]: ['A string', 50],
       *      meta: { thisIsMeta: true }
       *    });
       *
       */
      /* eslint-enable valid-jsdoc */
      log(level, msg, ...splat) {
        if (arguments.length === 1) {
          level[LEVEL] = level.level;
          this._addDefaultMeta(level);
          this.write(level);
          return this;
        }
        if (arguments.length === 2) {
          if (msg && typeof msg === "object") {
            msg[LEVEL] = msg.level = level;
            this._addDefaultMeta(msg);
            this.write(msg);
            return this;
          }
          msg = { [LEVEL]: level, level, message: msg };
          this._addDefaultMeta(msg);
          this.write(msg);
          return this;
        }
        const [meta] = splat;
        if (typeof meta === "object" && meta !== null) {
          const tokens = msg && msg.match && msg.match(formatRegExp);
          if (!tokens) {
            const info = Object.assign({}, this.defaultMeta, meta, {
              [LEVEL]: level,
              [SPLAT]: splat,
              level,
              message: msg
            });
            if (meta.message)
              info.message = `${info.message} ${meta.message}`;
            if (meta.stack)
              info.stack = meta.stack;
            this.write(info);
            return this;
          }
        }
        this.write(Object.assign({}, this.defaultMeta, {
          [LEVEL]: level,
          [SPLAT]: splat,
          level,
          message: msg
        }));
        return this;
      }
      /**
       * Pushes data so that it can be picked up by all of our pipe targets.
       * @param {mixed} info - TODO: add param description.
       * @param {mixed} enc - TODO: add param description.
       * @param {mixed} callback - Continues stream processing.
       * @returns {undefined}
       * @private
       */
      _transform(info, enc, callback) {
        if (this.silent) {
          return callback();
        }
        if (!info[LEVEL]) {
          info[LEVEL] = info.level;
        }
        if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
          console.error("[winston] Unknown logger level: %s", info[LEVEL]);
        }
        if (!this._readableState.pipes) {
          console.error(
            "[winston] Attempt to write logs with no transports, which can increase memory usage: %j",
            info
          );
        }
        try {
          this.push(this.format.transform(info, this.format.options));
        } finally {
          this._writableState.sync = false;
          callback();
        }
      }
      /**
       * Delays the 'finish' event until all transport pipe targets have
       * also emitted 'finish' or are already finished.
       * @param {mixed} callback - Continues stream processing.
       */
      _final(callback) {
        const transports = this.transports.slice();
        asyncForEach(
          transports,
          (transport, next) => {
            if (!transport || transport.finished)
              return setImmediate(next);
            transport.once("finish", next);
            transport.end();
          },
          callback
        );
      }
      /**
       * Adds the transport to this logger instance by piping to it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
      add(transport) {
        const target = !isStream(transport) || transport.log.length > 2 ? new LegacyTransportStream({ transport }) : transport;
        if (!target._writableState || !target._writableState.objectMode) {
          throw new Error(
            "Transports must WritableStreams in objectMode. Set { objectMode: true }."
          );
        }
        this._onEvent("error", target);
        this._onEvent("warn", target);
        this.pipe(target);
        if (transport.handleExceptions) {
          this.exceptions.handle();
        }
        if (transport.handleRejections) {
          this.rejections.handle();
        }
        return this;
      }
      /**
       * Removes the transport from this logger instance by unpiping from it.
       * @param {mixed} transport - TODO: add param description.
       * @returns {Logger} - TODO: add return description.
       */
      remove(transport) {
        if (!transport)
          return this;
        let target = transport;
        if (!isStream(transport) || transport.log.length > 2) {
          target = this.transports.filter(
            (match) => match.transport === transport
          )[0];
        }
        if (target) {
          this.unpipe(target);
        }
        return this;
      }
      /**
       * Removes all transports from this logger instance.
       * @returns {Logger} - TODO: add return description.
       */
      clear() {
        this.unpipe();
        return this;
      }
      /**
       * Cleans up resources (streams, event listeners) for all transports
       * associated with this instance (if necessary).
       * @returns {Logger} - TODO: add return description.
       */
      close() {
        this.exceptions.unhandle();
        this.rejections.unhandle();
        this.clear();
        this.emit("close");
        return this;
      }
      /**
       * Sets the `target` levels specified on this instance.
       * @param {Object} Target levels to use on this instance.
       */
      setLevels() {
        warn.deprecated("setLevels");
      }
      /**
       * Queries the all transports for this instance with the specified `options`.
       * This will aggregate each transport's results into one object containing
       * a property per transport.
       * @param {Object} options - Query options for this instance.
       * @param {function} callback - Continuation to respond to when complete.
       */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        const results = {};
        const queryObject = Object.assign({}, options.query || {});
        function queryTransport(transport, next) {
          if (options.query && typeof transport.formatQuery === "function") {
            options.query = transport.formatQuery(queryObject);
          }
          transport.query(options, (err, res) => {
            if (err) {
              return next(err);
            }
            if (typeof transport.formatResults === "function") {
              res = transport.formatResults(res, options.format);
            }
            next(null, res);
          });
        }
        function addResults(transport, next) {
          queryTransport(transport, (err, result) => {
            if (next) {
              result = err || result;
              if (result) {
                results[transport.name] = result;
              }
              next();
            }
            next = null;
          });
        }
        asyncForEach(
          this.transports.filter((transport) => !!transport.query),
          addResults,
          () => callback(null, results)
        );
      }
      /**
       * Returns a log stream for all transports. Options object is optional.
       * @param{Object} options={} - Stream options for this instance.
       * @returns {Stream} - TODO: add return description.
       */
      stream(options = {}) {
        const out = new Stream();
        const streams = [];
        out._streams = streams;
        out.destroy = () => {
          let i = streams.length;
          while (i--) {
            streams[i].destroy();
          }
        };
        this.transports.filter((transport) => !!transport.stream).forEach((transport) => {
          const str = transport.stream(options);
          if (!str) {
            return;
          }
          streams.push(str);
          str.on("log", (log) => {
            log.transport = log.transport || [];
            log.transport.push(transport.name);
            out.emit("log", log);
          });
          str.on("error", (err) => {
            err.transport = err.transport || [];
            err.transport.push(transport.name);
            out.emit("error", err);
          });
        });
        return out;
      }
      /**
       * Returns an object corresponding to a specific timing. When done is called
       * the timer will finish and log the duration. e.g.:
       * @returns {Profile} - TODO: add return description.
       * @example
       *    const timer = winston.startTimer()
       *    setTimeout(() => {
       *      timer.done({
       *        message: 'Logging message'
       *      });
       *    }, 1000);
       */
      startTimer() {
        return new Profiler(this);
      }
      /**
       * Tracks the time inbetween subsequent calls to this method with the same
       * `id` parameter. The second call to this method will log the difference in
       * milliseconds along with the message.
       * @param {string} id Unique id of the profiler
       * @returns {Logger} - TODO: add return description.
       */
      profile(id, ...args) {
        const time = Date.now();
        if (this.profilers[id]) {
          const timeEnd = this.profilers[id];
          delete this.profilers[id];
          if (typeof args[args.length - 2] === "function") {
            console.warn(
              "Callback function no longer supported as of winston@3.0.0"
            );
            args.pop();
          }
          const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
          info.level = info.level || "info";
          info.durationMs = time - timeEnd;
          info.message = info.message || id;
          return this.write(info);
        }
        this.profilers[id] = time;
        return this;
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
      handleExceptions(...args) {
        console.warn(
          "Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()"
        );
        this.exceptions.handle(...args);
      }
      /**
       * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
       * @returns {undefined}
       * @deprecated
       */
      unhandleExceptions(...args) {
        console.warn(
          "Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()"
        );
        this.exceptions.unhandle(...args);
      }
      /**
       * Throw a more meaningful deprecation notice
       * @throws {Error} - TODO: add throws description.
       */
      cli() {
        throw new Error(
          [
            "Logger.cli() was removed in winston@3.0.0",
            "Use a custom winston.formats.cli() instead.",
            "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
          ].join("\n")
        );
      }
      /**
       * Bubbles the `event` that occured on the specified `transport` up
       * from this instance.
       * @param {string} event - The event that occured
       * @param {Object} transport - Transport on which the event occured
       * @private
       */
      _onEvent(event, transport) {
        function transportEvent(err) {
          if (event === "error" && !this.transports.includes(transport)) {
            this.add(transport);
          }
          this.emit(event, err, transport);
        }
        if (!transport["__winston" + event]) {
          transport["__winston" + event] = transportEvent.bind(this);
          transport.on(event, transport["__winston" + event]);
        }
      }
      _addDefaultMeta(msg) {
        if (this.defaultMeta) {
          Object.assign(msg, this.defaultMeta);
        }
      }
    };
    function getLevelValue(levels, level) {
      const value = levels[level];
      if (!value && value !== 0) {
        return null;
      }
      return value;
    }
    Object.defineProperty(Logger.prototype, "transports", {
      configurable: false,
      enumerable: true,
      get() {
        const { pipes } = this._readableState;
        return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;
      }
    });
    module2.exports = Logger;
  }
});

// node_modules/winston/lib/winston/create-logger.js
var require_create_logger = __commonJS({
  "node_modules/winston/lib/winston/create-logger.js"(exports, module2) {
    "use strict";
    var { LEVEL } = require_triple_beam();
    var config = require_config2();
    var Logger = require_logger();
    var debug = require_node2()("winston:create-logger");
    function isLevelEnabledFunctionName(level) {
      return "is" + level.charAt(0).toUpperCase() + level.slice(1) + "Enabled";
    }
    module2.exports = function(opts = {}) {
      opts.levels = opts.levels || config.npm.levels;
      class DerivedLogger extends Logger {
        /**
         * Create a new class derived logger for which the levels can be attached to
         * the prototype of. This is a V8 optimization that is well know to increase
         * performance of prototype functions.
         * @param {!Object} options - Options for the created logger.
         */
        constructor(options) {
          super(options);
        }
      }
      const logger = new DerivedLogger(opts);
      Object.keys(opts.levels).forEach(function(level) {
        debug('Define prototype method for "%s"', level);
        if (level === "log") {
          console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
          return;
        }
        DerivedLogger.prototype[level] = function(...args) {
          const self2 = this || logger;
          if (args.length === 1) {
            const [msg] = args;
            const info = msg && msg.message && msg || { message: msg };
            info.level = info[LEVEL] = level;
            self2._addDefaultMeta(info);
            self2.write(info);
            return this || logger;
          }
          if (args.length === 0) {
            self2.log(level, "");
            return self2;
          }
          return self2.log(level, ...args);
        };
        DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function() {
          return (this || logger).isLevelEnabled(level);
        };
      });
      return logger;
    };
  }
});

// node_modules/winston/lib/winston/container.js
var require_container = __commonJS({
  "node_modules/winston/lib/winston/container.js"(exports, module2) {
    "use strict";
    var createLogger = require_create_logger();
    module2.exports = class Container {
      /**
       * Constructor function for the Container object responsible for managing a
       * set of `winston.Logger` instances based on string ids.
       * @param {!Object} [options={}] - Default pass-thru options for Loggers.
       */
      constructor(options = {}) {
        this.loggers = /* @__PURE__ */ new Map();
        this.options = options;
      }
      /**
       * Retrieves a `winston.Logger` instance for the specified `id`. If an
       * instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
      add(id, options) {
        if (!this.loggers.has(id)) {
          options = Object.assign({}, options || this.options);
          const existing = options.transports || this.options.transports;
          if (existing) {
            options.transports = Array.isArray(existing) ? existing.slice() : [existing];
          } else {
            options.transports = [];
          }
          const logger = createLogger(options);
          logger.on("close", () => this._delete(id));
          this.loggers.set(id, logger);
        }
        return this.loggers.get(id);
      }
      /**
       * Retreives a `winston.Logger` instance for the specified `id`. If
       * an instance does not exist, one is created.
       * @param {!string} id - The id of the Logger to get.
       * @param {?Object} [options] - Options for the Logger instance.
       * @returns {Logger} - A configured Logger instance with a specified id.
       */
      get(id, options) {
        return this.add(id, options);
      }
      /**
       * Check if the container has a logger with the id.
       * @param {?string} id - The id of the Logger instance to find.
       * @returns {boolean} - Boolean value indicating if this instance has a
       * logger with the specified `id`.
       */
      has(id) {
        return !!this.loggers.has(id);
      }
      /**
       * Closes a `Logger` instance with the specified `id` if it exists.
       * If no `id` is supplied then all Loggers are closed.
       * @param {?string} id - The id of the Logger instance to close.
       * @returns {undefined}
       */
      close(id) {
        if (id) {
          return this._removeLogger(id);
        }
        this.loggers.forEach((val, key) => this._removeLogger(key));
      }
      /**
       * Remove a logger based on the id.
       * @param {!string} id - The id of the logger to remove.
       * @returns {undefined}
       * @private
       */
      _removeLogger(id) {
        if (!this.loggers.has(id)) {
          return;
        }
        const logger = this.loggers.get(id);
        logger.close();
        this._delete(id);
      }
      /**
       * Deletes a `Logger` instance with the specified `id`.
       * @param {!string} id - The id of the Logger instance to delete from
       * container.
       * @returns {undefined}
       * @private
       */
      _delete(id) {
        this.loggers.delete(id);
      }
    };
  }
});

// node_modules/winston/lib/winston.js
var require_winston = __commonJS({
  "node_modules/winston/lib/winston.js"(exports) {
    "use strict";
    var logform = require_logform();
    var { warn } = require_common();
    exports.version = require_package().version;
    exports.transports = require_transports();
    exports.config = require_config2();
    exports.addColors = logform.levels;
    exports.format = logform.format;
    exports.createLogger = require_create_logger();
    exports.Logger = require_logger();
    exports.ExceptionHandler = require_exception_handler();
    exports.RejectionHandler = require_rejection_handler();
    exports.Container = require_container();
    exports.Transport = require_winston_transport();
    exports.loggers = new exports.Container();
    var defaultLogger = exports.createLogger();
    Object.keys(exports.config.npm.levels).concat([
      "log",
      "query",
      "stream",
      "add",
      "remove",
      "clear",
      "profile",
      "startTimer",
      "handleExceptions",
      "unhandleExceptions",
      "handleRejections",
      "unhandleRejections",
      "configure",
      "child"
    ]).forEach(
      (method) => exports[method] = (...args) => defaultLogger[method](...args)
    );
    Object.defineProperty(exports, "level", {
      get() {
        return defaultLogger.level;
      },
      set(val) {
        defaultLogger.level = val;
      }
    });
    Object.defineProperty(exports, "exceptions", {
      get() {
        return defaultLogger.exceptions;
      }
    });
    ["exitOnError"].forEach((prop) => {
      Object.defineProperty(exports, prop, {
        get() {
          return defaultLogger[prop];
        },
        set(val) {
          defaultLogger[prop] = val;
        }
      });
    });
    Object.defineProperty(exports, "default", {
      get() {
        return {
          exceptionHandlers: defaultLogger.exceptionHandlers,
          rejectionHandlers: defaultLogger.rejectionHandlers,
          transports: defaultLogger.transports
        };
      }
    });
    warn.deprecated(exports, "setLevels");
    warn.forFunctions(exports, "useFormat", ["cli"]);
    warn.forProperties(exports, "useFormat", ["padLevels", "stripColors"]);
    warn.forFunctions(exports, "deprecated", [
      "addRewriter",
      "addFilter",
      "clone",
      "extend"
    ]);
    warn.forProperties(exports, "deprecated", ["emitErrs", "levelLength"]);
  }
});

// node_modules/neovim/lib/utils/logger.js
var require_logger2 = __commonJS({
  "node_modules/neovim/lib/utils/logger.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLogger = void 0;
    var winston = __importStar(require_winston());
    var node_util_1 = require("util");
    var level = process.env.NVIM_NODE_LOG_LEVEL || "debug";
    function getFormat(colorize) {
      return winston.format.combine(winston.format.splat(), winston.format.timestamp({
        format: "YYYY-MM-DD HH:mm:ss"
      }), winston.format.printf((info) => {
        let msg;
        try {
          msg = typeof info.message === "object" ? (0, node_util_1.inspect)(info.message, false, 2, colorize) : info.message;
        } catch (_a) {
          msg = info.message;
        }
        const lvl = info.level === "debug" ? "DBG" : info.level.slice(0, 3).toUpperCase();
        return `${info.timestamp} ${lvl} ${msg}`;
      }));
    }
    function setupWinstonLogger() {
      const logger = winston.createLogger({
        level
      });
      if (process.env.NVIM_NODE_LOG_FILE) {
        logger.add(new winston.transports.File({
          filename: process.env.NVIM_NODE_LOG_FILE,
          level,
          format: getFormat(false)
        }));
      }
      if (process.env.ALLOW_CONSOLE) {
        logger.add(new winston.transports.Console({
          format: getFormat(true)
        }));
      }
      if (!process.env.NVIM_NODE_LOG_FILE && !process.env.ALLOW_CONSOLE) {
        logger.add(new winston.transports.Console({ silent: true }));
      }
      Object.keys(console).forEach((k) => {
        console[k] = function() {
          logger[k === "log" ? "info" : k].apply(logger, arguments);
        };
      });
      return logger;
    }
    var _logger;
    function getLogger() {
      if (!_logger) {
        _logger = setupWinstonLogger();
      }
      return _logger;
    }
    exports.getLogger = getLogger;
  }
});

// node_modules/neovim/lib/api/Base.js
var require_Base = __commonJS({
  "node_modules/neovim/lib/api/Base.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseApi = void 0;
    var node_events_1 = require("events");
    var util_1 = require_util();
    var logger_1 = require_logger2();
    var DO_REQUEST = Symbol("DO_REQUEST");
    var BaseApi = class extends node_events_1.EventEmitter {
      constructor({ transport, data, logger, metadata, client }) {
        super();
        this[_a] = (name, args = []) => new Promise((resolve, reject) => {
          this.transport.request(name, args, (err, res) => {
            if (this.logger.level === "debug") {
              let logData;
              try {
                logData = res && typeof res === "object" ? (0, util_1.partialClone)(res, 2, ["logger", "transport", "client"], "[Object]") : res;
              } catch (_b) {
                logData = String(res);
              }
              this.logger.debug(`response -> ${name}: %O`, logData);
            }
            if (err) {
              reject(new Error(`${name}: ${err[1]}`));
            } else {
              resolve(res);
            }
          });
        });
        this.setTransport(transport);
        this.data = data;
        this.logger = logger || (0, logger_1.getLogger)();
        this.client = client;
        if (metadata) {
          Object.defineProperty(this, "metadata", { value: metadata });
        }
      }
      setTransport(transport) {
        this.transport = transport;
      }
      equals(other) {
        try {
          return String(this.data) === String(other.data);
        } catch (e) {
          return false;
        }
      }
      asyncRequest(name, args = []) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this._isReady;
          this.logger.debug(`request  -> ${name}`);
          return this[DO_REQUEST](name, args).catch((err) => {
            const newError = new Error(err.message);
            this.logger.error(`failed request to "%s": %s: %s`, name, newError.name, newError.message);
            throw newError;
          });
        });
      }
      request(name, args = []) {
        return this.asyncRequest(name, args);
      }
      _getArgsByPrefix(...args) {
        const _args = [];
        if (this.prefix !== "nvim_") {
          _args.push(this);
        }
        return _args.concat(args);
      }
      /** Retrieves a scoped variable depending on type (using `this.prefix`) */
      getVar(name) {
        return __awaiter(this, void 0, void 0, function* () {
          const args = this._getArgsByPrefix(name);
          return this.request(`${this.prefix}get_var`, args).then((res) => res, (err) => {
            if (err && err.message && err.message.includes("not found")) {
              return null;
            }
            throw err;
          });
        });
      }
      /** Set a scoped variable */
      setVar(name, value) {
        const args = this._getArgsByPrefix(name, value);
        return this.request(`${this.prefix}set_var`, args);
      }
      /** Delete a scoped variable */
      deleteVar(name) {
        const args = this._getArgsByPrefix(name);
        return this.request(`${this.prefix}del_var`, args);
      }
      /** Retrieves a scoped option depending on type of `this` */
      getOption(name) {
        const args = this._getArgsByPrefix(name);
        return this.request(`${this.prefix}get_option`, args);
      }
      /** Set scoped option */
      setOption(name, value) {
        const args = this._getArgsByPrefix(name, value);
        return this.request(`${this.prefix}set_option`, args);
      }
      // TODO: Is this necessary?
      /** `request` is basically the same except you can choose to wait forpromise to be resolved */
      notify(name, args) {
        this.logger.debug(`notify -> ${name}`);
        this.transport.notify(name, args);
      }
    };
    exports.BaseApi = BaseApi;
    _a = DO_REQUEST;
  }
});

// node_modules/neovim/lib/api/Buffer.js
var require_Buffer = __commonJS({
  "node_modules/neovim/lib/api/Buffer.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    var _b;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Buffer = exports.ATTACH = exports.DETACH = void 0;
    var Base_1 = require_Base();
    var types_1 = require_types();
    exports.DETACH = Symbol("detachBuffer");
    exports.ATTACH = Symbol("attachBuffer");
    var Buffer2 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = types_1.Metadata[types_1.ExtType.Buffer].prefix;
        this[_a] = (sendBuffer = false, options = {}) => __awaiter(this, void 0, void 0, function* () {
          if (this.client.isAttached(this))
            return true;
          return this.request(`${this.prefix}attach`, [this, sendBuffer, options]);
        });
        this[_b] = () => this.request(`${this.prefix}detach`, [this]);
      }
      get isAttached() {
        return this.client.isAttached(this);
      }
      /**
       * Get the bufnr of Buffer
       */
      get id() {
        return this.data;
      }
      /** Total number of lines in buffer */
      get length() {
        return this.request(`${this.prefix}line_count`, [this]);
      }
      /** Get lines in buffer */
      get lines() {
        return this.getLines();
      }
      /** Gets a changed tick of a buffer */
      get changedtick() {
        return this.request(`${this.prefix}get_changedtick`, [this]);
      }
      get commands() {
        return this.getCommands();
      }
      getCommands(options = {}) {
        return this.request(`${this.prefix}get_commands`, [this, options]);
      }
      /** Get specific lines of buffer */
      getLines({ start, end, strictIndexing } = { start: 0, end: -1, strictIndexing: true }) {
        const indexing = typeof strictIndexing === "undefined" ? true : strictIndexing;
        return this.request(`${this.prefix}get_lines`, [
          this,
          start,
          end,
          indexing
        ]);
      }
      /** Set lines of buffer given indeces */
      setLines(_lines, { start: _start, end: _end, strictIndexing } = {
        strictIndexing: true
      }) {
        const indexing = typeof strictIndexing === "undefined" ? true : strictIndexing;
        const lines = typeof _lines === "string" ? [_lines] : _lines;
        const end = typeof _end !== "undefined" ? _end : _start + 1;
        return this.request(`${this.prefix}set_lines`, [
          this,
          _start,
          end,
          indexing,
          lines
        ]);
      }
      /** Insert lines at `start` index */
      insert(lines, start) {
        return this.setLines(lines, {
          start,
          end: start,
          strictIndexing: true
        });
      }
      /** Replace lines starting at `start` index */
      replace(_lines, start) {
        const lines = typeof _lines === "string" ? [_lines] : _lines;
        return this.setLines(lines, {
          start,
          end: start + lines.length,
          strictIndexing: false
        });
      }
      /** Remove lines at index */
      remove(start, end, strictIndexing) {
        return this.setLines([], { start, end, strictIndexing });
      }
      /** Append a string or list of lines to end of buffer */
      append(lines) {
        return this.setLines(lines, {
          start: -1,
          end: -1,
          strictIndexing: false
        });
      }
      /** Get buffer name */
      get name() {
        return this.request(`${this.prefix}get_name`, [this]);
      }
      /** Set current buffer name */
      set name(value) {
        this.request(`${this.prefix}set_name`, [this, value]);
      }
      /** Is current buffer valid */
      get valid() {
        return this.request(`${this.prefix}is_valid`, [this]);
      }
      /** Get mark position given mark name */
      mark(name) {
        return this.request(`${this.prefix}get_mark`, [this, name]);
      }
      // range(start, end) {
      // """Return a `Range` object, which represents part of the Buffer."""
      // return Range(this, start, end)
      // }
      /**
       * Gets a list of buffer-local |mapping| definitions.
       */
      getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [this, mode]);
      }
      /**
       * Checks if a buffer is valid and loaded. See |api-buffer| for
       * more info about unloaded buffers.
       */
      get loaded() {
        return this.request(`${this.prefix}is_loaded`, [this]);
      }
      /**
       * Returns the byte offset for a line.
       *
       * Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is
       * one byte. 'fileformat' and 'fileencoding' are ignored. The
       * line index just after the last line gives the total byte-count
       * of the buffer. A final EOL byte is counted if it would be
       * written, see 'eol'.
       *
       * Unlike |line2byte()|, throws error for out-of-bounds indexing.
       * Returns -1 for unloaded buffer.
       *
       * @return {Number} Integer byte offset, or -1 for unloaded buffer.
       */
      getOffset(index) {
        return this.request(`${this.prefix}get_offset`, [this, index]);
      }
      /**
       * Adds a highlight to buffer.
       *
       * Useful for plugins that dynamically generate highlights to a
       * buffer (like a semantic highlighter or linter). The function
       * adds a single highlight to a buffer. Unlike |matchaddpos()|
       * highlights follow changes to line numbering (as lines are
       * inserted/removed above the highlighted line), like signs and
       * marks do.
       *
       * Namespaces are used for batch deletion/updating of a set of
       * highlights. To create a namespace, use |nvim_create_namespace|
       * which returns a namespace id. Pass it in to this function as
       * `ns_id` to add highlights to the namespace. All highlights in
       * the same namespace can then be cleared with single call to
       * |nvim_buf_clear_namespace|. If the highlight never will be
       * deleted by an API call, pass `ns_id = -1`.
       *
       * As a shorthand, `ns_id = 0` can be used to create a new
       * namespace for the highlight, the allocated id is then
       * returned. If `hl_group` is the empty string no highlight is
       * added, but a new `ns_id` is still returned. This is supported
       * for backwards compatibility, new code should use
       * |nvim_create_namespace| to create a new empty namespace.
       */
      addHighlight({ hlGroup: _hlGroup, line, colStart: _start, colEnd: _end, srcId: _srcId }) {
        const hlGroup = typeof _hlGroup !== "undefined" ? _hlGroup : "";
        const colEnd = typeof _end !== "undefined" ? _end : -1;
        const colStart = typeof _start !== "undefined" ? _start : -0;
        const srcId = typeof _srcId !== "undefined" ? _srcId : -1;
        return this.request(`${this.prefix}add_highlight`, [
          this,
          srcId,
          hlGroup,
          line,
          colStart,
          colEnd
        ]);
      }
      /**
       * Deprecated
       */
      clearHighlight(args = {}) {
        console.warn("`clearHighlight` is deprecated, use ``clearNamespace()` instead");
        const defaults = {
          srcId: -1,
          lineStart: 0,
          lineEnd: -1
        };
        const { srcId, lineStart, lineEnd } = Object.assign(Object.assign({}, defaults), args);
        return this.request(`${this.prefix}clear_highlight`, [
          this,
          srcId,
          lineStart,
          lineEnd
        ]);
      }
      /**
       * Clears namespaced objects, highlights and virtual text, from a line range
       *
       * To clear the namespace in the entire buffer, pass in 0 and -1 to line_start and line_end respectively.
       *
       * @param {Number} nsId Namespace to clear, or -1 to clear all namespaces
       * @param {Number} lineStart Start of range of lines to clear
       * @param {Number} lineEnd End of range of lines to clear (exclusive) or -1 to clear to end of buffer
       */
      clearNamespace(args) {
        const defaults = {
          nsId: -1,
          lineStart: 0,
          lineEnd: -1
        };
        const { nsId, lineStart, lineEnd } = Object.assign(Object.assign({}, defaults), args);
        this.request(`${this.prefix}clear_namespace`, [
          this,
          nsId,
          lineStart,
          lineEnd
        ]);
      }
      /**
       * Set the virtual text (annotation) for a buffer line.
       *
       * By default (and currently the only option) the text will be
       * placed after the buffer text. Virtual text will never cause
       * reflow, rather virtual text will be truncated at the end of
       * the screen line. The virtual text will begin one cell
       * (|lcs-eol| or space) after the ordinary text.
       *
       * Namespaces are used to support batch deletion/updating of
       * virtual text. To create a namespace, use
       * |nvim_create_namespace|. Virtual text is cleared using
       * |nvim_buf_clear_namespace|. The same `ns_id` can be used for
       * both virtual text and highlights added by
       * |nvim_buf_add_highlight|, both can then be cleared with a
       * single call to |nvim_buf_clear_namespace|. If the virtual text
       * never will be cleared by an API call, pass `ns_id = -1`.
       *
       * As a shorthand, `ns_id = 0` can be used to create a new
       * namespace for the virtual text, the allocated id is then
       * returned.
       *
       * @param
       * @param {Number} nsId Namespace to use or 0 to create a namespace, or -1 for a ungrouped annotation
       * @param {Number} line Line to annotate with virtual text (zero-indexed)
       * @param {VirtualTextChunk[]} chunks  A list of [text, hl_group] arrays, each
                                  representing a text chunk with specified
                                  highlight. `hl_group` element can be omitted for
                                  no highlight.
       * @param {Object} opts Optional parameters. Currently not used.
       */
      setVirtualText(nsId, line, chunks, opts = {}) {
        return this.request(`${this.prefix}set_virtual_text`, [
          this,
          nsId,
          line,
          chunks,
          opts
        ]);
      }
      /**
       * Listens to buffer for events
       */
      listen(eventName, cb) {
        if (!this.isAttached) {
          this[exports.ATTACH]().then((attached) => {
            if (!attached) {
              this.unlisten(eventName, cb);
            }
          });
        }
        this.client.attachBuffer(this, eventName, cb);
        return () => {
          this.unlisten(eventName, cb);
        };
      }
      unlisten(eventName, cb) {
        if (!this.isAttached)
          return;
        const shouldDetach = this.client.detachBuffer(this, eventName, cb);
        if (!shouldDetach)
          return;
        this[exports.DETACH]();
      }
    };
    exports.Buffer = Buffer2;
    _a = exports.ATTACH, _b = exports.DETACH;
  }
});

// node_modules/neovim/lib/api/utils/createChainableApi.js
var require_createChainableApi = __commonJS({
  "node_modules/neovim/lib/api/utils/createChainableApi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createChainableApi = void 0;
    var Base_1 = require_Base();
    var baseProperties = Object.getOwnPropertyNames(Base_1.BaseApi.prototype);
    function createChainableApi(name, Type, requestPromise, chainCallPromise) {
      if (this[`${name}Promise`] && this[`${name}Promise`].status === 0 && this[`${name}Proxy`]) {
        return this[`${name}Proxy`];
      }
      this[`${name}Promise`] = requestPromise();
      [...baseProperties, ...Object.getOwnPropertyNames(Type.prototype)].forEach((key) => {
        Object.defineProperty(this[`${name}Promise`], key, {
          enumerable: true,
          writable: true,
          configurable: true
        });
      });
      const proxyHandler = {
        get: (target, prop) => {
          const isOnPrototype = Object.prototype.hasOwnProperty.call(Type.prototype, prop) || Object.prototype.hasOwnProperty.call(Base_1.BaseApi.prototype, prop);
          const descriptor = Object.getOwnPropertyDescriptor(Type.prototype, prop) || Object.getOwnPropertyDescriptor(Base_1.BaseApi.prototype, prop);
          const isGetter = descriptor && (typeof descriptor.get !== "undefined" || typeof descriptor.set !== "undefined");
          if (Type && isOnPrototype) {
            if (isOnPrototype && !isGetter && (prop in Type.prototype && typeof Type.prototype[prop] === "function" || prop in Base_1.BaseApi.prototype && typeof Base_1.BaseApi.prototype[prop] === "function")) {
              return (...args) => this[`${name}Promise`].then((res) => res[prop].call(res, ...args));
            }
            return chainCallPromise && chainCallPromise() || this[`${name}Promise`].then((res) => res[prop]);
          }
          if (prop in target) {
            if (typeof target[prop] === "function") {
              return target[prop].bind(target);
            }
            return target[prop];
          }
          return null;
        },
        set: (target, prop, value, receiver) => {
          if (receiver && (receiver instanceof Promise || "then" in receiver)) {
            receiver.then((obj) => {
              if (prop in obj) {
                obj[prop] = value;
              }
            });
          } else {
            target[prop] = value;
          }
          return true;
        }
      };
      this[`${name}Proxy`] = new Proxy(this[`${name}Promise`], proxyHandler);
      return this[`${name}Proxy`];
    }
    exports.createChainableApi = createChainableApi;
  }
});

// node_modules/neovim/lib/api/Tabpage.js
var require_Tabpage = __commonJS({
  "node_modules/neovim/lib/api/Tabpage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tabpage = void 0;
    var Base_1 = require_Base();
    var types_1 = require_types();
    var createChainableApi_1 = require_createChainableApi();
    var Window_1 = require_Window();
    var Tabpage = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = types_1.Metadata[types_1.ExtType.Tabpage].prefix;
      }
      /** Returns all windows of tabpage */
      get windows() {
        return this.request(`${this.prefix}list_wins`, [this]);
      }
      /** Gets the current window of tabpage */
      get window() {
        return createChainableApi_1.createChainableApi.call(this, "Window", Window_1.Window, () => this.request(`${this.prefix}get_win`, [this]));
      }
      /** Is current tabpage valid */
      get valid() {
        return this.request(`${this.prefix}is_valid`, [this]);
      }
      /** Tabpage number */
      get number() {
        return this.request(`${this.prefix}get_number`, [this]);
      }
      /** Invalid */
      getOption() {
        this.logger.error("Tabpage does not have `getOption`");
      }
      /** Invalid */
      setOption() {
        this.logger.error("Tabpage does not have `setOption`");
      }
    };
    exports.Tabpage = Tabpage;
  }
});

// node_modules/neovim/lib/api/Window.js
var require_Window = __commonJS({
  "node_modules/neovim/lib/api/Window.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Window = void 0;
    var Base_1 = require_Base();
    var types_1 = require_types();
    var createChainableApi_1 = require_createChainableApi();
    var Tabpage_1 = require_Tabpage();
    var Buffer_1 = require_Buffer();
    var Window = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = types_1.Metadata[types_1.ExtType.Window].prefix;
      }
      /**
       * The windowid that not change within a Vim session
       */
      get id() {
        return this.data;
      }
      /** Get current buffer of window */
      get buffer() {
        return createChainableApi_1.createChainableApi.call(this, "Buffer", Buffer_1.Buffer, () => this.request(`${this.prefix}get_buf`, [this]));
      }
      /** Get the Tabpage that contains the window */
      get tabpage() {
        return createChainableApi_1.createChainableApi.call(this, "Tabpage", Tabpage_1.Tabpage, () => this.request(`${this.prefix}get_tabpage`, [this]));
      }
      /** Get cursor position */
      get cursor() {
        return this.request(`${this.prefix}get_cursor`, [this]);
      }
      /** Set cursor position */
      set cursor(pos) {
        this.request(`${this.prefix}set_cursor`, [this, pos]);
      }
      /** Get window height by number of rows */
      get height() {
        return this.request(`${this.prefix}get_height`, [this]);
      }
      /** Set window height by number of rows */
      set height(height) {
        this.request(`${this.prefix}set_height`, [this, height]);
      }
      /** Get window width by number of columns */
      get width() {
        return this.request(`${this.prefix}get_width`, [this]);
      }
      /** Set window width by number of columns  */
      set width(width) {
        this.request(`${this.prefix}set_width`, [this, width]);
      }
      /** Get window position */
      get position() {
        return this.request(`${this.prefix}get_position`, [this]);
      }
      /** 0-indexed, on-screen window position(row) in display cells. */
      get row() {
        return this.request(`${this.prefix}get_position`, [this]).then((position) => position[0]);
      }
      /** 0-indexed, on-screen window position(col) in display cells. */
      get col() {
        return this.request(`${this.prefix}get_position`, [this]).then((position) => position[1]);
      }
      /** Is window valid */
      get valid() {
        return this.request(`${this.prefix}is_valid`, [this]);
      }
      /** Get window number */
      get number() {
        return this.request(`${this.prefix}get_number`, [this]);
      }
      /**
       * Closes window
       *
       * @param {Boolean} force Force close window
       */
      close(force = false) {
        return this.request(`${this.prefix}close`, [this, force]);
      }
      /**
       * Configure window position. Currently this is only used to
       * configure floating and external windows (including changing a
       * split window to these types).
       *
       * See documentation at |nvim_open_win()|, for the meaning of
       * parameters. Pass in -1 for 'witdh' and 'height' to keep
       * exiting size.
       *
       * When reconfiguring a floating window, absent option keys will
       * not be changed. The following restriction apply: `row`, `col`
       * and `relative` must be reconfigured together. Only changing a
       * subset of these is an error.
       *
       * @param {Window}  window Window handle
       * @Param {Object}  options Options object
       */
      config(options = {}) {
        return this.request(`${this.prefix}set_config`, [this, options]);
      }
    };
    exports.Window = Window;
  }
});

// node_modules/neovim/lib/api/types.js
var require_types = __commonJS({
  "node_modules/neovim/lib/api/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Metadata = exports.ExtType = void 0;
    var Buffer_1 = require_Buffer();
    var Window_1 = require_Window();
    var Tabpage_1 = require_Tabpage();
    var ExtType;
    (function(ExtType2) {
      ExtType2[ExtType2["Buffer"] = 0] = "Buffer";
      ExtType2[ExtType2["Window"] = 1] = "Window";
      ExtType2[ExtType2["Tabpage"] = 2] = "Tabpage";
    })(ExtType || (exports.ExtType = ExtType = {}));
    exports.Metadata = [
      {
        constructor: Buffer_1.Buffer,
        name: "Buffer",
        prefix: "nvim_buf_"
      },
      {
        constructor: Window_1.Window,
        name: "Window",
        prefix: "nvim_win_"
      },
      {
        constructor: Tabpage_1.Tabpage,
        name: "Tabpage",
        prefix: "nvim_tabpage_"
      }
    ];
  }
});

// node_modules/neovim/lib/utils/transport.js
var require_transport = __commonJS({
  "node_modules/neovim/lib/utils/transport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transport = void 0;
    var node_events_1 = require("events");
    var msgpack_1 = require_dist();
    var types_1 = require_types();
    var Response = class {
      constructor(encoder, requestId) {
        this.encoder = encoder;
        this.requestId = requestId;
      }
      send(resp, isError) {
        if (this.sent) {
          throw new Error(`Response to id ${this.requestId} already sent`);
        }
        const encoded = (0, msgpack_1.encode)([
          1,
          this.requestId,
          isError ? resp : null,
          !isError ? resp : null
        ]);
        this.encoder.write(Buffer.from(encoded.buffer, encoded.byteOffset, encoded.byteLength));
        this.sent = true;
      }
    };
    var Transport = class extends node_events_1.EventEmitter {
      constructor() {
        super(...arguments);
        this.pending = /* @__PURE__ */ new Map();
        this.nextRequestId = 1;
        this.extensionCodec = this.initializeExtensionCodec();
      }
      initializeExtensionCodec() {
        const codec = new msgpack_1.ExtensionCodec();
        types_1.Metadata.forEach(({ constructor }, id) => {
          codec.register({
            type: id,
            encode: (input) => {
              if (input instanceof constructor) {
                return (0, msgpack_1.encode)(input.data);
              }
              return null;
            },
            decode: (data) => new constructor({
              transport: this,
              client: this.client,
              data: (0, msgpack_1.decode)(data)
            })
          });
        });
        return codec;
      }
      encodeToBuffer(value) {
        const encoded = (0, msgpack_1.encode)(value, { extensionCodec: this.extensionCodec });
        return Buffer.from(encoded.buffer, encoded.byteOffset, encoded.byteLength);
      }
      attach(writer, reader, client) {
        this.writer = writer;
        this.reader = reader;
        this.client = client;
        this.reader.on("end", () => {
          this.emit("detach");
        });
        const asyncDecodeGenerator = (0, msgpack_1.decodeMultiStream)(this.reader, {
          extensionCodec: this.extensionCodec
        });
        const resolveGeneratorRecursively = (iter) => {
          iter.next().then((resolved) => {
            if (!resolved.done) {
              this.parseMessage(resolved.value);
              return resolveGeneratorRecursively(iter);
            }
            return Promise.resolve();
          });
        };
        resolveGeneratorRecursively(asyncDecodeGenerator);
      }
      request(method, args, cb) {
        this.nextRequestId = this.nextRequestId + 1;
        this.writer.write(this.encodeToBuffer([0, this.nextRequestId, method, args]));
        this.pending.set(this.nextRequestId, cb);
      }
      notify(method, args) {
        this.writer.write(this.encodeToBuffer([2, method, args]));
      }
      parseMessage(msg) {
        const msgType = msg[0];
        if (msgType === 0) {
          this.emit("request", msg[2].toString(), msg[3], new Response(this.writer, msg[1]));
        } else if (msgType === 1) {
          const id = msg[1];
          const handler = this.pending.get(id);
          this.pending.delete(id);
          handler(msg[2], msg[3]);
        } else if (msgType === 2) {
          this.emit("notification", msg[1].toString(), msg[2]);
        } else {
          this.writer.write(this.encodeToBuffer([1, 0, "Invalid message type", null]));
        }
      }
    };
    exports.Transport = Transport;
  }
});

// node_modules/neovim/lib/api/Neovim.js
var require_Neovim = __commonJS({
  "node_modules/neovim/lib/api/Neovim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Neovim = void 0;
    var Base_1 = require_Base();
    var createChainableApi_1 = require_createChainableApi();
    var Buffer_1 = require_Buffer();
    var Tabpage_1 = require_Tabpage();
    var Window_1 = require_Window();
    var Neovim = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_";
        this.Buffer = Buffer_1.Buffer;
        this.Window = Window_1.Window;
        this.Tabpage = Tabpage_1.Tabpage;
      }
      /**
       * Retrieves nvim API information
       */
      get apiInfo() {
        return this.request(`${this.prefix}get_api_info`);
      }
      /**
       * Gets the current list of buffer handles
       *
       * Includes unlisted (unloaded/deleted) buffers, like `ls!`. Use `buffer.loaded`
       * to check if a buffer is loaded
       *
       * @return {Buffer[]} List of buffer handles
       */
      get buffers() {
        return this.request(`${this.prefix}list_bufs`);
      }
      /**
       * Gets the current buffer
       *
       * @return {Buffer} Buffer handle
       */
      get buffer() {
        return createChainableApi_1.createChainableApi.call(this, "Buffer", Buffer_1.Buffer, () => this.request(`${this.prefix}get_current_buf`));
      }
      /**
       * Sets the current buffer
       */
      set buffer(buffer) {
        this.request(`${this.prefix}set_current_buf`, [buffer]);
      }
      /**
       * Get information about all open channels
       *
       * @return {Channel[]} Array of channels
       */
      get chans() {
        return this.request(`${this.prefix}list_chans`);
      }
      /**
       * Gets information about a channel
       *
       * @param {Number} chan The channel number
       * @return {Channel} A channel
       */
      getChanInfo(chan) {
        return this.request(`${this.prefix}get_chan_info`, [chan]);
      }
      /**
       * Gets a map of buffer-local |user-commands|.
       */
      get commands() {
        return this.getCommands();
      }
      /**
       * Gets a map of buffer-local |user-commands|.
       *
       * @param {Object} options Optional parameters (currently not used)
       * @return {Object} Map of maps describing commands
       */
      getCommands(options = {}) {
        return this.request(`${this.prefix}get_commands`, [options]);
      }
      /**
       * Gets the current list of tabpage handles
       *
       * @return {Tabpage[]} List of tagpage handles
       */
      get tabpages() {
        return this.request(`${this.prefix}list_tabpages`);
      }
      /**
       * Gets the window tabpage
       *
       * @return {Tabpage} Tagpage that contains the window
       */
      get tabpage() {
        return createChainableApi_1.createChainableApi.call(this, "Tabpage", Tabpage_1.Tabpage, () => this.request(`${this.prefix}get_current_tabpage`));
      }
      /**
       * Sets the current tabpage
       */
      set tabpage(tabpage) {
        this.request(`${this.prefix}set_current_tabpage`, [tabpage]);
      }
      /**
       * Gets the current list of window handles
       *
       * @return {Window[]} List of window handles
       */
      get windows() {
        return this.getWindows();
      }
      /**
       * Gets the current window
       *
       * @return {Window} Window handle
       */
      get window() {
        return this.getWindow();
      }
      /**
       * Sets the current window
       *
       * @param {Window} Window handle
       */
      set window(win) {
        if (win instanceof Window_1.Window)
          this.setWindow(win);
        else
          win.then((win2) => this.setWindow(win2));
      }
      /**
       * Gets the current list of window handles
       *
       * @return {Window[]} List of window handles
       */
      getWindows() {
        return this.request(`${this.prefix}list_wins`);
      }
      /**
       * Gets the current window
       *
       * @return {Window} Window handle
       */
      getWindow() {
        return createChainableApi_1.createChainableApi.call(this, "Window", Window_1.Window, () => this.request(`${this.prefix}get_current_win`));
      }
      /**
       * Sets the current window
       *
       * @param {Window} Window handle
       */
      setWindow(win) {
        return this.request(`${this.prefix}set_current_win`, [win]);
      }
      /**
       * Gets the paths contained in "runtimepath"
       *
       * @return {String[]} List of paths
       */
      get runtimePaths() {
        return this.request(`${this.prefix}list_runtime_paths`);
      }
      /**
       * Changes the global working directory
       *
       * @param {String} Directory path
       *
       */
      set dir(dir) {
        this.request(`${this.prefix}set_current_dir`, [dir]);
      }
      /**
       * Gets the current line
       *
       * @return {String} Current line string
       */
      get line() {
        return this.getLine();
      }
      /**
       * Sets current line
       *
       * @param {String} line Line contents
       */
      set line(line) {
        if (typeof line === "string") {
          this.setLine(line);
        }
      }
      /**
       * Gets the current line
       *
       * @return {String} Current line string
       */
      getLine() {
        return this.request(`${this.prefix}get_current_line`);
      }
      /**
       * Sets current line
       *
       * @param {String} line Line contents
       */
      setLine(line) {
        return this.request(`${this.prefix}set_current_line`, [line]);
      }
      /**
       * Gets a list of global (non-buffer-local) |mapping| definitions.
       *
       * @param {String} mode Mode short-name ("n", "i", "v", ...)
       * @return {Object[]}  Array of maparg()-like dictionaries describing mappings. The "buffer" key is always zero.
       */
      getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [mode]);
      }
      /**
       * Gets the current mode. |mode()| "blocking" is true if Nvim is waiting for input.
       *
       * @return {Object} Dictionary { "mode": String, "blocking": Boolean }
       */
      get mode() {
        return this.request(`${this.prefix}get_mode`);
      }
      /**
       * Gets map of defined colors
       *
       * @return {Object} Color map
       */
      get colorMap() {
        return this.request(`${this.prefix}get_color_map`);
      }
      /**
       * Get color by name
       *
       * @param {String} name Color name
       * @return {Number} Color value
       */
      getColorByName(name) {
        return this.request(`${this.prefix}get_color_by_name`, [name]);
      }
      /**
       * Get highlight by name or id
       *
       * @param {String|Number} nameOrId Name or ID
       * @param {Boolean} isRgb Should export RGB colors
       * @return {Object} Highlight definition map
       */
      getHighlight(nameOrId, isRgb = true) {
        const functionName = typeof nameOrId === "string" ? "by_name" : "by_id";
        return this.request(`${this.prefix}get_hl_${functionName}`, [
          nameOrId,
          isRgb
        ]);
      }
      /**
       * Get highlight definition by name
       *
       * @param {String} name Highlight group name
       * @param {Boolean} isRgb Should export RGB colors
       * @return {Object} Highlight definition map
       */
      getHighlightByName(name, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_name`, [name, isRgb]);
      }
      /**
       * Get highlight definition by id |hlID()|
       *
       * @param {Number} id Highlight id as returned by |hlID()|
       * @param {Boolean} isRgb Should export RGB colors
       * @return {Object} Highlight definition map
       */
      getHighlightById(id, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_id`, [id, isRgb]);
      }
      /**
       * Deletes the current line
       */
      deleteCurrentLine() {
        return this.request(`${this.prefix}del_current_line`);
      }
      /**
       * Evaluates a VimL expression (:help expression). Dictionaries
       * and Lists are recursively expanded. On VimL error: Returns a
       * generic error; v:errmsg is not updated.
       *
       */
      eval(expr) {
        return this.request(`${this.prefix}eval`, [expr]);
      }
      /**
       * Executes lua, it's possible neovim client does not support this
       */
      lua(code, args = []) {
        const _args = Array.isArray(args) ? args : [args];
        return this.request(`${this.prefix}execute_lua`, [code, _args]);
      }
      /**
       * Alias for `lua()` to be consistent with neovim API
       */
      executeLua(code, args = []) {
        return this.lua(code, args);
      }
      /**
       * Calls a VimL |Dictionary-function| with the given arguments.
       *
       * On execution error: fails with VimL error, does not update v:errmsg.
       */
      callDictFunction(dict, fname, args = []) {
        const _args = Array.isArray(args) ? args : [args];
        return this.request(`${this.prefix}call_dict_function`, [
          dict,
          fname,
          _args
        ]);
      }
      /**
       * Calls a VimL function with the given arguments.
       *
       * On execution error: fails with VimL error, does not update v:errmsg.
       */
      call(fname, args = []) {
        const _args = Array.isArray(args) ? args : [args];
        return this.request(`${this.prefix}call_function`, [fname, _args]);
      }
      /**
       * Alias for `call`
       */
      callFunction(fname, args = []) {
        return this.call(fname, args);
      }
      /**
       * Calls many API methods atomically.
       *
       * This has two main usages:
       *  - To perform several requests from an async context atomically, i.e. without
       * interleaving redraws, RPC requests from other clients, or user interactions
       * (however API methods may trigger autocommands or event processing which have
       * such side-effects, e.g. |:sleep| may wake timers)
       *
       *  - To minimize RPC overhead (roundtrips) of a sequence of many requests.
       */
      callAtomic(calls) {
        return this.request(`${this.prefix}call_atomic`, [calls]);
      }
      /**
       * Executes an ex-command.
       *
       * On execution error: fails with VimL error, does not update v:errmsg.
       *
       * @param {String} arg Ex-command string
       */
      command(arg) {
        return this.request(`${this.prefix}command`, [arg]);
      }
      /**
       * Executes an ex-command and returns its (non-error) output.
       * Shell |:!| output is not captured.
       *
       * On execution error: fails with VimL error, does not update v:errmsg.
       */
      commandOutput(arg) {
        return this.request(`${this.prefix}command_output`, [arg]);
      }
      /**
       * Gets a v: variable
       *
       * @param {String} name Variable name
       * @return {VimValue} Variable value
       */
      getVvar(name) {
        return this.request(`${this.prefix}get_vvar`, [name]);
      }
      /**
       * Sets a v: variable, if it is not readonly.
       *
       * @param {String} name Variable name
       * @param {VimValue} value Variable value
       */
      setVvar(name, value) {
        return this.request(`${this.prefix}set_vvar`, [name, value]);
      }
      /**
       * Sends input-keys to Nvim, subject to various quirks controlled
       * by `mode` flags. This is a blocking call, unlike |nvim_input()|.
       *
       * On execution error: does not fail, but updates v:errmsg.
       *
       * @param {String} keys To be typed
       * @param {String} mode Behavior flags, see |feedkeys()|
       * @param {Boolean} escapeCsi If true, escape K_SPECIAL/CSI bytes in `keys`
       */
      feedKeys(keys, mode, escapeCsi) {
        return this.request(`${this.prefix}feedkeys`, [keys, mode, escapeCsi]);
      }
      /**
       * Queues raw user-input. Unlike |nvim_feedkeys()|, this uses a
       * low-level input buffer and the call is non-blocking (input is
       * processed asynchronously by the eventloop).
       *
       * On execution error: does not fail, but updates v:errmsg.
       *
       * Note:
       * |keycodes| like <CR> are translated, so "<" is special. To
       * input a literal "<", send <LT>.
       *
       * Note:
       * For mouse events use |nvim_input_mouse()|. The pseudokey
       * form "<LeftMouse><col,row>" is deprecated since
       * |api-level| 6.
       *
       * @param {String} keys To be typed
       */
      input(keys) {
        return this.request(`${this.prefix}input`, [keys]);
      }
      /**
       * Send mouse event from GUI.
       *
       * The call is non-blocking. It doesn't wait on any resulting
       * action, but queues the event to be processed soon by the event
       * loop.
       *
       * Note:
       * Currently this doesn't support "scripting" multiple mouse
       * events by calling it multiple times in a loop: the
       * intermediate mouse positions will be ignored. It should be
       * used to implement real-time mouse input in a GUI. The
       * deprecated pseudokey form ("<LeftMouse><col,row>") of
       * |nvim_input()| has the same limitiation.
       *
       * @param {String} button    Mouse button: one of "left", "right", "middle", "wheel".
       * @param {String} action    For ordinary buttons, one of "press", "drag", "release".
       *                           For the wheel, one of "up", "down", "left", "right".
       * @param {String} modifier  String of modifiers each represented by a
       *                           single char. The same specifiers are used as
       *                           for a key press, except that the "-" separator
       *                           is optional, so "C-A-", "c-a" and "CA" can all
       *                           be used to specify Ctrl+Alt+click.
       * @param {Number} grid      Grid number if the client uses |ui-multigrid|, else 0.
       * @param {Number} row       Mouse row-position (zero-based, like redraw events)
       * @param {Number} col       Mouse column-position (zero-based, like redraw events)
       */
      inputMouse(button, action, modifier, grid, row, col) {
        return this.request(`${this.prefix}input_mouse`, [
          button,
          action,
          modifier,
          grid,
          row,
          col
        ]);
      }
      /**
       * Parse a VimL Expression
       *
       * TODO: return type, see :help
       */
      parseExpression(expr, flags, highlight) {
        return this.request(`${this.prefix}parse_expression`, [
          expr,
          flags,
          highlight
        ]);
      }
      /**
       * Gets info describing process `pid`.
       *
       * @param {Number} pid pid
       * @return {Proc} Map of process properties, or null if process not found
       */
      getProc(pid) {
        return this.request(`${this.prefix}get_proc`, [pid]);
      }
      /**
       * Gets the immediate children of process `pid`
       *
       * @return {Proc[]} Array of child process ids, empty if process not found
       */
      getProcChildren(pid) {
        return this.request(`${this.prefix}get_proc_children`, [pid]);
      }
      /**
       * Replaces terminal codes and |keycodes| (<CR>, <Esc>, ...) in a
       * string with the internal representation.
       *
       * @param {String} str String to be converted.
       * @param {Boolean} fromPart Legacy Vim parameter. Usually true.
       * @param {Boolean} doIt Also translate <lt>. Ignored if `special` is false.
       * @param {Boolean} special Replace |keycodes|, e.g. <CR> becomes a "\n" char.
       */
      replaceTermcodes(str, fromPart, doIt, special) {
        return this.request(`${this.prefix}replace_termcodes`, [
          str,
          fromPart,
          doIt,
          special
        ]);
      }
      /**
       * Calculates the number of display cells occupied by `text`.
       * <Tab> counts as one cell.
       *
       * @param {String} str Some text
       * @return {Number} Number of cells
       */
      strWidth(str) {
        return this.request(`${this.prefix}strwidth`, [str]);
      }
      /** Write to output buffer */
      outWrite(str) {
        return this.request(`${this.prefix}out_write`, [str]);
      }
      outWriteLine(str) {
        return this.outWrite(`${str}
`);
      }
      /** Write to error buffer */
      errWrite(str) {
        return this.request(`${this.prefix}err_write`, [str]);
      }
      /** Write to error buffer */
      errWriteLine(str) {
        return this.request(`${this.prefix}err_writeln`, [str]);
      }
      /**
       * Gets a list of dictionaries representing attached UIs.
       *
       * @return {Ui[]} Array of UI dictionaries
       * Each dictionary has the following keys:
       * "height" requested height of the UI
       * "width" requested width of the UI
       * "rgb" whether the UI uses rgb colors (false implies cterm colors)
       * "ext_..." Requested UI extensions, see |ui-options|
       * "chan" Channel id of remote UI (not present for TUI)
       */
      get uis() {
        return this.request(`${this.prefix}list_uis`);
      }
      uiAttach(width, height, options) {
        return this.request(`${this.prefix}ui_attach`, [width, height, options]);
      }
      uiDetach() {
        return this.request(`${this.prefix}ui_detach`, []);
      }
      /**
       * TODO: Documentation
       *
       * @param {Number} width The new requested width
       * @param {Number} height The new requested height
       */
      uiTryResize(width, height) {
        return this.request(`${this.prefix}ui_try_resize`, [width, height]);
      }
      /**
       * Tell Nvim to resize a grid. Triggers a grid_resize event with
       * the requested grid size or the maximum size if it exceeds size
       * limits.
       *
       * On invalid grid handle, fails with error.
       *
       * @param {Number} grid The handle of the grid to be changed
       * @param {Number} width The new requested width
       * @param {Number} height The new requested height
       */
      uiTryResizeGrid(grid, width, height) {
        return this.request(`${this.prefix}ui_try_resize_grid`, [
          grid,
          width,
          height
        ]);
      }
      /**
       * Set UI Option
       */
      uiSetOption(name, value) {
        return this.request(`${this.prefix}ui_set_option`, [name, value]);
      }
      /**
       * Subscribe to nvim event broadcasts
       *
       * @param {String} event Event type string
       */
      subscribe(event) {
        return this.request(`${this.prefix}subscribe`, [event]);
      }
      /**
       * Unsubscribe to nvim event broadcasts
       *
       * @param {String} event Event type string
       */
      unsubscribe(event) {
        return this.request(`${this.prefix}unsubscribe`, [event]);
      }
      /**
       * Identify the client for nvim. Can be called more than once,
       * but subsequent calls will remove earlier info, which should be
       * resent if it is still valid. (This could happen if a library
       * first identifies the channel, and a plugin using that library
       * later overrides that info)
       *
       */
      setClientInfo(name, version, type, methods, attributes) {
        this.request(`${this.prefix}set_client_info`, [
          name,
          version,
          type,
          methods,
          attributes
        ]);
      }
      /**
       * Creates a new namespace, or gets an existing one.
       *
       * Namespaces are used for buffer highlights and virtual text,
       * see |nvim_buf_add_highlight()| and |nvim_buf_set_virtual_text()|.
       *
       * Namespaces can be named or anonymous. If `name` matches an
       * existing namespace, the associated id is returned. If `name`
       * is an empty string a new, anonymous namespace is created.
       *
       * @param {String} name Namespace name or empty string
       * @return {Number} Namespace id
       */
      createNamespace(name = "") {
        return this.request(`${this.prefix}create_namespace`, [name]);
      }
      /**
       * Alias for `getNamespaces()`
       */
      get namespaces() {
        return this.getNamespaces();
      }
      /**
       * Gets existing, non-anonymous namespaces.
       *
       * @return {Object} dict that maps from names to namespace ids.
       */
      getNamespaces() {
        return this.request(`${this.prefix}get_namespaces`);
      }
      /**
       * Selects an item in the completion popupmenu.
       *
       * If |ins-completion| is not active this API call is silently
       * ignored. Useful for an external UI using |ui-popupmenu| to
       * control the popupmenu with the mouse. Can also be used in a
       * mapping; use <cmd> |:map-cmd| to ensure the mapping doesn't
       * end completion mode.
       *
       * @param {Number}  item     Index (zero-based) of the item to select.
       *                           Value of -1 selects nothing and restores the original text.
       * @param {Boolean} insert   Whether the selection should be inserted in the buffer.
       * @param {Boolean} finish   Finish the completion and dismiss the popupmenu.
       *                           Implies `insert`.
       * @param {Object}  opts     Optional parameters. Reserved for future use.
       */
      selectPopupmenuItem(item, insert, finish, opts = {}) {
        return this.request(`${this.prefix}select_popupmenu_item`, [
          item,
          insert,
          finish,
          opts
        ]);
      }
      /**
       * Creates a new, empty, unnamed buffer.
       *
       * @param {Boolean} listed  Controls 'buflisted'
       * @param {Boolean} scratch Creates a "throwaway" |scratch-buffer| for temporary work (always 'nomodified')
       * @return {Buffer|Number} Buffer handle, or 0 on error
       */
      createBuf(listed, scratch) {
        return this.request(`${this.prefix}create_buf`, [listed, scratch]);
      }
      /**
       * Public alias for `createBuf`
       */
      createBuffer(listed, scratch) {
        return this.createBuf(listed, scratch);
      }
      /**
       * Open a new window.
       * Currently this is used to open floating and external windows.
       * Floats are windows that are drawn above the split layout, at
       * some anchor position in some other window. Floats can be draw
       * internally or by external GUI with the |ui-multigrid|
       * extension. External windows are only supported with multigrid
       * GUIs, and are displayed as separate top-level windows.
       *
       * Exactly one of `external` and `relative` must be specified.
       *
       * @param {Buffer}  buffer Handle of buffer to be displayed in the window
       * @param {Boolean} enter  Whether the window should be entered (made the current window)
       * @Param {Object}  options Options object
       * @return {Window|Number} The Window handle or 0 when error
       */
      openWin(buffer, enter, options) {
        return this.request(`${this.prefix}open_win`, [buffer, enter, options]);
      }
      /**
       * Public alias for `openWin`
       */
      openWindow(buffer, enter, options) {
        return this.openWin(buffer, enter, options);
      }
      /**
       * Configure window position. Currently this is only used to
       * configure floating and external windows (including changing a
       * split window to these types).
       *
       * See documentation at |nvim_open_win()|, for the meaning of
       * parameters. Pass in -1 for 'witdh' and 'height' to keep
       * exiting size.
       *
       * When reconfiguring a floating window, absent option keys will
       * not be changed. The following restriction apply: `row`, `col`
       * and `relative` must be reconfigured together. Only changing a
       * subset of these is an error.
       *
       * @param {Window}  window Window handle
       * @param {Number}  width  Width of window (in character cells)
       * @param {Number}  height Height of window (in character cells)
       * @Param {Object}  options Options object
       */
      winConfig(window2, options = {}) {
        return window2.config(options);
      }
      /**
       * Public Alias for `winConfig`
       */
      windowConfig(window2, options = {}) {
        return this.winConfig(window2, options);
      }
      /**
       * Closes window
       *
       * @param {Boolean} force Force close window
       */
      winClose(window2, force) {
        return window2.close(force);
      }
      /**
       * Public alias for `winClose`
       */
      windowClose(window2, force) {
        return this.winClose(window2, force);
      }
      /**
       * Quit nvim
       */
      quit() {
        this.command("qa!");
      }
    };
    exports.Neovim = Neovim;
  }
});

// node_modules/neovim/lib/api/client.js
var require_client = __commonJS({
  "node_modules/neovim/lib/api/client.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NeovimClient = void 0;
    var transport_1 = require_transport();
    var Neovim_1 = require_Neovim();
    var REGEX_BUF_EVENT = /nvim_buf_(.*)_event/;
    var NeovimClient = class extends Neovim_1.Neovim {
      constructor(options = {}) {
        super({
          logger: options.logger
        });
        this.attachedBuffers = /* @__PURE__ */ new Map();
        const transport = options.transport || new transport_1.Transport();
        this.setTransport(transport);
        this.requestQueue = [];
        this.transportAttached = false;
        this.handleRequest = this.handleRequest.bind(this);
        this.handleNotification = this.handleNotification.bind(this);
      }
      /** Attaches msgpack to read/write streams * */
      attach({ reader, writer }) {
        this.transport.attach(writer, reader, this);
        this.transportAttached = true;
        this.setupTransport();
      }
      get isApiReady() {
        return this.transportAttached && typeof this._channelId !== "undefined";
      }
      get channelId() {
        return (() => __awaiter(this, void 0, void 0, function* () {
          yield this._isReady;
          return this._channelId;
        }))();
      }
      isAttached(buffer) {
        const key = `${buffer.data}`;
        return this.attachedBuffers.has(key);
      }
      handleRequest(method, args, resp, ...restArgs) {
        this.logger.info("handleRequest: ", method);
        if (!this.isApiReady && method !== "specs") {
          this.requestQueue.push({
            type: "request",
            args: [method, args, resp, ...restArgs]
          });
        } else {
          this.emit("request", method, args, resp);
        }
      }
      emitNotification(method, args) {
        if (method.endsWith("_event")) {
          if (!method.startsWith("nvim_buf_")) {
            this.logger.error("Unhandled event: ", method);
            return;
          }
          const shortName = method.replace(REGEX_BUF_EVENT, "$1");
          const [buffer] = args;
          const bufferKey = `${buffer.data}`;
          if (!this.attachedBuffers.has(bufferKey)) {
            return;
          }
          const bufferMap = this.attachedBuffers.get(bufferKey);
          const cbs = bufferMap.get(shortName) || [];
          cbs.forEach((cb) => cb(...args));
          if (shortName === "detach") {
            this.attachedBuffers.delete(bufferKey);
          }
        } else {
          this.emit("notification", method, args);
        }
      }
      handleNotification(method, args, ...restArgs) {
        this.logger.info("handleNotification: ", method);
        if (!this.isApiReady) {
          this.requestQueue.push({
            type: "notification",
            args: [method, args, ...restArgs]
          });
        } else {
          this.emitNotification(method, args);
        }
      }
      // Listen and setup handlers for transport
      setupTransport() {
        if (!this.transportAttached) {
          throw new Error("Not attached to input/output");
        }
        this.transport.on("request", this.handleRequest);
        this.transport.on("notification", this.handleNotification);
        this.transport.on("detach", () => {
          this.emit("disconnect");
          this.transport.removeAllListeners("request");
          this.transport.removeAllListeners("notification");
          this.transport.removeAllListeners("detach");
        });
        this._isReady = this.generateApi();
      }
      requestApi() {
        return new Promise((resolve, reject) => {
          this.transport.request("nvim_get_api_info", [], (err, res) => {
            if (err) {
              reject(err);
            } else {
              resolve(res);
            }
          });
        });
      }
      // Request API from neovim and augment this current class to add these APIs
      generateApi() {
        return __awaiter(this, void 0, void 0, function* () {
          let results;
          try {
            results = yield this.requestApi();
          } catch (err) {
            this.logger.error("Could not get vim api results");
            this.logger.error(err);
          }
          if (results) {
            try {
              const [
                channelId
                /* , encodedMetadata */
              ] = results;
              this._channelId = channelId;
              this.requestQueue.forEach((pending) => {
                if (pending.type === "notification") {
                  this.emitNotification(pending.args[0], pending.args[1]);
                } else {
                  this.emit(pending.type, ...pending.args);
                }
              });
              this.requestQueue = [];
              return true;
            } catch (err) {
              this.logger.error(`Could not dynamically generate neovim API: ${err}`, {
                error: err
              });
              this.logger.error(err.stack);
              return null;
            }
          }
          return null;
        });
      }
      attachBuffer(buffer, eventName, cb) {
        const bufferKey = `${buffer.data}`;
        if (!this.attachedBuffers.has(bufferKey)) {
          this.attachedBuffers.set(bufferKey, /* @__PURE__ */ new Map());
        }
        const bufferMap = this.attachedBuffers.get(bufferKey);
        if (!bufferMap.get(eventName)) {
          bufferMap.set(eventName, []);
        }
        const cbs = bufferMap.get(eventName);
        if (cbs.includes(cb))
          return cb;
        cbs.push(cb);
        bufferMap.set(eventName, cbs);
        this.attachedBuffers.set(bufferKey, bufferMap);
        return cb;
      }
      /**
       * Returns `true` if buffer should be detached
       */
      detachBuffer(buffer, eventName, cb) {
        const bufferKey = `${buffer.data}`;
        const bufferMap = this.attachedBuffers.get(bufferKey);
        if (!bufferMap)
          return false;
        const handlers = (bufferMap.get(eventName) || []).filter((handler) => handler !== cb);
        if (!handlers.length) {
          bufferMap.delete(eventName);
        } else {
          bufferMap.set(eventName, handlers);
        }
        if (!bufferMap.size) {
          this.attachedBuffers.delete(bufferKey);
          return true;
        }
        return false;
      }
    };
    exports.NeovimClient = NeovimClient;
  }
});

// node_modules/neovim/lib/attach/attach.js
var require_attach = __commonJS({
  "node_modules/neovim/lib/attach/attach.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attach = void 0;
    var node_net_1 = require("net");
    var client_1 = require_client();
    var logger_1 = require_logger2();
    function attach({ reader: _reader, writer: _writer, proc, socket, options = {} }) {
      let writer;
      let reader;
      if (socket) {
        const client = (0, node_net_1.createConnection)(socket);
        writer = client;
        reader = client;
      } else if (_reader && _writer) {
        writer = _writer;
        reader = _reader;
      } else if (proc) {
        writer = proc.stdin;
        reader = proc.stdout;
      }
      if (writer && reader) {
        const loggerInstance = options.logger || (0, logger_1.getLogger)();
        const neovim = new client_1.NeovimClient({ logger: loggerInstance });
        neovim.attach({
          writer,
          reader
        });
        return neovim;
      }
      throw new Error("Invalid arguments, could not attach");
    }
    exports.attach = attach;
  }
});

// node_modules/neovim/lib/attach.js
var require_attach2 = __commonJS({
  "node_modules/neovim/lib/attach.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attach = void 0;
    var attach_1 = require_attach();
    Object.defineProperty(exports, "attach", { enumerable: true, get: function() {
      return attach_1.attach;
    } });
  }
});

// node_modules/neovim/lib/api/index.js
var require_api = __commonJS({
  "node_modules/neovim/lib/api/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tabpage = exports.Window = exports.Buffer = exports.NeovimClient = exports.Neovim = void 0;
    var Neovim_1 = require_Neovim();
    Object.defineProperty(exports, "Neovim", { enumerable: true, get: function() {
      return Neovim_1.Neovim;
    } });
    var client_1 = require_client();
    Object.defineProperty(exports, "NeovimClient", { enumerable: true, get: function() {
      return client_1.NeovimClient;
    } });
    var Buffer_1 = require_Buffer();
    Object.defineProperty(exports, "Buffer", { enumerable: true, get: function() {
      return Buffer_1.Buffer;
    } });
    var Window_1 = require_Window();
    Object.defineProperty(exports, "Window", { enumerable: true, get: function() {
      return Window_1.Window;
    } });
    var Tabpage_1 = require_Tabpage();
    Object.defineProperty(exports, "Tabpage", { enumerable: true, get: function() {
      return Tabpage_1.Tabpage;
    } });
  }
});

// node_modules/neovim/lib/plugin/properties.js
var require_properties = __commonJS({
  "node_modules/neovim/lib/plugin/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NVIM_METHOD_NAME = exports.NVIM_SYNC = exports.NVIM_SPEC = exports.NVIM_DEV_MODE = exports.NVIM_PLUGIN = void 0;
    exports.NVIM_PLUGIN = "_nvim_plugin";
    exports.NVIM_DEV_MODE = "_nvim_dev_mode";
    exports.NVIM_SPEC = "_nvim_rpc_spec";
    exports.NVIM_SYNC = "_nvim_rpc_sync";
    exports.NVIM_METHOD_NAME = "_nvim_rpc_method_name";
  }
});

// node_modules/neovim/lib/host/NvimPlugin.js
var require_NvimPlugin = __commonJS({
  "node_modules/neovim/lib/host/NvimPlugin.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NvimPlugin = exports.callable = void 0;
    function callable(fn) {
      if (typeof fn === "function") {
        return fn;
      }
      if (Array.isArray(fn) && fn.length === 2) {
        return function(...args) {
          return fn[1].apply(fn[0], args);
        };
      }
      throw new Error();
    }
    exports.callable = callable;
    var NvimPlugin = class {
      constructor(filename, plugin, nvim) {
        this.filename = filename;
        this.nvim = nvim;
        this.dev = false;
        this.alwaysInit = false;
        this.autocmds = {};
        this.commands = {};
        this.functions = {};
        try {
          this.instance = new plugin(this);
        } catch (err) {
          if (err instanceof TypeError) {
            this.instance = plugin(this);
          } else {
            throw err;
          }
        }
      }
      setOptions(options) {
        this.dev = options.dev === void 0 ? this.dev : options.dev;
        this.alwaysInit = options.alwaysInit;
      }
      // Cache module (in dev mode will clear the require module cache)
      get shouldCacheModule() {
        return !this.dev;
      }
      registerAutocmd(name, fn, options) {
        if (!options.pattern) {
          this.nvim.logger.error(`registerAutocmd expected pattern option for ${name}`);
          return;
        }
        const spec = {
          type: "autocmd",
          name,
          sync: options && !!options.sync,
          opts: {}
        };
        ["pattern", "eval"].forEach((option) => {
          if (options && typeof options[option] !== "undefined") {
            spec.opts[option] = options[option];
          }
        });
        try {
          this.autocmds[`${name} ${options.pattern}`] = {
            fn: callable(fn),
            spec
          };
        } catch (err) {
          this.nvim.logger.error(`registerAutocmd expected callable argument for ${name}`);
        }
      }
      registerCommand(name, fn, options) {
        const spec = {
          type: "command",
          name,
          sync: options && !!options.sync,
          opts: {}
        };
        ["range", "nargs", "complete"].forEach((option) => {
          if (options && typeof options[option] !== "undefined") {
            spec.opts[option] = options[option];
          }
        });
        try {
          this.commands[name] = {
            fn: callable(fn),
            spec
          };
        } catch (err) {
          this.nvim.logger.error(`registerCommand expected callable argument for ${name}`);
        }
      }
      registerFunction(name, fn, options) {
        const spec = {
          type: "function",
          name,
          sync: options && !!options.sync,
          opts: {}
        };
        ["range", "eval"].forEach((option) => {
          if (options && typeof options[option] !== "undefined") {
            spec.opts[option] = options[option];
          }
        });
        try {
          this.functions[name] = {
            fn: callable(fn),
            spec
          };
        } catch (err) {
          this.nvim.logger.error(`registerFunction expected callable argument for ${name}`);
        }
      }
      get specs() {
        const autocmds = Object.keys(this.autocmds).map((key) => this.autocmds[key].spec);
        const commands = Object.keys(this.commands).map((key) => this.commands[key].spec);
        const functions = Object.keys(this.functions).map((key) => this.functions[key].spec);
        return autocmds.concat(commands).concat(functions);
      }
      handleRequest(name, type, args) {
        return __awaiter(this, void 0, void 0, function* () {
          let handlers;
          switch (type) {
            case "autocmd":
              handlers = this.autocmds;
              break;
            case "command":
              handlers = this.commands;
              break;
            case "function":
              handlers = this.functions;
              break;
            default:
              const errMsg = `No handler for unknown type ${type}: "${name}" in ${this.filename}`;
              this.nvim.logger.error(errMsg);
              throw new Error(errMsg);
          }
          if (handlers.hasOwnProperty(name)) {
            const handler = handlers[name];
            try {
              return handler.spec.sync ? handler.fn(...args) : yield handler.fn(...args);
            } catch (err) {
              const msg = `Error in plugin for ${type}:${name}: ${err.message}`;
              this.nvim.logger.error(`${msg} (file: ${this.filename}, stack: ${err.stack})`);
              throw new Error(err);
            }
          } else {
            const errMsg = `Missing handler for ${type}: "${name}" in ${this.filename}`;
            this.nvim.logger.error(errMsg);
            throw new Error(errMsg);
          }
        });
      }
    };
    exports.NvimPlugin = NvimPlugin;
  }
});

// node_modules/neovim/lib/plugin/plugin.js
var require_plugin = __commonJS({
  "node_modules/neovim/lib/plugin/plugin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.plugin = exports.NvimPlugin = exports.Neovim = void 0;
    var properties_1 = require_properties();
    var Neovim_1 = require_Neovim();
    Object.defineProperty(exports, "Neovim", { enumerable: true, get: function() {
      return Neovim_1.Neovim;
    } });
    var NvimPlugin_1 = require_NvimPlugin();
    Object.defineProperty(exports, "NvimPlugin", { enumerable: true, get: function() {
      return NvimPlugin_1.NvimPlugin;
    } });
    function wrapper(cls, options) {
      return class extends cls {
        constructor(...args) {
          const plugin2 = args[0];
          super(plugin2.nvim, plugin2);
          this.setApi(plugin2.nvim);
          if (options) {
            plugin2.setOptions(options);
          }
          plugin2.nvim.logger.info(`Decorating class ${cls}`);
          Object.getOwnPropertyNames(cls.prototype).forEach((methodName) => {
            plugin2.nvim.logger.info(`Method name ${methodName}`);
            plugin2.nvim.logger.info(`${cls.prototype[methodName]} ${typeof cls.prototype[methodName]}`);
            plugin2.nvim.logger.info(`${this} ${typeof this}`);
            const method = cls.prototype[methodName];
            if (method && method[properties_1.NVIM_SPEC]) {
              const spec = method[properties_1.NVIM_SPEC];
              switch (spec.type) {
                case "autocmd":
                  const autoCmdOpts = {
                    pattern: spec.opts.pattern,
                    sync: spec.sync
                  };
                  if (typeof spec.opts.eval !== "undefined") {
                    autoCmdOpts.eval = spec.opts.eval;
                  }
                  plugin2.registerAutocmd(spec.name, [this, method], autoCmdOpts);
                  break;
                case "command":
                  const cmdOpts = {
                    sync: spec.sync
                  };
                  if (typeof spec.opts.range !== "undefined") {
                    cmdOpts.range = spec.opts.range;
                  }
                  if (typeof spec.opts.nargs !== "undefined") {
                    cmdOpts.nargs = spec.opts.nargs;
                  }
                  if (typeof spec.opts.complete !== "undefined") {
                    cmdOpts.complete = spec.opts.complete;
                  }
                  plugin2.registerCommand(spec.name, [this, method], cmdOpts);
                  break;
                case "function":
                  const funcOpts = {
                    sync: spec.sync
                  };
                  if (typeof spec.opts.range !== "undefined") {
                    funcOpts.range = spec.opts.range;
                  }
                  if (typeof spec.opts.eval !== "undefined") {
                    funcOpts.eval = spec.opts.eval;
                  }
                  plugin2.registerFunction(spec.name, [this, method], funcOpts);
                  break;
                default:
                  break;
              }
            }
          });
        }
        setApi(nvim) {
          this.nvim = nvim;
        }
      };
    }
    function plugin(outter) {
      return typeof outter !== "function" ? (cls) => wrapper(cls, outter) : wrapper(outter);
    }
    exports.plugin = plugin;
  }
});

// node_modules/neovim/lib/plugin/function.js
var require_function = __commonJS({
  "node_modules/neovim/lib/plugin/function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nvimFunction = void 0;
    var properties_1 = require_properties();
    function nvimFunction(name, options = {}) {
      return function(cls, methodName) {
        const sync = options && !!options.sync;
        const isMethod = typeof methodName === "string";
        const f = isMethod ? cls[methodName] : cls;
        const opts = {};
        if (options && options.range) {
          opts.range = options.range;
        }
        if (options && options.eval) {
          opts.eval = options.eval;
        }
        Object.defineProperty(f, properties_1.NVIM_METHOD_NAME, { value: `function:${name}` });
        Object.defineProperty(f, properties_1.NVIM_SYNC, { value: !!sync });
        Object.defineProperty(f, properties_1.NVIM_SPEC, {
          value: {
            type: "function",
            name,
            sync: !!sync,
            opts
          }
        });
        if (isMethod) {
          cls[methodName] = f;
        }
        return cls;
      };
    }
    exports.nvimFunction = nvimFunction;
  }
});

// node_modules/neovim/lib/plugin/autocmd.js
var require_autocmd = __commonJS({
  "node_modules/neovim/lib/plugin/autocmd.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.autocmd = void 0;
    var properties_1 = require_properties();
    function autocmd(name, options) {
      return function(cls, methodName) {
        const sync = options && !!options.sync;
        const isMethod = typeof methodName === "string";
        const f = isMethod ? cls[methodName] : cls;
        const opts = {
          pattern: ""
        };
        ["pattern", "eval"].forEach((option) => {
          if (options && typeof options[option] !== "undefined") {
            opts[option] = options[option];
          }
        });
        const nameWithPattern = `${name}${options.pattern ? `:${options.pattern}` : ""}`;
        Object.defineProperty(f, properties_1.NVIM_METHOD_NAME, {
          value: `autocmd:${nameWithPattern}`
        });
        Object.defineProperty(f, properties_1.NVIM_SYNC, { value: !!sync });
        Object.defineProperty(f, properties_1.NVIM_SPEC, {
          value: {
            type: "autocmd",
            name,
            sync: !!sync,
            opts
          }
        });
        if (isMethod) {
          cls[methodName] = f;
        }
        return cls;
      };
    }
    exports.autocmd = autocmd;
  }
});

// node_modules/neovim/lib/plugin/command.js
var require_command = __commonJS({
  "node_modules/neovim/lib/plugin/command.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.command = void 0;
    var properties_1 = require_properties();
    function command(name, options) {
      return function(cls, methodName) {
        const sync = options && !!options.sync;
        const isMethod = typeof methodName === "string";
        const f = isMethod ? cls[methodName] : cls;
        const opts = {};
        ["range", "nargs", "complete"].forEach((option) => {
          if (options && typeof options[option] !== "undefined") {
            opts[option] = options[option];
          }
        });
        Object.defineProperty(f, properties_1.NVIM_METHOD_NAME, { value: `command:${name}` });
        Object.defineProperty(f, properties_1.NVIM_SYNC, { value: !!sync });
        Object.defineProperty(f, properties_1.NVIM_SPEC, {
          value: {
            type: "command",
            name,
            sync: !!sync,
            opts
          }
        });
        if (isMethod) {
          cls[methodName] = f;
        }
        return cls;
      };
    }
    exports.command = command;
  }
});

// node_modules/neovim/lib/plugin/index.js
var require_plugin2 = __commonJS({
  "node_modules/neovim/lib/plugin/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Command = exports.Autocmd = exports.Function = exports.Plugin = void 0;
    var plugin_1 = require_plugin();
    Object.defineProperty(exports, "Plugin", { enumerable: true, get: function() {
      return plugin_1.plugin;
    } });
    var function_1 = require_function();
    Object.defineProperty(exports, "Function", { enumerable: true, get: function() {
      return function_1.nvimFunction;
    } });
    var autocmd_1 = require_autocmd();
    Object.defineProperty(exports, "Autocmd", { enumerable: true, get: function() {
      return autocmd_1.autocmd;
    } });
    var command_1 = require_command();
    Object.defineProperty(exports, "Command", { enumerable: true, get: function() {
      return command_1.command;
    } });
  }
});

// node_modules/neovim/lib/plugin.js
var require_plugin3 = __commonJS({
  "node_modules/neovim/lib/plugin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Command = exports.Autocmd = exports.Function = exports.Plugin = void 0;
    var index_1 = require_plugin2();
    Object.defineProperty(exports, "Plugin", { enumerable: true, get: function() {
      return index_1.Plugin;
    } });
    Object.defineProperty(exports, "Function", { enumerable: true, get: function() {
      return index_1.Function;
    } });
    Object.defineProperty(exports, "Autocmd", { enumerable: true, get: function() {
      return index_1.Autocmd;
    } });
    Object.defineProperty(exports, "Command", { enumerable: true, get: function() {
      return index_1.Command;
    } });
  }
});

// node_modules/neovim/lib/host/factory.js
var require_factory = __commonJS({
  "node_modules/neovim/lib/host/factory.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.loadPlugin = void 0;
    var path = __importStar(require("path"));
    var Module = require("module");
    var NvimPlugin_1 = require_NvimPlugin();
    function createPlugin(filename, nvim, options = {}) {
      try {
        nvim.logger.debug(`createPlugin.${filename}.clearCache: ${options && !options.cache}`);
        if (options && !options.cache) {
          try {
            delete Module._cache[require.resolve(filename)];
          } catch (err) {
          }
        }
        const defaultImport = require(filename);
        const plugin = defaultImport && defaultImport.default || defaultImport;
        if (typeof plugin === "function") {
          return new NvimPlugin_1.NvimPlugin(filename, plugin, nvim);
        }
      } catch (err) {
        const file = path.basename(filename);
        nvim.logger.error(`[${file}] ${err.stack}`);
        nvim.logger.error(`[${file}] Error loading child ChildPlugin ${filename}`);
      }
      return null;
    }
    function loadPlugin(filename, nvim, options = {}) {
      try {
        return createPlugin(filename, nvim, options);
      } catch (err) {
        return null;
      }
    }
    exports.loadPlugin = loadPlugin;
  }
});

// node_modules/neovim/lib/utils/findNvim.js
var require_findNvim = __commonJS({
  "node_modules/neovim/lib/utils/findNvim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exportsForTesting = exports.findNvim = void 0;
    var node_child_process_1 = require("child_process");
    var node_path_1 = require("path");
    var node_fs_1 = require("fs");
    var versionRegex = /^(\d+)\.(\d+)\.(\d+)(?:-(.+))?$/;
    var nvimVersionRegex = /^NVIM\s+v(.+)$/m;
    var buildTypeRegex = /^Build\s+type:\s+(.+)$/m;
    var luaJitVersionRegex = /^LuaJIT\s+(.+)$/m;
    var windows = process.platform === "win32";
    function parseVersion(version) {
      if (typeof version !== "string") {
        throw new TypeError("Invalid version format: not a string");
      }
      const match = version.match(versionRegex);
      if (!match) {
        return void 0;
      }
      const [, major, minor, patch, prerelease] = match;
      const majorNumber = Number(major);
      const minorNumber = Number(minor);
      const patchNumber = Number(patch);
      const versionParts = [
        majorNumber,
        minorNumber,
        patchNumber
      ];
      if (prerelease !== void 0) {
        versionParts.push(prerelease);
      } else {
        versionParts.push("zzz");
      }
      return versionParts;
    }
    function compareVersions(a, b) {
      const versionA = parseVersion(a);
      const versionB = parseVersion(b);
      const length = Math.min(versionA.length, versionB.length);
      for (let i = 0; i < length; i = i + 1) {
        const partA = versionA[i];
        const partB = versionB[i];
        if (partA < partB) {
          return -1;
        }
        if (partA > partB) {
          return 1;
        }
      }
      if (versionB.length > versionA.length) {
        return -1;
      }
      return 0;
    }
    function findNvim2(opt = {}) {
      const paths = process.env.PATH.split(node_path_1.delimiter);
      const pathLength = paths.length;
      const matches = new Array();
      const invalid = new Array();
      for (let i = 0; i !== pathLength; i = i + 1) {
        const nvimPath = (0, node_path_1.join)(paths[i], windows ? "nvim.exe" : "nvim");
        if ((0, node_fs_1.existsSync)(nvimPath)) {
          try {
            (0, node_fs_1.accessSync)(nvimPath, node_fs_1.constants.X_OK);
            const nvimVersionFull = (0, node_child_process_1.execFileSync)(nvimPath, [
              "--version"
            ]).toString();
            const nvimVersionMatch = nvimVersionRegex.exec(nvimVersionFull);
            const buildTypeMatch = buildTypeRegex.exec(nvimVersionFull);
            const luaJitVersionMatch = luaJitVersionRegex.exec(nvimVersionFull);
            if (nvimVersionMatch && buildTypeMatch && luaJitVersionMatch) {
              if ("minVersion" in opt && compareVersions(opt.minVersion, nvimVersionMatch[1]) === 1) {
                invalid.push({
                  nvimVersion: nvimVersionMatch[1],
                  path: nvimPath,
                  buildType: buildTypeMatch[1],
                  luaJitVersion: luaJitVersionMatch[1]
                });
              } else {
                matches.push({
                  nvimVersion: nvimVersionMatch[1],
                  path: nvimPath,
                  buildType: buildTypeMatch[1],
                  luaJitVersion: luaJitVersionMatch[1]
                });
              }
            }
          } catch (e) {
            invalid.push({
              path: nvimPath,
              error: e
            });
          }
        }
      }
      if (opt.orderBy === void 0 || opt.orderBy === "desc") {
        matches.sort((a, b) => compareVersions(b.nvimVersion, a.nvimVersion));
      }
      return {
        matches,
        invalid
      };
    }
    exports.findNvim = findNvim2;
    if (process.env.NODE_ENV === "test") {
      exports.exportsForTesting = {
        parseVersion,
        compareVersions
      };
    }
  }
});

// node_modules/neovim/lib/index.js
var require_lib = __commonJS({
  "node_modules/neovim/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findNvim = exports.loadPlugin = exports.NvimPlugin = exports.Command = exports.Autocmd = exports.Function = exports.Plugin = exports.Window = exports.Tabpage = exports.Buffer = exports.NeovimClient = exports.Neovim = exports.attach = void 0;
    var attach_1 = require_attach2();
    Object.defineProperty(exports, "attach", { enumerable: true, get: function() {
      return attach_1.attach;
    } });
    var index_1 = require_api();
    Object.defineProperty(exports, "Neovim", { enumerable: true, get: function() {
      return index_1.Neovim;
    } });
    Object.defineProperty(exports, "NeovimClient", { enumerable: true, get: function() {
      return index_1.NeovimClient;
    } });
    Object.defineProperty(exports, "Buffer", { enumerable: true, get: function() {
      return index_1.Buffer;
    } });
    Object.defineProperty(exports, "Tabpage", { enumerable: true, get: function() {
      return index_1.Tabpage;
    } });
    Object.defineProperty(exports, "Window", { enumerable: true, get: function() {
      return index_1.Window;
    } });
    var plugin_1 = require_plugin3();
    Object.defineProperty(exports, "Plugin", { enumerable: true, get: function() {
      return plugin_1.Plugin;
    } });
    Object.defineProperty(exports, "Function", { enumerable: true, get: function() {
      return plugin_1.Function;
    } });
    Object.defineProperty(exports, "Autocmd", { enumerable: true, get: function() {
      return plugin_1.Autocmd;
    } });
    Object.defineProperty(exports, "Command", { enumerable: true, get: function() {
      return plugin_1.Command;
    } });
    var NvimPlugin_1 = require_NvimPlugin();
    Object.defineProperty(exports, "NvimPlugin", { enumerable: true, get: function() {
      return NvimPlugin_1.NvimPlugin;
    } });
    var factory_1 = require_factory();
    Object.defineProperty(exports, "loadPlugin", { enumerable: true, get: function() {
      return factory_1.loadPlugin;
    } });
    var findNvim_1 = require_findNvim();
    Object.defineProperty(exports, "findNvim", { enumerable: true, get: function() {
      return findNvim_1.findNvim;
    } });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EditInNeovim
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_neovim = __toESM(require_lib());
var child_process = __toESM(require("child_process"));
var DEFAULT_SETTINGS = {
  terminal: process.env.TERMINAL || "alacritty",
  listenOn: "127.0.0.1:2006",
  openNeovimOnLoad: true,
  supportedFileTypes: ["txt", "md", "css", "js", "ts", "tsx", "jsx", "json"]
};
var EditInNeovim = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.spawnNewInstanceOnLoad = (nvim, adapter) => {
      child_process.spawn(this.settings.terminal, [
        "-e",
        nvim.path,
        "--listen",
        this.settings.listenOn
      ], { cwd: adapter.getBasePath() });
    };
    this.openInNeovimInstance = (file) => {
      if (!file)
        return;
      if (!this.settings.supportedFileTypes.includes(file.extension))
        return;
      const found = (0, import_neovim.findNvim)({ orderBy: "desc", minVersion: "0.9.0" });
      child_process.spawn(found.matches[0].path, [
        "--server",
        this.settings.listenOn,
        "--remote",
        `${file.path}`
      ]);
    };
  }
  async onload() {
    await this.loadSettings();
    const adapter = this.app.vault.adapter;
    const found = (0, import_neovim.findNvim)({ orderBy: "desc", minVersion: "0.9.0" });
    if (found.matches.length === 0)
      throw Error("No Valid nvim binaries :'( plugin can't run without them");
    if (!(adapter instanceof import_obsidian.FileSystemAdapter))
      throw Error("I need a FileSystemAdapter in order to work, are you running on mobile?");
    if (this.settings.openNeovimOnLoad)
      this.spawnNewInstanceOnLoad(found.matches[0], adapter);
    console.log("Edit in Neovim Loaded! will look for neovim listening at: " + this.settings.listenOn);
    this.registerEvent(this.app.workspace.on("file-open", this.openInNeovimInstance));
    this.addSettingTab(new EditInNeovimSettingsTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var EditInNeovimSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Terminal").setDesc("Which terminal emulator should I try and use for the neovim instance?").addText((text) => text.setPlaceholder("E.g. alacritty, kitty, wezterm...").setValue(this.plugin.settings.terminal).onChange(async (value) => {
      this.plugin.settings.terminal = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Neovim Server Location").setDesc("The Neovim instance will be spawned using --listen and needs a socket or IP:PORT (not sure if sockets work so use at your own risk)").addText((text) => text.setPlaceholder("127.0.0.1:2006").setValue(this.plugin.settings.listenOn).onChange(async (value) => {
      this.plugin.settings.listenOn = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Open on startup").setDesc("Open the Neovim instance when Obsidian opens").addToggle((toggle) => toggle.setValue(this.plugin.settings.openNeovimOnLoad).onChange(async (value) => {
      this.plugin.settings.openNeovimOnLoad = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Supported file types").setDesc("Which file extensions do you want this extension to try and open?").addText((text) => text.setPlaceholder("Filetypes should be separated by spaces and not include the '.', E.g. 'txt md css html'").setValue(this.plugin.settings.supportedFileTypes.join(" ")).onChange(async (value) => {
      this.plugin.settings.supportedFileTypes = value.split(" ");
      await this.plugin.saveSettings();
    }));
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svc3JjL3V0aWxzL2ludC50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvdXRpbHMvdXRmOC50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvRXh0RGF0YS50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvRGVjb2RlRXJyb3IudHMiLCAibm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svc3JjL3RpbWVzdGFtcC50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvRXh0ZW5zaW9uQ29kZWMudHMiLCAibm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svc3JjL3V0aWxzL3R5cGVkQXJyYXlzLnRzIiwgIm5vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL3NyYy9FbmNvZGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL3NyYy9lbmNvZGUudHMiLCAibm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svc3JjL3V0aWxzL3ByZXR0eUJ5dGUudHMiLCAibm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svc3JjL0NhY2hlZEtleURlY29kZXIudHMiLCAibm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svc3JjL0RlY29kZXIudHMiLCAibm9kZV9tb2R1bGVzL0Btc2dwYWNrL21zZ3BhY2svc3JjL2RlY29kZS50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvdXRpbHMvc3RyZWFtLnRzIiwgIm5vZGVfbW9kdWxlcy9AbXNncGFjay9tc2dwYWNrL3NyYy9kZWNvZGVBc3luYy50cyIsICJub2RlX21vZHVsZXMvQG1zZ3BhY2svbXNncGFjay9zcmMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL25lb3ZpbS9saWIvdXRpbHMvdXRpbC5qcyIsICJub2RlX21vZHVsZXMvbG9nZm9ybS9mb3JtYXQuanMiLCAibm9kZV9tb2R1bGVzL0Bjb2xvcnMvY29sb3JzL2xpYi9zdHlsZXMuanMiLCAibm9kZV9tb2R1bGVzL0Bjb2xvcnMvY29sb3JzL2xpYi9zeXN0ZW0vaGFzLWZsYWcuanMiLCAibm9kZV9tb2R1bGVzL0Bjb2xvcnMvY29sb3JzL2xpYi9zeXN0ZW0vc3VwcG9ydHMtY29sb3JzLmpzIiwgIm5vZGVfbW9kdWxlcy9AY29sb3JzL2NvbG9ycy9saWIvY3VzdG9tL3RyYXAuanMiLCAibm9kZV9tb2R1bGVzL0Bjb2xvcnMvY29sb3JzL2xpYi9jdXN0b20vemFsZ28uanMiLCAibm9kZV9tb2R1bGVzL0Bjb2xvcnMvY29sb3JzL2xpYi9tYXBzL2FtZXJpY2EuanMiLCAibm9kZV9tb2R1bGVzL0Bjb2xvcnMvY29sb3JzL2xpYi9tYXBzL3plYnJhLmpzIiwgIm5vZGVfbW9kdWxlcy9AY29sb3JzL2NvbG9ycy9saWIvbWFwcy9yYWluYm93LmpzIiwgIm5vZGVfbW9kdWxlcy9AY29sb3JzL2NvbG9ycy9saWIvbWFwcy9yYW5kb20uanMiLCAibm9kZV9tb2R1bGVzL0Bjb2xvcnMvY29sb3JzL2xpYi9jb2xvcnMuanMiLCAibm9kZV9tb2R1bGVzL0Bjb2xvcnMvY29sb3JzL3NhZmUuanMiLCAibm9kZV9tb2R1bGVzL3RyaXBsZS1iZWFtL2NvbmZpZy9jbGkuanMiLCAibm9kZV9tb2R1bGVzL3RyaXBsZS1iZWFtL2NvbmZpZy9ucG0uanMiLCAibm9kZV9tb2R1bGVzL3RyaXBsZS1iZWFtL2NvbmZpZy9zeXNsb2cuanMiLCAibm9kZV9tb2R1bGVzL3RyaXBsZS1iZWFtL2NvbmZpZy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvdHJpcGxlLWJlYW0vaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2xvZ2Zvcm0vY29sb3JpemUuanMiLCAibm9kZV9tb2R1bGVzL2xvZ2Zvcm0vbGV2ZWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9sb2dmb3JtL2FsaWduLmpzIiwgIm5vZGVfbW9kdWxlcy9sb2dmb3JtL2Vycm9ycy5qcyIsICJub2RlX21vZHVsZXMvbG9nZm9ybS9wYWQtbGV2ZWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9sb2dmb3JtL2NsaS5qcyIsICJub2RlX21vZHVsZXMvbG9nZm9ybS9jb21iaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9zYWZlLXN0YWJsZS1zdHJpbmdpZnkvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2xvZ2Zvcm0vanNvbi5qcyIsICJub2RlX21vZHVsZXMvbG9nZm9ybS9sYWJlbC5qcyIsICJub2RlX21vZHVsZXMvbG9nZm9ybS9sb2dzdGFzaC5qcyIsICJub2RlX21vZHVsZXMvbG9nZm9ybS9tZXRhZGF0YS5qcyIsICJub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2xvZ2Zvcm0vbXMuanMiLCAibm9kZV9tb2R1bGVzL2xvZ2Zvcm0vcHJldHR5LXByaW50LmpzIiwgIm5vZGVfbW9kdWxlcy9sb2dmb3JtL3ByaW50Zi5qcyIsICJub2RlX21vZHVsZXMvbG9nZm9ybS9zaW1wbGUuanMiLCAibm9kZV9tb2R1bGVzL2xvZ2Zvcm0vc3BsYXQuanMiLCAibm9kZV9tb2R1bGVzL2ZlY2hhL3NyYy9mZWNoYS50cyIsICJub2RlX21vZHVsZXMvbG9nZm9ybS90aW1lc3RhbXAuanMiLCAibm9kZV9tb2R1bGVzL2xvZ2Zvcm0vdW5jb2xvcml6ZS5qcyIsICJub2RlX21vZHVsZXMvbG9nZm9ybS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9jb21tb24uanMiLCAibm9kZV9tb2R1bGVzL3dpbnN0b24vcGFja2FnZS5qc29uIiwgIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLmpzIiwgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsICJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2Vycm9ycy5qcyIsICJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlLmpzIiwgIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0cy5qcyIsICJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0LmpzIiwgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcyIsICJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzIiwgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZnJvbS5qcyIsICJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCAibm9kZV9tb2R1bGVzL3dpbnN0b24tdHJhbnNwb3J0L21vZGVybi5qcyIsICJub2RlX21vZHVsZXMvd2luc3Rvbi10cmFuc3BvcnQvbGVnYWN5LmpzIiwgIm5vZGVfbW9kdWxlcy93aW5zdG9uLXRyYW5zcG9ydC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90cmFuc3BvcnRzL2NvbnNvbGUuanMiLCAibm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL2lzQXJyYXlMaWtlLmpzIiwgIm5vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9pbml0aWFsUGFyYW1zLmpzIiwgIm5vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9zZXRJbW1lZGlhdGUuanMiLCAibm9kZV9tb2R1bGVzL2FzeW5jL2FzeW5jaWZ5LmpzIiwgIm5vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC93cmFwQXN5bmMuanMiLCAibm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL2F3YWl0aWZ5LmpzIiwgIm5vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9wYXJhbGxlbC5qcyIsICJub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvb25jZS5qcyIsICJub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvZ2V0SXRlcmF0b3IuanMiLCAibm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL2l0ZXJhdG9yLmpzIiwgIm5vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9vbmx5T25jZS5qcyIsICJub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvYnJlYWtMb29wLmpzIiwgIm5vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9hc3luY0VhY2hPZkxpbWl0LmpzIiwgIm5vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9lYWNoT2ZMaW1pdC5qcyIsICJub2RlX21vZHVsZXMvYXN5bmMvZWFjaE9mTGltaXQuanMiLCAibm9kZV9tb2R1bGVzL2FzeW5jL2VhY2hPZlNlcmllcy5qcyIsICJub2RlX21vZHVsZXMvYXN5bmMvc2VyaWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwgIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCAibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcyIsICJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwgIm5vZGVfbW9kdWxlcy9AZGFiaC9kaWFnbm9zdGljcy9kaWFnbm9zdGljcy5qcyIsICJub2RlX21vZHVsZXMvQGRhYmgvZGlhZ25vc3RpY3Mvbm9kZS9wcm9kdWN0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9jb2xvci1uYW1lL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9pcy1hcnJheWlzaC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvc2ltcGxlLXN3aXp6bGUvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2NvbG9yLXN0cmluZy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvY29sb3Ivbm9kZV9tb2R1bGVzL2NvbG9yLW5hbWUvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2NvbG9yL25vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L2NvbnZlcnNpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy9jb2xvci9ub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9yb3V0ZS5qcyIsICJub2RlX21vZHVsZXMvY29sb3Ivbm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2NvbG9yL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy90ZXh0LWhleC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvY29sb3JzcGFjZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMva3VsZXIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BkYWJoL2RpYWdub3N0aWNzL21vZGlmaWVycy9uYW1lc3BhY2UtYW5zaS5qcyIsICJub2RlX21vZHVsZXMvZW5hYmxlZC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGRhYmgvZGlhZ25vc3RpY3MvYWRhcHRlcnMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BkYWJoL2RpYWdub3N0aWNzL2FkYXB0ZXJzL3Byb2Nlc3MuZW52LmpzIiwgIm5vZGVfbW9kdWxlcy9AZGFiaC9kaWFnbm9zdGljcy9sb2dnZXIvY29uc29sZS5qcyIsICJub2RlX21vZHVsZXMvQGRhYmgvZGlhZ25vc3RpY3Mvbm9kZS9kZXZlbG9wbWVudC5qcyIsICJub2RlX21vZHVsZXMvQGRhYmgvZGlhZ25vc3RpY3Mvbm9kZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90YWlsLWZpbGUuanMiLCAibm9kZV9tb2R1bGVzL3dpbnN0b24vbGliL3dpbnN0b24vdHJhbnNwb3J0cy9maWxlLmpzIiwgIm5vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL3RyYW5zcG9ydHMvaHR0cC5qcyIsICJub2RlX21vZHVsZXMvaXMtc3RyZWFtL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL3RyYW5zcG9ydHMvc3RyZWFtLmpzIiwgIm5vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL3RyYW5zcG9ydHMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3dpbnN0b24vbGliL3dpbnN0b24vY29uZmlnL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9hc3luYy9lYWNoT2YuanMiLCAibm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL3dpdGhvdXRJbmRleC5qcyIsICJub2RlX21vZHVsZXMvYXN5bmMvZm9yRWFjaC5qcyIsICJub2RlX21vZHVsZXMvZm4ubmFtZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvb25lLXRpbWUvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3N0YWNrLXRyYWNlL2xpYi9zdGFjay10cmFjZS5qcyIsICJub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9leGNlcHRpb24tc3RyZWFtLmpzIiwgIm5vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL2V4Y2VwdGlvbi1oYW5kbGVyLmpzIiwgIm5vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL3JlamVjdGlvbi1oYW5kbGVyLmpzIiwgIm5vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL3Byb2ZpbGVyLmpzIiwgIm5vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL2xvZ2dlci5qcyIsICJub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9jcmVhdGUtbG9nZ2VyLmpzIiwgIm5vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL2NvbnRhaW5lci5qcyIsICJub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi5qcyIsICJub2RlX21vZHVsZXMvbmVvdmltL2xpYi91dGlscy9sb2dnZXIuanMiLCAibm9kZV9tb2R1bGVzL25lb3ZpbS9saWIvYXBpL0Jhc2UuanMiLCAibm9kZV9tb2R1bGVzL25lb3ZpbS9saWIvYXBpL0J1ZmZlci5qcyIsICJub2RlX21vZHVsZXMvbmVvdmltL2xpYi9hcGkvdXRpbHMvY3JlYXRlQ2hhaW5hYmxlQXBpLmpzIiwgIm5vZGVfbW9kdWxlcy9uZW92aW0vbGliL2FwaS9UYWJwYWdlLmpzIiwgIm5vZGVfbW9kdWxlcy9uZW92aW0vbGliL2FwaS9XaW5kb3cuanMiLCAibm9kZV9tb2R1bGVzL25lb3ZpbS9saWIvYXBpL3R5cGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9uZW92aW0vbGliL3V0aWxzL3RyYW5zcG9ydC5qcyIsICJub2RlX21vZHVsZXMvbmVvdmltL2xpYi9hcGkvTmVvdmltLmpzIiwgIm5vZGVfbW9kdWxlcy9uZW92aW0vbGliL2FwaS9jbGllbnQuanMiLCAibm9kZV9tb2R1bGVzL25lb3ZpbS9saWIvYXR0YWNoL2F0dGFjaC5qcyIsICJub2RlX21vZHVsZXMvbmVvdmltL2xpYi9hdHRhY2guanMiLCAibm9kZV9tb2R1bGVzL25lb3ZpbS9saWIvYXBpL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9uZW92aW0vbGliL3BsdWdpbi9wcm9wZXJ0aWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9uZW92aW0vbGliL2hvc3QvTnZpbVBsdWdpbi5qcyIsICJub2RlX21vZHVsZXMvbmVvdmltL2xpYi9wbHVnaW4vcGx1Z2luLmpzIiwgIm5vZGVfbW9kdWxlcy9uZW92aW0vbGliL3BsdWdpbi9mdW5jdGlvbi5qcyIsICJub2RlX21vZHVsZXMvbmVvdmltL2xpYi9wbHVnaW4vYXV0b2NtZC5qcyIsICJub2RlX21vZHVsZXMvbmVvdmltL2xpYi9wbHVnaW4vY29tbWFuZC5qcyIsICJub2RlX21vZHVsZXMvbmVvdmltL2xpYi9wbHVnaW4vaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL25lb3ZpbS9saWIvcGx1Z2luLmpzIiwgIm5vZGVfbW9kdWxlcy9uZW92aW0vbGliL2hvc3QvZmFjdG9yeS5qcyIsICJub2RlX21vZHVsZXMvbmVvdmltL2xpYi91dGlscy9maW5kTnZpbS5qcyIsICJub2RlX21vZHVsZXMvbmVvdmltL2xpYi9pbmRleC5qcyIsICJtYWluLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBJbnRlZ2VyIFV0aWxpdHlcblxuZXhwb3J0IGNvbnN0IFVJTlQzMl9NQVggPSAweGZmZmZfZmZmZjtcblxuLy8gRGF0YVZpZXcgZXh0ZW5zaW9uIHRvIGhhbmRsZSBpbnQ2NCAvIHVpbnQ2NCxcbi8vIHdoZXJlIHRoZSBhY3R1YWwgcmFuZ2UgaXMgNTMtYml0cyBpbnRlZ2VyIChhLmsuYS4gc2FmZSBpbnRlZ2VyKVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VWludDY0KHZpZXc6IERhdGFWaWV3LCBvZmZzZXQ6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IHZvaWQge1xuICBjb25zdCBoaWdoID0gdmFsdWUgLyAweDFfMDAwMF8wMDAwO1xuICBjb25zdCBsb3cgPSB2YWx1ZTsgLy8gaGlnaCBiaXRzIGFyZSB0cnVuY2F0ZWQgYnkgRGF0YVZpZXdcbiAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBoaWdoKTtcbiAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgNCwgbG93KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEludDY0KHZpZXc6IERhdGFWaWV3LCBvZmZzZXQ6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IHZvaWQge1xuICBjb25zdCBoaWdoID0gTWF0aC5mbG9vcih2YWx1ZSAvIDB4MV8wMDAwXzAwMDApO1xuICBjb25zdCBsb3cgPSB2YWx1ZTsgLy8gaGlnaCBiaXRzIGFyZSB0cnVuY2F0ZWQgYnkgRGF0YVZpZXdcbiAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBoaWdoKTtcbiAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgNCwgbG93KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEludDY0KHZpZXc6IERhdGFWaWV3LCBvZmZzZXQ6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IGhpZ2ggPSB2aWV3LmdldEludDMyKG9mZnNldCk7XG4gIGNvbnN0IGxvdyA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQpO1xuICByZXR1cm4gaGlnaCAqIDB4MV8wMDAwXzAwMDAgKyBsb3c7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaW50NjQodmlldzogRGF0YVZpZXcsIG9mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgaGlnaCA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gIGNvbnN0IGxvdyA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQpO1xuICByZXR1cm4gaGlnaCAqIDB4MV8wMDAwXzAwMDAgKyBsb3c7XG59XG4iLCAiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAqL1xuaW1wb3J0IHsgVUlOVDMyX01BWCB9IGZyb20gXCIuL2ludFwiO1xuXG5jb25zdCBURVhUX0VOQ09ESU5HX0FWQUlMQUJMRSA9XG4gICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBwcm9jZXNzPy5lbnY/LltcIlRFWFRfRU5DT0RJTkdcIl0gIT09IFwibmV2ZXJcIikgJiZcbiAgdHlwZW9mIFRleHRFbmNvZGVyICE9PSBcInVuZGVmaW5lZFwiICYmXG4gIHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gXCJ1bmRlZmluZWRcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhDb3VudChzdHI6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG5cbiAgbGV0IGJ5dGVMZW5ndGggPSAwO1xuICBsZXQgcG9zID0gMDtcbiAgd2hpbGUgKHBvcyA8IHN0ckxlbmd0aCkge1xuICAgIGxldCB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAgIGlmICgodmFsdWUgJiAweGZmZmZmZjgwKSA9PT0gMCkge1xuICAgICAgLy8gMS1ieXRlXG4gICAgICBieXRlTGVuZ3RoKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKCh2YWx1ZSAmIDB4ZmZmZmY4MDApID09PSAwKSB7XG4gICAgICAvLyAyLWJ5dGVzXG4gICAgICBieXRlTGVuZ3RoICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhbmRsZSBzdXJyb2dhdGUgcGFpclxuICAgICAgaWYgKHZhbHVlID49IDB4ZDgwMCAmJiB2YWx1ZSA8PSAweGRiZmYpIHtcbiAgICAgICAgLy8gaGlnaCBzdXJyb2dhdGVcbiAgICAgICAgaWYgKHBvcyA8IHN0ckxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGV4dHJhID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICBpZiAoKGV4dHJhICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgICAgICArK3BvcztcbiAgICAgICAgICAgIHZhbHVlID0gKCh2YWx1ZSAmIDB4M2ZmKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNmZikgKyAweDEwMDAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKHZhbHVlICYgMHhmZmZmMDAwMCkgPT09IDApIHtcbiAgICAgICAgLy8gMy1ieXRlXG4gICAgICAgIGJ5dGVMZW5ndGggKz0gMztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDQtYnl0ZVxuICAgICAgICBieXRlTGVuZ3RoICs9IDQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlTGVuZ3RoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXRmOEVuY29kZUpzKHN0cjogc3RyaW5nLCBvdXRwdXQ6IFVpbnQ4QXJyYXksIG91dHB1dE9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gIGNvbnN0IHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIGxldCBvZmZzZXQgPSBvdXRwdXRPZmZzZXQ7XG4gIGxldCBwb3MgPSAwO1xuICB3aGlsZSAocG9zIDwgc3RyTGVuZ3RoKSB7XG4gICAgbGV0IHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gICAgaWYgKCh2YWx1ZSAmIDB4ZmZmZmZmODApID09PSAwKSB7XG4gICAgICAvLyAxLWJ5dGVcbiAgICAgIG91dHB1dFtvZmZzZXQrK10gPSB2YWx1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoKHZhbHVlICYgMHhmZmZmZjgwMCkgPT09IDApIHtcbiAgICAgIC8vIDItYnl0ZXNcbiAgICAgIG91dHB1dFtvZmZzZXQrK10gPSAoKHZhbHVlID4+IDYpICYgMHgxZikgfCAweGMwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYW5kbGUgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmKSB7XG4gICAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlXG4gICAgICAgIGlmIChwb3MgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBleHRyYSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgaWYgKChleHRyYSAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgKytwb3M7XG4gICAgICAgICAgICB2YWx1ZSA9ICgodmFsdWUgJiAweDNmZikgPDwgMTApICsgKGV4dHJhICYgMHgzZmYpICsgMHgxMDAwMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCh2YWx1ZSAmIDB4ZmZmZjAwMDApID09PSAwKSB7XG4gICAgICAgIC8vIDMtYnl0ZVxuICAgICAgICBvdXRwdXRbb2Zmc2V0KytdID0gKCh2YWx1ZSA+PiAxMikgJiAweDBmKSB8IDB4ZTA7XG4gICAgICAgIG91dHB1dFtvZmZzZXQrK10gPSAoKHZhbHVlID4+IDYpICYgMHgzZikgfCAweDgwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gNC1ieXRlXG4gICAgICAgIG91dHB1dFtvZmZzZXQrK10gPSAoKHZhbHVlID4+IDE4KSAmIDB4MDcpIHwgMHhmMDtcbiAgICAgICAgb3V0cHV0W29mZnNldCsrXSA9ICgodmFsdWUgPj4gMTIpICYgMHgzZikgfCAweDgwO1xuICAgICAgICBvdXRwdXRbb2Zmc2V0KytdID0gKCh2YWx1ZSA+PiA2KSAmIDB4M2YpIHwgMHg4MDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvdXRwdXRbb2Zmc2V0KytdID0gKHZhbHVlICYgMHgzZikgfCAweDgwO1xuICB9XG59XG5cbmNvbnN0IHNoYXJlZFRleHRFbmNvZGVyID0gVEVYVF9FTkNPRElOR19BVkFJTEFCTEUgPyBuZXcgVGV4dEVuY29kZXIoKSA6IHVuZGVmaW5lZDtcbmV4cG9ydCBjb25zdCBURVhUX0VOQ09ERVJfVEhSRVNIT0xEID0gIVRFWFRfRU5DT0RJTkdfQVZBSUxBQkxFXG4gID8gVUlOVDMyX01BWFxuICA6IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3M/LmVudj8uW1wiVEVYVF9FTkNPRElOR1wiXSAhPT0gXCJmb3JjZVwiXG4gID8gMjAwXG4gIDogMDtcblxuZnVuY3Rpb24gdXRmOEVuY29kZVRFZW5jb2RlKHN0cjogc3RyaW5nLCBvdXRwdXQ6IFVpbnQ4QXJyYXksIG91dHB1dE9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gIG91dHB1dC5zZXQoc2hhcmVkVGV4dEVuY29kZXIhLmVuY29kZShzdHIpLCBvdXRwdXRPZmZzZXQpO1xufVxuXG5mdW5jdGlvbiB1dGY4RW5jb2RlVEVlbmNvZGVJbnRvKHN0cjogc3RyaW5nLCBvdXRwdXQ6IFVpbnQ4QXJyYXksIG91dHB1dE9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gIHNoYXJlZFRleHRFbmNvZGVyIS5lbmNvZGVJbnRvKHN0ciwgb3V0cHV0LnN1YmFycmF5KG91dHB1dE9mZnNldCkpO1xufVxuXG5leHBvcnQgY29uc3QgdXRmOEVuY29kZVRFID0gc2hhcmVkVGV4dEVuY29kZXI/LmVuY29kZUludG8gPyB1dGY4RW5jb2RlVEVlbmNvZGVJbnRvIDogdXRmOEVuY29kZVRFZW5jb2RlO1xuXG5jb25zdCBDSFVOS19TSVpFID0gMHgxXzAwMDtcblxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhEZWNvZGVKcyhieXRlczogVWludDhBcnJheSwgaW5wdXRPZmZzZXQ6IG51bWJlciwgYnl0ZUxlbmd0aDogbnVtYmVyKTogc3RyaW5nIHtcbiAgbGV0IG9mZnNldCA9IGlucHV0T2Zmc2V0O1xuICBjb25zdCBlbmQgPSBvZmZzZXQgKyBieXRlTGVuZ3RoO1xuXG4gIGNvbnN0IHVuaXRzOiBBcnJheTxudW1iZXI+ID0gW107XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICB3aGlsZSAob2Zmc2V0IDwgZW5kKSB7XG4gICAgY29uc3QgYnl0ZTEgPSBieXRlc1tvZmZzZXQrK10hO1xuICAgIGlmICgoYnl0ZTEgJiAweDgwKSA9PT0gMCkge1xuICAgICAgLy8gMSBieXRlXG4gICAgICB1bml0cy5wdXNoKGJ5dGUxKTtcbiAgICB9IGVsc2UgaWYgKChieXRlMSAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAvLyAyIGJ5dGVzXG4gICAgICBjb25zdCBieXRlMiA9IGJ5dGVzW29mZnNldCsrXSEgJiAweDNmO1xuICAgICAgdW5pdHMucHVzaCgoKGJ5dGUxICYgMHgxZikgPDwgNikgfCBieXRlMik7XG4gICAgfSBlbHNlIGlmICgoYnl0ZTEgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgLy8gMyBieXRlc1xuICAgICAgY29uc3QgYnl0ZTIgPSBieXRlc1tvZmZzZXQrK10hICYgMHgzZjtcbiAgICAgIGNvbnN0IGJ5dGUzID0gYnl0ZXNbb2Zmc2V0KytdISAmIDB4M2Y7XG4gICAgICB1bml0cy5wdXNoKCgoYnl0ZTEgJiAweDFmKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMyk7XG4gICAgfSBlbHNlIGlmICgoYnl0ZTEgJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgLy8gNCBieXRlc1xuICAgICAgY29uc3QgYnl0ZTIgPSBieXRlc1tvZmZzZXQrK10hICYgMHgzZjtcbiAgICAgIGNvbnN0IGJ5dGUzID0gYnl0ZXNbb2Zmc2V0KytdISAmIDB4M2Y7XG4gICAgICBjb25zdCBieXRlNCA9IGJ5dGVzW29mZnNldCsrXSEgJiAweDNmO1xuICAgICAgbGV0IHVuaXQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwYykgfCAoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcbiAgICAgIGlmICh1bml0ID4gMHhmZmZmKSB7XG4gICAgICAgIHVuaXQgLT0gMHgxMDAwMDtcbiAgICAgICAgdW5pdHMucHVzaCgoKHVuaXQgPj4+IDEwKSAmIDB4M2ZmKSB8IDB4ZDgwMCk7XG4gICAgICAgIHVuaXQgPSAweGRjMDAgfCAodW5pdCAmIDB4M2ZmKTtcbiAgICAgIH1cbiAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXRzLnB1c2goYnl0ZTEpO1xuICAgIH1cblxuICAgIGlmICh1bml0cy5sZW5ndGggPj0gQ0hVTktfU0laRSkge1xuICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoLi4udW5pdHMpO1xuICAgICAgdW5pdHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cblxuICBpZiAodW5pdHMubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLnVuaXRzKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IHNoYXJlZFRleHREZWNvZGVyID0gVEVYVF9FTkNPRElOR19BVkFJTEFCTEUgPyBuZXcgVGV4dERlY29kZXIoKSA6IG51bGw7XG5leHBvcnQgY29uc3QgVEVYVF9ERUNPREVSX1RIUkVTSE9MRCA9ICFURVhUX0VOQ09ESU5HX0FWQUlMQUJMRVxuICA/IFVJTlQzMl9NQVhcbiAgOiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzPy5lbnY/LltcIlRFWFRfREVDT0RFUlwiXSAhPT0gXCJmb3JjZVwiXG4gID8gMjAwXG4gIDogMDtcblxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhEZWNvZGVURChieXRlczogVWludDhBcnJheSwgaW5wdXRPZmZzZXQ6IG51bWJlciwgYnl0ZUxlbmd0aDogbnVtYmVyKTogc3RyaW5nIHtcbiAgY29uc3Qgc3RyaW5nQnl0ZXMgPSBieXRlcy5zdWJhcnJheShpbnB1dE9mZnNldCwgaW5wdXRPZmZzZXQgKyBieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHNoYXJlZFRleHREZWNvZGVyIS5kZWNvZGUoc3RyaW5nQnl0ZXMpO1xufVxuIiwgIi8qKlxuICogRXh0RGF0YSBpcyB1c2VkIHRvIGhhbmRsZSBFeHRlbnNpb24gVHlwZXMgdGhhdCBhcmUgbm90IHJlZ2lzdGVyZWQgdG8gRXh0ZW5zaW9uQ29kZWMuXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHREYXRhIHtcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgdHlwZTogbnVtYmVyLCByZWFkb25seSBkYXRhOiBVaW50OEFycmF5KSB7fVxufVxuIiwgImV4cG9ydCBjbGFzcyBEZWNvZGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG5cbiAgICAvLyBmaXggdGhlIHByb3RvdHlwZSBjaGFpbiBpbiBhIGNyb3NzLXBsYXRmb3JtIHdheVxuICAgIGNvbnN0IHByb3RvOiB0eXBlb2YgRGVjb2RlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShEZWNvZGVFcnJvci5wcm90b3R5cGUpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBwcm90byk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IERlY29kZUVycm9yLm5hbWUsXG4gICAgfSk7XG4gIH1cbn1cbiIsICIvLyBodHRwczovL2dpdGh1Yi5jb20vbXNncGFjay9tc2dwYWNrL2Jsb2IvbWFzdGVyL3NwZWMubWQjdGltZXN0YW1wLWV4dGVuc2lvbi10eXBlXG5pbXBvcnQgeyBEZWNvZGVFcnJvciB9IGZyb20gXCIuL0RlY29kZUVycm9yXCI7XG5pbXBvcnQgeyBnZXRJbnQ2NCwgc2V0SW50NjQgfSBmcm9tIFwiLi91dGlscy9pbnRcIjtcblxuZXhwb3J0IGNvbnN0IEVYVF9USU1FU1RBTVAgPSAtMTtcblxuZXhwb3J0IHR5cGUgVGltZVNwZWMgPSB7XG4gIHNlYzogbnVtYmVyO1xuICBuc2VjOiBudW1iZXI7XG59O1xuXG5jb25zdCBUSU1FU1RBTVAzMl9NQVhfU0VDID0gMHgxMDAwMDAwMDAgLSAxOyAvLyAzMi1iaXQgdW5zaWduZWQgaW50XG5jb25zdCBUSU1FU1RBTVA2NF9NQVhfU0VDID0gMHg0MDAwMDAwMDAgLSAxOyAvLyAzNC1iaXQgdW5zaWduZWQgaW50XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVUaW1lU3BlY1RvVGltZXN0YW1wKHsgc2VjLCBuc2VjIH06IFRpbWVTcGVjKTogVWludDhBcnJheSB7XG4gIGlmIChzZWMgPj0gMCAmJiBuc2VjID49IDAgJiYgc2VjIDw9IFRJTUVTVEFNUDY0X01BWF9TRUMpIHtcbiAgICAvLyBIZXJlIHNlYyA+PSAwICYmIG5zZWMgPj0gMFxuICAgIGlmIChuc2VjID09PSAwICYmIHNlYyA8PSBUSU1FU1RBTVAzMl9NQVhfU0VDKSB7XG4gICAgICAvLyB0aW1lc3RhbXAgMzIgPSB7IHNlYzMyICh1bnNpZ25lZCkgfVxuICAgICAgY29uc3QgcnYgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcocnYuYnVmZmVyKTtcbiAgICAgIHZpZXcuc2V0VWludDMyKDAsIHNlYyk7XG4gICAgICByZXR1cm4gcnY7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRpbWVzdGFtcCA2NCA9IHsgbnNlYzMwICh1bnNpZ25lZCksIHNlYzM0ICh1bnNpZ25lZCkgfVxuICAgICAgY29uc3Qgc2VjSGlnaCA9IHNlYyAvIDB4MTAwMDAwMDAwO1xuICAgICAgY29uc3Qgc2VjTG93ID0gc2VjICYgMHhmZmZmZmZmZjtcbiAgICAgIGNvbnN0IHJ2ID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KHJ2LmJ1ZmZlcik7XG4gICAgICAvLyBuc2VjMzAgfCBzZWNIaWdoMlxuICAgICAgdmlldy5zZXRVaW50MzIoMCwgKG5zZWMgPDwgMikgfCAoc2VjSGlnaCAmIDB4MykpO1xuICAgICAgLy8gc2VjTG93MzJcbiAgICAgIHZpZXcuc2V0VWludDMyKDQsIHNlY0xvdyk7XG4gICAgICByZXR1cm4gcnY7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHRpbWVzdGFtcCA5NiA9IHsgbnNlYzMyICh1bnNpZ25lZCksIHNlYzY0IChzaWduZWQpIH1cbiAgICBjb25zdCBydiA9IG5ldyBVaW50OEFycmF5KDEyKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KHJ2LmJ1ZmZlcik7XG4gICAgdmlldy5zZXRVaW50MzIoMCwgbnNlYyk7XG4gICAgc2V0SW50NjQodmlldywgNCwgc2VjKTtcbiAgICByZXR1cm4gcnY7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZURhdGVUb1RpbWVTcGVjKGRhdGU6IERhdGUpOiBUaW1lU3BlYyB7XG4gIGNvbnN0IG1zZWMgPSBkYXRlLmdldFRpbWUoKTtcbiAgY29uc3Qgc2VjID0gTWF0aC5mbG9vcihtc2VjIC8gMWUzKTtcbiAgY29uc3QgbnNlYyA9IChtc2VjIC0gc2VjICogMWUzKSAqIDFlNjtcblxuICAvLyBOb3JtYWxpemVzIHsgc2VjLCBuc2VjIH0gdG8gZW5zdXJlIG5zZWMgaXMgdW5zaWduZWQuXG4gIGNvbnN0IG5zZWNJblNlYyA9IE1hdGguZmxvb3IobnNlYyAvIDFlOSk7XG4gIHJldHVybiB7XG4gICAgc2VjOiBzZWMgKyBuc2VjSW5TZWMsXG4gICAgbnNlYzogbnNlYyAtIG5zZWNJblNlYyAqIDFlOSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVRpbWVzdGFtcEV4dGVuc2lvbihvYmplY3Q6IHVua25vd24pOiBVaW50OEFycmF5IHwgbnVsbCB7XG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgY29uc3QgdGltZVNwZWMgPSBlbmNvZGVEYXRlVG9UaW1lU3BlYyhvYmplY3QpO1xuICAgIHJldHVybiBlbmNvZGVUaW1lU3BlY1RvVGltZXN0YW1wKHRpbWVTcGVjKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVGltZXN0YW1wVG9UaW1lU3BlYyhkYXRhOiBVaW50OEFycmF5KTogVGltZVNwZWMge1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgLy8gZGF0YSBtYXkgYmUgMzIsIDY0LCBvciA5NiBiaXRzXG4gIHN3aXRjaCAoZGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgY2FzZSA0OiB7XG4gICAgICAvLyB0aW1lc3RhbXAgMzIgPSB7IHNlYzMyIH1cbiAgICAgIGNvbnN0IHNlYyA9IHZpZXcuZ2V0VWludDMyKDApO1xuICAgICAgY29uc3QgbnNlYyA9IDA7XG4gICAgICByZXR1cm4geyBzZWMsIG5zZWMgfTtcbiAgICB9XG4gICAgY2FzZSA4OiB7XG4gICAgICAvLyB0aW1lc3RhbXAgNjQgPSB7IG5zZWMzMCwgc2VjMzQgfVxuICAgICAgY29uc3QgbnNlYzMwQW5kU2VjSGlnaDIgPSB2aWV3LmdldFVpbnQzMigwKTtcbiAgICAgIGNvbnN0IHNlY0xvdzMyID0gdmlldy5nZXRVaW50MzIoNCk7XG4gICAgICBjb25zdCBzZWMgPSAobnNlYzMwQW5kU2VjSGlnaDIgJiAweDMpICogMHgxMDAwMDAwMDAgKyBzZWNMb3czMjtcbiAgICAgIGNvbnN0IG5zZWMgPSBuc2VjMzBBbmRTZWNIaWdoMiA+Pj4gMjtcbiAgICAgIHJldHVybiB7IHNlYywgbnNlYyB9O1xuICAgIH1cbiAgICBjYXNlIDEyOiB7XG4gICAgICAvLyB0aW1lc3RhbXAgOTYgPSB7IG5zZWMzMiAodW5zaWduZWQpLCBzZWM2NCAoc2lnbmVkKSB9XG5cbiAgICAgIGNvbnN0IHNlYyA9IGdldEludDY0KHZpZXcsIDQpO1xuICAgICAgY29uc3QgbnNlYyA9IHZpZXcuZ2V0VWludDMyKDApO1xuICAgICAgcmV0dXJuIHsgc2VjLCBuc2VjIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRGVjb2RlRXJyb3IoYFVucmVjb2duaXplZCBkYXRhIHNpemUgZm9yIHRpbWVzdGFtcCAoZXhwZWN0ZWQgNCwgOCwgb3IgMTIpOiAke2RhdGEubGVuZ3RofWApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUaW1lc3RhbXBFeHRlbnNpb24oZGF0YTogVWludDhBcnJheSk6IERhdGUge1xuICBjb25zdCB0aW1lU3BlYyA9IGRlY29kZVRpbWVzdGFtcFRvVGltZVNwZWMoZGF0YSk7XG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lU3BlYy5zZWMgKiAxZTMgKyB0aW1lU3BlYy5uc2VjIC8gMWU2KTtcbn1cblxuZXhwb3J0IGNvbnN0IHRpbWVzdGFtcEV4dGVuc2lvbiA9IHtcbiAgdHlwZTogRVhUX1RJTUVTVEFNUCxcbiAgZW5jb2RlOiBlbmNvZGVUaW1lc3RhbXBFeHRlbnNpb24sXG4gIGRlY29kZTogZGVjb2RlVGltZXN0YW1wRXh0ZW5zaW9uLFxufTtcbiIsICIvLyBFeHRlbnNpb25Db2RlYyB0byBoYW5kbGUgTWVzc2FnZVBhY2sgZXh0ZW5zaW9uc1xuXG5pbXBvcnQgeyBFeHREYXRhIH0gZnJvbSBcIi4vRXh0RGF0YVwiO1xuaW1wb3J0IHsgdGltZXN0YW1wRXh0ZW5zaW9uIH0gZnJvbSBcIi4vdGltZXN0YW1wXCI7XG5cbmV4cG9ydCB0eXBlIEV4dGVuc2lvbkRlY29kZXJUeXBlPENvbnRleHRUeXBlPiA9IChcbiAgZGF0YTogVWludDhBcnJheSxcbiAgZXh0ZW5zaW9uVHlwZTogbnVtYmVyLFxuICBjb250ZXh0OiBDb250ZXh0VHlwZSxcbikgPT4gdW5rbm93bjtcblxuZXhwb3J0IHR5cGUgRXh0ZW5zaW9uRW5jb2RlclR5cGU8Q29udGV4dFR5cGU+ID0gKGlucHV0OiB1bmtub3duLCBjb250ZXh0OiBDb250ZXh0VHlwZSkgPT4gVWludDhBcnJheSB8IG51bGw7XG5cbi8vIGltbXV0YWJsZSBpbnRlcmZhY2UgdG8gRXh0ZW5zaW9uQ29kZWNcbmV4cG9ydCB0eXBlIEV4dGVuc2lvbkNvZGVjVHlwZTxDb250ZXh0VHlwZT4gPSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgX19icmFuZD86IENvbnRleHRUeXBlO1xuICB0cnlUb0VuY29kZShvYmplY3Q6IHVua25vd24sIGNvbnRleHQ6IENvbnRleHRUeXBlKTogRXh0RGF0YSB8IG51bGw7XG4gIGRlY29kZShkYXRhOiBVaW50OEFycmF5LCBleHRUeXBlOiBudW1iZXIsIGNvbnRleHQ6IENvbnRleHRUeXBlKTogdW5rbm93bjtcbn07XG5cbmV4cG9ydCBjbGFzcyBFeHRlbnNpb25Db2RlYzxDb250ZXh0VHlwZSA9IHVuZGVmaW5lZD4gaW1wbGVtZW50cyBFeHRlbnNpb25Db2RlY1R5cGU8Q29udGV4dFR5cGU+IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBkZWZhdWx0Q29kZWM6IEV4dGVuc2lvbkNvZGVjVHlwZTx1bmRlZmluZWQ+ID0gbmV3IEV4dGVuc2lvbkNvZGVjKCk7XG5cbiAgLy8gZW5zdXJlcyBFeHRlbnNpb25Db2RlY1R5cGU8WD4gbWF0Y2hlcyBFeHRlbnNpb25Db2RlYzxYPlxuICAvLyB0aGlzIHdpbGwgbWFrZSB0eXBlIGVycm9ycyBhIGxvdCBtb3JlIGNsZWFyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgX19icmFuZD86IENvbnRleHRUeXBlO1xuXG4gIC8vIGJ1aWx0LWluIGV4dGVuc2lvbnNcbiAgcHJpdmF0ZSByZWFkb25seSBidWlsdEluRW5jb2RlcnM6IEFycmF5PEV4dGVuc2lvbkVuY29kZXJUeXBlPENvbnRleHRUeXBlPiB8IHVuZGVmaW5lZCB8IG51bGw+ID0gW107XG4gIHByaXZhdGUgcmVhZG9ubHkgYnVpbHRJbkRlY29kZXJzOiBBcnJheTxFeHRlbnNpb25EZWNvZGVyVHlwZTxDb250ZXh0VHlwZT4gfCB1bmRlZmluZWQgfCBudWxsPiA9IFtdO1xuXG4gIC8vIGN1c3RvbSBleHRlbnNpb25zXG4gIHByaXZhdGUgcmVhZG9ubHkgZW5jb2RlcnM6IEFycmF5PEV4dGVuc2lvbkVuY29kZXJUeXBlPENvbnRleHRUeXBlPiB8IHVuZGVmaW5lZCB8IG51bGw+ID0gW107XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVjb2RlcnM6IEFycmF5PEV4dGVuc2lvbkRlY29kZXJUeXBlPENvbnRleHRUeXBlPiB8IHVuZGVmaW5lZCB8IG51bGw+ID0gW107XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVnaXN0ZXIodGltZXN0YW1wRXh0ZW5zaW9uKTtcbiAgfVxuXG4gIHB1YmxpYyByZWdpc3Rlcih7XG4gICAgdHlwZSxcbiAgICBlbmNvZGUsXG4gICAgZGVjb2RlLFxuICB9OiB7XG4gICAgdHlwZTogbnVtYmVyO1xuICAgIGVuY29kZTogRXh0ZW5zaW9uRW5jb2RlclR5cGU8Q29udGV4dFR5cGU+O1xuICAgIGRlY29kZTogRXh0ZW5zaW9uRGVjb2RlclR5cGU8Q29udGV4dFR5cGU+O1xuICB9KTogdm9pZCB7XG4gICAgaWYgKHR5cGUgPj0gMCkge1xuICAgICAgLy8gY3VzdG9tIGV4dGVuc2lvbnNcbiAgICAgIHRoaXMuZW5jb2RlcnNbdHlwZV0gPSBlbmNvZGU7XG4gICAgICB0aGlzLmRlY29kZXJzW3R5cGVdID0gZGVjb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBidWlsdC1pbiBleHRlbnNpb25zXG4gICAgICBjb25zdCBpbmRleCA9IDEgKyB0eXBlO1xuICAgICAgdGhpcy5idWlsdEluRW5jb2RlcnNbaW5kZXhdID0gZW5jb2RlO1xuICAgICAgdGhpcy5idWlsdEluRGVjb2RlcnNbaW5kZXhdID0gZGVjb2RlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB0cnlUb0VuY29kZShvYmplY3Q6IHVua25vd24sIGNvbnRleHQ6IENvbnRleHRUeXBlKTogRXh0RGF0YSB8IG51bGwge1xuICAgIC8vIGJ1aWx0LWluIGV4dGVuc2lvbnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnVpbHRJbkVuY29kZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbmNvZGVFeHQgPSB0aGlzLmJ1aWx0SW5FbmNvZGVyc1tpXTtcbiAgICAgIGlmIChlbmNvZGVFeHQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZW5jb2RlRXh0KG9iamVjdCwgY29udGV4dCk7XG4gICAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCB0eXBlID0gLTEgLSBpO1xuICAgICAgICAgIHJldHVybiBuZXcgRXh0RGF0YSh0eXBlLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGN1c3RvbSBleHRlbnNpb25zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVuY29kZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbmNvZGVFeHQgPSB0aGlzLmVuY29kZXJzW2ldO1xuICAgICAgaWYgKGVuY29kZUV4dCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVFeHQob2JqZWN0LCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSBpO1xuICAgICAgICAgIHJldHVybiBuZXcgRXh0RGF0YSh0eXBlLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBFeHREYXRhKSB7XG4gICAgICAvLyB0byBrZWVwIEV4dERhdGEgYXMgaXNcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHVibGljIGRlY29kZShkYXRhOiBVaW50OEFycmF5LCB0eXBlOiBudW1iZXIsIGNvbnRleHQ6IENvbnRleHRUeXBlKTogdW5rbm93biB7XG4gICAgY29uc3QgZGVjb2RlRXh0ID0gdHlwZSA8IDAgPyB0aGlzLmJ1aWx0SW5EZWNvZGVyc1stMSAtIHR5cGVdIDogdGhpcy5kZWNvZGVyc1t0eXBlXTtcbiAgICBpZiAoZGVjb2RlRXh0KSB7XG4gICAgICByZXR1cm4gZGVjb2RlRXh0KGRhdGEsIHR5cGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkZWNvZGUoKSBkb2VzIG5vdCBmYWlsLCByZXR1cm5zIEV4dERhdGEgaW5zdGVhZC5cbiAgICAgIHJldHVybiBuZXcgRXh0RGF0YSh0eXBlLCBkYXRhKTtcbiAgICB9XG4gIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZW5zdXJlVWludDhBcnJheShidWZmZXI6IEFycmF5TGlrZTxudW1iZXI+IHwgVWludDhBcnJheSB8IEFycmF5QnVmZmVyVmlldyB8IEFycmF5QnVmZmVyKTogVWludDhBcnJheSB7XG4gIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIuYnVmZmVyLCBidWZmZXIuYnl0ZU9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2UgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXJyYXlMaWtlPG51bWJlcj5cbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGJ1ZmZlcik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURhdGFWaWV3KGJ1ZmZlcjogQXJyYXlMaWtlPG51bWJlcj4gfCBBcnJheUJ1ZmZlclZpZXcgfCBBcnJheUJ1ZmZlcik6IERhdGFWaWV3IHtcbiAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICB9XG5cbiAgY29uc3QgYnVmZmVyVmlldyA9IGVuc3VyZVVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgcmV0dXJuIG5ldyBEYXRhVmlldyhidWZmZXJWaWV3LmJ1ZmZlciwgYnVmZmVyVmlldy5ieXRlT2Zmc2V0LCBidWZmZXJWaWV3LmJ5dGVMZW5ndGgpO1xufVxuIiwgImltcG9ydCB7IHV0ZjhFbmNvZGVKcywgdXRmOENvdW50LCBURVhUX0VOQ09ERVJfVEhSRVNIT0xELCB1dGY4RW5jb2RlVEUgfSBmcm9tIFwiLi91dGlscy91dGY4XCI7XG5pbXBvcnQgeyBFeHRlbnNpb25Db2RlYywgRXh0ZW5zaW9uQ29kZWNUeXBlIH0gZnJvbSBcIi4vRXh0ZW5zaW9uQ29kZWNcIjtcbmltcG9ydCB7IHNldEludDY0LCBzZXRVaW50NjQgfSBmcm9tIFwiLi91dGlscy9pbnRcIjtcbmltcG9ydCB7IGVuc3VyZVVpbnQ4QXJyYXkgfSBmcm9tIFwiLi91dGlscy90eXBlZEFycmF5c1wiO1xuaW1wb3J0IHR5cGUgeyBFeHREYXRhIH0gZnJvbSBcIi4vRXh0RGF0YVwiO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVhfREVQVEggPSAxMDA7XG5leHBvcnQgY29uc3QgREVGQVVMVF9JTklUSUFMX0JVRkZFUl9TSVpFID0gMjA0ODtcblxuZXhwb3J0IGNsYXNzIEVuY29kZXI8Q29udGV4dFR5cGUgPSB1bmRlZmluZWQ+IHtcbiAgcHJpdmF0ZSBwb3MgPSAwO1xuICBwcml2YXRlIHZpZXcgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKHRoaXMuaW5pdGlhbEJ1ZmZlclNpemUpKTtcbiAgcHJpdmF0ZSBieXRlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMudmlldy5idWZmZXIpO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGV4dGVuc2lvbkNvZGVjOiBFeHRlbnNpb25Db2RlY1R5cGU8Q29udGV4dFR5cGU+ID0gRXh0ZW5zaW9uQ29kZWMuZGVmYXVsdENvZGVjIGFzIGFueSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbnRleHQ6IENvbnRleHRUeXBlID0gdW5kZWZpbmVkIGFzIGFueSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1heERlcHRoID0gREVGQVVMVF9NQVhfREVQVEgsXG4gICAgcHJpdmF0ZSByZWFkb25seSBpbml0aWFsQnVmZmVyU2l6ZSA9IERFRkFVTFRfSU5JVElBTF9CVUZGRVJfU0laRSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNvcnRLZXlzID0gZmFsc2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBmb3JjZUZsb2F0MzIgPSBmYWxzZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGlnbm9yZVVuZGVmaW5lZCA9IGZhbHNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZm9yY2VJbnRlZ2VyVG9GbG9hdCA9IGZhbHNlLFxuICApIHt9XG5cbiAgcHJpdmF0ZSByZWluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0aGlzLnBvcyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhbG1vc3QgZXF1aXZhbGVudCB0byB7QGxpbmsgRW5jb2RlciNlbmNvZGV9LCBidXQgaXQgcmV0dXJucyBhbiByZWZlcmVuY2Ugb2YgdGhlIGVuY29kZXIncyBpbnRlcm5hbCBidWZmZXIgYW5kIHRodXMgbXVjaCBmYXN0ZXIgdGhhbiB7QGxpbmsgRW5jb2RlciNlbmNvZGV9LlxuICAgKlxuICAgKiBAcmV0dXJucyBFbmNvZGVzIHRoZSBvYmplY3QgYW5kIHJldHVybnMgYSBzaGFyZWQgcmVmZXJlbmNlIHRoZSBlbmNvZGVyJ3MgaW50ZXJuYWwgYnVmZmVyLlxuICAgKi9cbiAgcHVibGljIGVuY29kZVNoYXJlZFJlZihvYmplY3Q6IHVua25vd24pOiBVaW50OEFycmF5IHtcbiAgICB0aGlzLnJlaW5pdGlhbGl6ZVN0YXRlKCk7XG4gICAgdGhpcy5kb0VuY29kZShvYmplY3QsIDEpO1xuICAgIHJldHVybiB0aGlzLmJ5dGVzLnN1YmFycmF5KDAsIHRoaXMucG9zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBFbmNvZGVzIHRoZSBvYmplY3QgYW5kIHJldHVybnMgYSBjb3B5IG9mIHRoZSBlbmNvZGVyJ3MgaW50ZXJuYWwgYnVmZmVyLlxuICAgKi9cbiAgcHVibGljIGVuY29kZShvYmplY3Q6IHVua25vd24pOiBVaW50OEFycmF5IHtcbiAgICB0aGlzLnJlaW5pdGlhbGl6ZVN0YXRlKCk7XG4gICAgdGhpcy5kb0VuY29kZShvYmplY3QsIDEpO1xuICAgIHJldHVybiB0aGlzLmJ5dGVzLnNsaWNlKDAsIHRoaXMucG9zKTtcbiAgfVxuXG4gIHByaXZhdGUgZG9FbmNvZGUob2JqZWN0OiB1bmtub3duLCBkZXB0aDogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKGRlcHRoID4gdGhpcy5tYXhEZXB0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb28gZGVlcCBvYmplY3RzIGluIGRlcHRoICR7ZGVwdGh9YCk7XG4gICAgfVxuXG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICB0aGlzLmVuY29kZU5pbCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHRoaXMuZW5jb2RlQm9vbGVhbihvYmplY3QpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGhpcy5lbmNvZGVOdW1iZXIob2JqZWN0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuZW5jb2RlU3RyaW5nKG9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5jb2RlT2JqZWN0KG9iamVjdCwgZGVwdGgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoc2l6ZVRvV3JpdGU6IG51bWJlcikge1xuICAgIGNvbnN0IHJlcXVpcmVkU2l6ZSA9IHRoaXMucG9zICsgc2l6ZVRvV3JpdGU7XG5cbiAgICBpZiAodGhpcy52aWV3LmJ5dGVMZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICAgIHRoaXMucmVzaXplQnVmZmVyKHJlcXVpcmVkU2l6ZSAqIDIpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVzaXplQnVmZmVyKG5ld1NpemU6IG51bWJlcikge1xuICAgIGNvbnN0IG5ld0J1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihuZXdTaXplKTtcbiAgICBjb25zdCBuZXdCeXRlcyA9IG5ldyBVaW50OEFycmF5KG5ld0J1ZmZlcik7XG4gICAgY29uc3QgbmV3VmlldyA9IG5ldyBEYXRhVmlldyhuZXdCdWZmZXIpO1xuXG4gICAgbmV3Qnl0ZXMuc2V0KHRoaXMuYnl0ZXMpO1xuXG4gICAgdGhpcy52aWV3ID0gbmV3VmlldztcbiAgICB0aGlzLmJ5dGVzID0gbmV3Qnl0ZXM7XG4gIH1cblxuICBwcml2YXRlIGVuY29kZU5pbCgpIHtcbiAgICB0aGlzLndyaXRlVTgoMHhjMCk7XG4gIH1cblxuICBwcml2YXRlIGVuY29kZUJvb2xlYW4ob2JqZWN0OiBib29sZWFuKSB7XG4gICAgaWYgKG9iamVjdCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMud3JpdGVVOCgweGMyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cml0ZVU4KDB4YzMpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIGVuY29kZU51bWJlcihvYmplY3Q6IG51bWJlcikge1xuICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcihvYmplY3QpICYmICF0aGlzLmZvcmNlSW50ZWdlclRvRmxvYXQpIHtcbiAgICAgIGlmIChvYmplY3QgPj0gMCkge1xuICAgICAgICBpZiAob2JqZWN0IDwgMHg4MCkge1xuICAgICAgICAgIC8vIHBvc2l0aXZlIGZpeGludFxuICAgICAgICAgIHRoaXMud3JpdGVVOChvYmplY3QpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdCA8IDB4MTAwKSB7XG4gICAgICAgICAgLy8gdWludCA4XG4gICAgICAgICAgdGhpcy53cml0ZVU4KDB4Y2MpO1xuICAgICAgICAgIHRoaXMud3JpdGVVOChvYmplY3QpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAvLyB1aW50IDE2XG4gICAgICAgICAgdGhpcy53cml0ZVU4KDB4Y2QpO1xuICAgICAgICAgIHRoaXMud3JpdGVVMTYob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3QgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgIC8vIHVpbnQgMzJcbiAgICAgICAgICB0aGlzLndyaXRlVTgoMHhjZSk7XG4gICAgICAgICAgdGhpcy53cml0ZVUzMihvYmplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVpbnQgNjRcbiAgICAgICAgICB0aGlzLndyaXRlVTgoMHhjZik7XG4gICAgICAgICAgdGhpcy53cml0ZVU2NChvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob2JqZWN0ID49IC0weDIwKSB7XG4gICAgICAgICAgLy8gbmVnYXRpdmUgZml4aW50XG4gICAgICAgICAgdGhpcy53cml0ZVU4KDB4ZTAgfCAob2JqZWN0ICsgMHgyMCkpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdCA+PSAtMHg4MCkge1xuICAgICAgICAgIC8vIGludCA4XG4gICAgICAgICAgdGhpcy53cml0ZVU4KDB4ZDApO1xuICAgICAgICAgIHRoaXMud3JpdGVJOChvYmplY3QpO1xuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdCA+PSAtMHg4MDAwKSB7XG4gICAgICAgICAgLy8gaW50IDE2XG4gICAgICAgICAgdGhpcy53cml0ZVU4KDB4ZDEpO1xuICAgICAgICAgIHRoaXMud3JpdGVJMTYob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3QgPj0gLTB4ODAwMDAwMDApIHtcbiAgICAgICAgICAvLyBpbnQgMzJcbiAgICAgICAgICB0aGlzLndyaXRlVTgoMHhkMik7XG4gICAgICAgICAgdGhpcy53cml0ZUkzMihvYmplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGludCA2NFxuICAgICAgICAgIHRoaXMud3JpdGVVOCgweGQzKTtcbiAgICAgICAgICB0aGlzLndyaXRlSTY0KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9uLWludGVnZXIgbnVtYmVyc1xuICAgICAgaWYgKHRoaXMuZm9yY2VGbG9hdDMyKSB7XG4gICAgICAgIC8vIGZsb2F0IDMyXG4gICAgICAgIHRoaXMud3JpdGVVOCgweGNhKTtcbiAgICAgICAgdGhpcy53cml0ZUYzMihvYmplY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmxvYXQgNjRcbiAgICAgICAgdGhpcy53cml0ZVU4KDB4Y2IpO1xuICAgICAgICB0aGlzLndyaXRlRjY0KG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZVN0cmluZ0hlYWRlcihieXRlTGVuZ3RoOiBudW1iZXIpIHtcbiAgICBpZiAoYnl0ZUxlbmd0aCA8IDMyKSB7XG4gICAgICAvLyBmaXhzdHJcbiAgICAgIHRoaXMud3JpdGVVOCgweGEwICsgYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChieXRlTGVuZ3RoIDwgMHgxMDApIHtcbiAgICAgIC8vIHN0ciA4XG4gICAgICB0aGlzLndyaXRlVTgoMHhkOSk7XG4gICAgICB0aGlzLndyaXRlVTgoYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChieXRlTGVuZ3RoIDwgMHgxMDAwMCkge1xuICAgICAgLy8gc3RyIDE2XG4gICAgICB0aGlzLndyaXRlVTgoMHhkYSk7XG4gICAgICB0aGlzLndyaXRlVTE2KGJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoYnl0ZUxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAvLyBzdHIgMzJcbiAgICAgIHRoaXMud3JpdGVVOCgweGRiKTtcbiAgICAgIHRoaXMud3JpdGVVMzIoYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vIGxvbmcgc3RyaW5nOiAke2J5dGVMZW5ndGh9IGJ5dGVzIGluIFVURi04YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBlbmNvZGVTdHJpbmcob2JqZWN0OiBzdHJpbmcpIHtcbiAgICBjb25zdCBtYXhIZWFkZXJTaXplID0gMSArIDQ7XG4gICAgY29uc3Qgc3RyTGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDtcblxuICAgIGlmIChzdHJMZW5ndGggPiBURVhUX0VOQ09ERVJfVEhSRVNIT0xEKSB7XG4gICAgICBjb25zdCBieXRlTGVuZ3RoID0gdXRmOENvdW50KG9iamVjdCk7XG4gICAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKG1heEhlYWRlclNpemUgKyBieXRlTGVuZ3RoKTtcbiAgICAgIHRoaXMud3JpdGVTdHJpbmdIZWFkZXIoYnl0ZUxlbmd0aCk7XG4gICAgICB1dGY4RW5jb2RlVEUob2JqZWN0LCB0aGlzLmJ5dGVzLCB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyArPSBieXRlTGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBieXRlTGVuZ3RoID0gdXRmOENvdW50KG9iamVjdCk7XG4gICAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKG1heEhlYWRlclNpemUgKyBieXRlTGVuZ3RoKTtcbiAgICAgIHRoaXMud3JpdGVTdHJpbmdIZWFkZXIoYnl0ZUxlbmd0aCk7XG4gICAgICB1dGY4RW5jb2RlSnMob2JqZWN0LCB0aGlzLmJ5dGVzLCB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyArPSBieXRlTGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW5jb2RlT2JqZWN0KG9iamVjdDogdW5rbm93biwgZGVwdGg6IG51bWJlcikge1xuICAgIC8vIHRyeSB0byBlbmNvZGUgb2JqZWN0cyB3aXRoIGN1c3RvbSBjb2RlYyBmaXJzdCBvZiBub24tcHJpbWl0aXZlc1xuICAgIGNvbnN0IGV4dCA9IHRoaXMuZXh0ZW5zaW9uQ29kZWMudHJ5VG9FbmNvZGUob2JqZWN0LCB0aGlzLmNvbnRleHQpO1xuICAgIGlmIChleHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5lbmNvZGVFeHRlbnNpb24oZXh0KTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgdGhpcy5lbmNvZGVBcnJheShvYmplY3QsIGRlcHRoKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhvYmplY3QpKSB7XG4gICAgICB0aGlzLmVuY29kZUJpbmFyeShvYmplY3QpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdGhpcy5lbmNvZGVNYXAob2JqZWN0IGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBkZXB0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN5bWJvbCwgZnVuY3Rpb24gYW5kIG90aGVyIHNwZWNpYWwgb2JqZWN0IGNvbWUgaGVyZSB1bmxlc3MgZXh0ZW5zaW9uQ29kZWMgaGFuZGxlcyB0aGVtLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgb2JqZWN0OiAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkob2JqZWN0KX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGVuY29kZUJpbmFyeShvYmplY3Q6IEFycmF5QnVmZmVyVmlldykge1xuICAgIGNvbnN0IHNpemUgPSBvYmplY3QuYnl0ZUxlbmd0aDtcbiAgICBpZiAoc2l6ZSA8IDB4MTAwKSB7XG4gICAgICAvLyBiaW4gOFxuICAgICAgdGhpcy53cml0ZVU4KDB4YzQpO1xuICAgICAgdGhpcy53cml0ZVU4KHNpemUpO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDB4MTAwMDApIHtcbiAgICAgIC8vIGJpbiAxNlxuICAgICAgdGhpcy53cml0ZVU4KDB4YzUpO1xuICAgICAgdGhpcy53cml0ZVUxNihzaXplKTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgLy8gYmluIDMyXG4gICAgICB0aGlzLndyaXRlVTgoMHhjNik7XG4gICAgICB0aGlzLndyaXRlVTMyKHNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBsYXJnZSBiaW5hcnk6ICR7c2l6ZX1gKTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVVaW50OEFycmF5KG9iamVjdCk7XG4gICAgdGhpcy53cml0ZVU4YShieXRlcyk7XG4gIH1cblxuICBwcml2YXRlIGVuY29kZUFycmF5KG9iamVjdDogQXJyYXk8dW5rbm93bj4sIGRlcHRoOiBudW1iZXIpIHtcbiAgICBjb25zdCBzaXplID0gb2JqZWN0Lmxlbmd0aDtcbiAgICBpZiAoc2l6ZSA8IDE2KSB7XG4gICAgICAvLyBmaXhhcnJheVxuICAgICAgdGhpcy53cml0ZVU4KDB4OTAgKyBzaXplKTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwKSB7XG4gICAgICAvLyBhcnJheSAxNlxuICAgICAgdGhpcy53cml0ZVU4KDB4ZGMpO1xuICAgICAgdGhpcy53cml0ZVUxNihzaXplKTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgLy8gYXJyYXkgMzJcbiAgICAgIHRoaXMud3JpdGVVOCgweGRkKTtcbiAgICAgIHRoaXMud3JpdGVVMzIoc2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vIGxhcmdlIGFycmF5OiAke3NpemV9YCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBvYmplY3QpIHtcbiAgICAgIHRoaXMuZG9FbmNvZGUoaXRlbSwgZGVwdGggKyAxKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvdW50V2l0aG91dFVuZGVmaW5lZChvYmplY3Q6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBrZXlzOiBSZWFkb25seUFycmF5PHN0cmluZz4pOiBudW1iZXIge1xuICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAob2JqZWN0W2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuXG4gIHByaXZhdGUgZW5jb2RlTWFwKG9iamVjdDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIGRlcHRoOiBudW1iZXIpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICBpZiAodGhpcy5zb3J0S2V5cykge1xuICAgICAga2V5cy5zb3J0KCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuaWdub3JlVW5kZWZpbmVkID8gdGhpcy5jb3VudFdpdGhvdXRVbmRlZmluZWQob2JqZWN0LCBrZXlzKSA6IGtleXMubGVuZ3RoO1xuXG4gICAgaWYgKHNpemUgPCAxNikge1xuICAgICAgLy8gZml4bWFwXG4gICAgICB0aGlzLndyaXRlVTgoMHg4MCArIHNpemUpO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDB4MTAwMDApIHtcbiAgICAgIC8vIG1hcCAxNlxuICAgICAgdGhpcy53cml0ZVU4KDB4ZGUpO1xuICAgICAgdGhpcy53cml0ZVUxNihzaXplKTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgLy8gbWFwIDMyXG4gICAgICB0aGlzLndyaXRlVTgoMHhkZik7XG4gICAgICB0aGlzLndyaXRlVTMyKHNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBsYXJnZSBtYXAgb2JqZWN0OiAke3NpemV9YCk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgaWYgKCEodGhpcy5pZ25vcmVVbmRlZmluZWQgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdGhpcy5lbmNvZGVTdHJpbmcoa2V5KTtcbiAgICAgICAgdGhpcy5kb0VuY29kZSh2YWx1ZSwgZGVwdGggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGVuY29kZUV4dGVuc2lvbihleHQ6IEV4dERhdGEpIHtcbiAgICBjb25zdCBzaXplID0gZXh0LmRhdGEubGVuZ3RoO1xuICAgIGlmIChzaXplID09PSAxKSB7XG4gICAgICAvLyBmaXhleHQgMVxuICAgICAgdGhpcy53cml0ZVU4KDB4ZDQpO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gMikge1xuICAgICAgLy8gZml4ZXh0IDJcbiAgICAgIHRoaXMud3JpdGVVOCgweGQ1KTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPT09IDQpIHtcbiAgICAgIC8vIGZpeGV4dCA0XG4gICAgICB0aGlzLndyaXRlVTgoMHhkNik7XG4gICAgfSBlbHNlIGlmIChzaXplID09PSA4KSB7XG4gICAgICAvLyBmaXhleHQgOFxuICAgICAgdGhpcy53cml0ZVU4KDB4ZDcpO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gMTYpIHtcbiAgICAgIC8vIGZpeGV4dCAxNlxuICAgICAgdGhpcy53cml0ZVU4KDB4ZDgpO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDB4MTAwKSB7XG4gICAgICAvLyBleHQgOFxuICAgICAgdGhpcy53cml0ZVU4KDB4YzcpO1xuICAgICAgdGhpcy53cml0ZVU4KHNpemUpO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDB4MTAwMDApIHtcbiAgICAgIC8vIGV4dCAxNlxuICAgICAgdGhpcy53cml0ZVU4KDB4YzgpO1xuICAgICAgdGhpcy53cml0ZVUxNihzaXplKTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPCAweDEwMDAwMDAwMCkge1xuICAgICAgLy8gZXh0IDMyXG4gICAgICB0aGlzLndyaXRlVTgoMHhjOSk7XG4gICAgICB0aGlzLndyaXRlVTMyKHNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBsYXJnZSBleHRlbnNpb24gb2JqZWN0OiAke3NpemV9YCk7XG4gICAgfVxuICAgIHRoaXMud3JpdGVJOChleHQudHlwZSk7XG4gICAgdGhpcy53cml0ZVU4YShleHQuZGF0YSk7XG4gIH1cblxuICBwcml2YXRlIHdyaXRlVTgodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoMSk7XG5cbiAgICB0aGlzLnZpZXcuc2V0VWludDgodGhpcy5wb3MsIHZhbHVlKTtcbiAgICB0aGlzLnBvcysrO1xuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZVU4YSh2YWx1ZXM6IEFycmF5TGlrZTxudW1iZXI+KSB7XG4gICAgY29uc3Qgc2l6ZSA9IHZhbHVlcy5sZW5ndGg7XG4gICAgdGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZShzaXplKTtcblxuICAgIHRoaXMuYnl0ZXMuc2V0KHZhbHVlcywgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IHNpemU7XG4gIH1cblxuICBwcml2YXRlIHdyaXRlSTgodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoMSk7XG5cbiAgICB0aGlzLnZpZXcuc2V0SW50OCh0aGlzLnBvcywgdmFsdWUpO1xuICAgIHRoaXMucG9zKys7XG4gIH1cblxuICBwcml2YXRlIHdyaXRlVTE2KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDIpO1xuXG4gICAgdGhpcy52aWV3LnNldFVpbnQxNih0aGlzLnBvcywgdmFsdWUpO1xuICAgIHRoaXMucG9zICs9IDI7XG4gIH1cblxuICBwcml2YXRlIHdyaXRlSTE2KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDIpO1xuXG4gICAgdGhpcy52aWV3LnNldEludDE2KHRoaXMucG9zLCB2YWx1ZSk7XG4gICAgdGhpcy5wb3MgKz0gMjtcbiAgfVxuXG4gIHByaXZhdGUgd3JpdGVVMzIodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoNCk7XG5cbiAgICB0aGlzLnZpZXcuc2V0VWludDMyKHRoaXMucG9zLCB2YWx1ZSk7XG4gICAgdGhpcy5wb3MgKz0gNDtcbiAgfVxuXG4gIHByaXZhdGUgd3JpdGVJMzIodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoNCk7XG5cbiAgICB0aGlzLnZpZXcuc2V0SW50MzIodGhpcy5wb3MsIHZhbHVlKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICB9XG5cbiAgcHJpdmF0ZSB3cml0ZUYzMih2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5lbnN1cmVCdWZmZXJTaXplVG9Xcml0ZSg0KTtcbiAgICB0aGlzLnZpZXcuc2V0RmxvYXQzMih0aGlzLnBvcywgdmFsdWUpO1xuICAgIHRoaXMucG9zICs9IDQ7XG4gIH1cblxuICBwcml2YXRlIHdyaXRlRjY0KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDgpO1xuICAgIHRoaXMudmlldy5zZXRGbG9hdDY0KHRoaXMucG9zLCB2YWx1ZSk7XG4gICAgdGhpcy5wb3MgKz0gODtcbiAgfVxuXG4gIHByaXZhdGUgd3JpdGVVNjQodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuZW5zdXJlQnVmZmVyU2l6ZVRvV3JpdGUoOCk7XG5cbiAgICBzZXRVaW50NjQodGhpcy52aWV3LCB0aGlzLnBvcywgdmFsdWUpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gIH1cblxuICBwcml2YXRlIHdyaXRlSTY0KHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmVuc3VyZUJ1ZmZlclNpemVUb1dyaXRlKDgpO1xuXG4gICAgc2V0SW50NjQodGhpcy52aWV3LCB0aGlzLnBvcywgdmFsdWUpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBFbmNvZGVyIH0gZnJvbSBcIi4vRW5jb2RlclwiO1xuaW1wb3J0IHR5cGUgeyBFeHRlbnNpb25Db2RlY1R5cGUgfSBmcm9tIFwiLi9FeHRlbnNpb25Db2RlY1wiO1xuaW1wb3J0IHR5cGUgeyBDb250ZXh0T2YsIFNwbGl0VW5kZWZpbmVkIH0gZnJvbSBcIi4vY29udGV4dFwiO1xuXG5leHBvcnQgdHlwZSBFbmNvZGVPcHRpb25zPENvbnRleHRUeXBlID0gdW5kZWZpbmVkPiA9IFBhcnRpYWw8XG4gIFJlYWRvbmx5PHtcbiAgICBleHRlbnNpb25Db2RlYzogRXh0ZW5zaW9uQ29kZWNUeXBlPENvbnRleHRUeXBlPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIGRlcHRoIGluIG5lc3RlZCBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byAxMDAuXG4gICAgICovXG4gICAgbWF4RGVwdGg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbml0aWFsIHNpemUgb2YgdGhlIGludGVybmFsIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIDIwNDguXG4gICAgICovXG4gICAgaW5pdGlhbEJ1ZmZlclNpemU6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgdGhlIGtleXMgb2YgYW4gb2JqZWN0IGlzIHNvcnRlZC4gSW4gb3RoZXIgd29yZHMsIHRoZSBlbmNvZGVkXG4gICAgICogYmluYXJ5IGlzIGNhbm9uaWNhbCBhbmQgdGh1cyBjb21wYXJhYmxlIHRvIGFub3RoZXIgZW5jb2RlZCBiaW5hcnkuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLiBJZiBlbmFibGVkLCBpdCBzcGVuZHMgbW9yZSB0aW1lIGluIGVuY29kaW5nIG9iamVjdHMuXG4gICAgICovXG4gICAgc29ydEtleXM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCBub24taW50ZWdlciBudW1iZXJzIGFyZSBlbmNvZGVkIGluIGZsb2F0MzIsIG5vdCBpbiBmbG9hdDY0ICh0aGUgZGVmYXVsdCkuXG4gICAgICpcbiAgICAgKiBPbmx5IHVzZSBpdCBpZiBwcmVjaXNpb25zIGRvbid0IG1hdHRlci5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICovXG4gICAgZm9yY2VGbG9hdDMyOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCBhbiBvYmplY3QgcHJvcGVydHkgd2l0aCBgdW5kZWZpbmVkYCB2YWx1ZSBhcmUgaWdub3JlZC5cbiAgICAgKiBlLmcuIGB7IGZvbzogdW5kZWZpbmVkIH1gIHdpbGwgYmUgZW5jb2RlZCBhcyBge31gLCBhcyBgSlNPTi5zdHJpbmdpZnkoKWAgZG9lcy5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuIElmIGVuYWJsZWQsIGl0IHNwZW5kcyBtb3JlIHRpbWUgaW4gZW5jb2Rpbmcgb2JqZWN0cy5cbiAgICAgKi9cbiAgICBpZ25vcmVVbmRlZmluZWQ6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIGludGVnZXIgbnVtYmVycyBhcmUgZW5jb2RlZCBhcyBmbG9hdGluZyBwb2ludCBudW1iZXJzLFxuICAgICAqIHdpdGggdGhlIGBmb3JjZUZsb2F0MzJgIG9wdGlvbiB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZvcmNlSW50ZWdlclRvRmxvYXQ6IGJvb2xlYW47XG4gIH0+XG4+ICZcbiAgQ29udGV4dE9mPENvbnRleHRUeXBlPjtcblxuY29uc3QgZGVmYXVsdEVuY29kZU9wdGlvbnM6IEVuY29kZU9wdGlvbnMgPSB7fTtcblxuLyoqXG4gKiBJdCBlbmNvZGVzIGB2YWx1ZWAgaW4gdGhlIE1lc3NhZ2VQYWNrIGZvcm1hdCBhbmRcbiAqIHJldHVybnMgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgYnVmZmVyIGlzIGEgc2xpY2Ugb2YgYSBsYXJnZXIgYEFycmF5QnVmZmVyYCwgc28geW91IGhhdmUgdG8gdXNlIGl0cyBgI2J5dGVPZmZzZXRgIGFuZCBgI2J5dGVMZW5ndGhgIGluIG9yZGVyIHRvIGNvbnZlcnQgaXQgdG8gYW5vdGhlciB0eXBlZCBhcnJheXMgaW5jbHVkaW5nIE5vZGVKUyBgQnVmZmVyYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZTxDb250ZXh0VHlwZSA9IHVuZGVmaW5lZD4oXG4gIHZhbHVlOiB1bmtub3duLFxuICBvcHRpb25zOiBFbmNvZGVPcHRpb25zPFNwbGl0VW5kZWZpbmVkPENvbnRleHRUeXBlPj4gPSBkZWZhdWx0RW5jb2RlT3B0aW9ucyBhcyBhbnksXG4pOiBVaW50OEFycmF5IHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBFbmNvZGVyKFxuICAgIG9wdGlvbnMuZXh0ZW5zaW9uQ29kZWMsXG4gICAgKG9wdGlvbnMgYXMgdHlwZW9mIG9wdGlvbnMgJiB7IGNvbnRleHQ6IGFueSB9KS5jb250ZXh0LFxuICAgIG9wdGlvbnMubWF4RGVwdGgsXG4gICAgb3B0aW9ucy5pbml0aWFsQnVmZmVyU2l6ZSxcbiAgICBvcHRpb25zLnNvcnRLZXlzLFxuICAgIG9wdGlvbnMuZm9yY2VGbG9hdDMyLFxuICAgIG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkLFxuICAgIG9wdGlvbnMuZm9yY2VJbnRlZ2VyVG9GbG9hdCxcbiAgKTtcbiAgcmV0dXJuIGVuY29kZXIuZW5jb2RlU2hhcmVkUmVmKHZhbHVlKTtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gcHJldHR5Qnl0ZShieXRlOiBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gYCR7Ynl0ZSA8IDAgPyBcIi1cIiA6IFwiXCJ9MHgke01hdGguYWJzKGJ5dGUpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIil9YDtcbn1cbiIsICJpbXBvcnQgeyB1dGY4RGVjb2RlSnMgfSBmcm9tIFwiLi91dGlscy91dGY4XCI7XG5cbmNvbnN0IERFRkFVTFRfTUFYX0tFWV9MRU5HVEggPSAxNjtcbmNvbnN0IERFRkFVTFRfTUFYX0xFTkdUSF9QRVJfS0VZID0gMTY7XG5cbmV4cG9ydCBpbnRlcmZhY2UgS2V5RGVjb2RlciB7XG4gIGNhbkJlQ2FjaGVkKGJ5dGVMZW5ndGg6IG51bWJlcik6IGJvb2xlYW47XG4gIGRlY29kZShieXRlczogVWludDhBcnJheSwgaW5wdXRPZmZzZXQ6IG51bWJlciwgYnl0ZUxlbmd0aDogbnVtYmVyKTogc3RyaW5nO1xufVxuaW50ZXJmYWNlIEtleUNhY2hlUmVjb3JkIHtcbiAgcmVhZG9ubHkgYnl0ZXM6IFVpbnQ4QXJyYXk7XG4gIHJlYWRvbmx5IHN0cjogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ2FjaGVkS2V5RGVjb2RlciBpbXBsZW1lbnRzIEtleURlY29kZXIge1xuICBoaXQgPSAwO1xuICBtaXNzID0gMDtcbiAgcHJpdmF0ZSByZWFkb25seSBjYWNoZXM6IEFycmF5PEFycmF5PEtleUNhY2hlUmVjb3JkPj47XG5cbiAgY29uc3RydWN0b3IocmVhZG9ubHkgbWF4S2V5TGVuZ3RoID0gREVGQVVMVF9NQVhfS0VZX0xFTkdUSCwgcmVhZG9ubHkgbWF4TGVuZ3RoUGVyS2V5ID0gREVGQVVMVF9NQVhfTEVOR1RIX1BFUl9LRVkpIHtcbiAgICAvLyBhdm9pZCBgbmV3IEFycmF5KE4pYCwgd2hpY2ggbWFrZXMgYSBzcGFyc2UgYXJyYXksXG4gICAgLy8gYmVjYXVzZSBhIHNwYXJzZSBhcnJheSBpcyB0eXBpY2FsbHkgc2xvd2VyIHRoYW4gYSBub24tc3BhcnNlIGFycmF5LlxuICAgIHRoaXMuY2FjaGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1heEtleUxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmNhY2hlcy5wdXNoKFtdKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY2FuQmVDYWNoZWQoYnl0ZUxlbmd0aDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGJ5dGVMZW5ndGggPiAwICYmIGJ5dGVMZW5ndGggPD0gdGhpcy5tYXhLZXlMZW5ndGg7XG4gIH1cblxuICBwcml2YXRlIGZpbmQoYnl0ZXM6IFVpbnQ4QXJyYXksIGlucHV0T2Zmc2V0OiBudW1iZXIsIGJ5dGVMZW5ndGg6IG51bWJlcik6IHN0cmluZyB8IG51bGwge1xuICAgIGNvbnN0IHJlY29yZHMgPSB0aGlzLmNhY2hlc1tieXRlTGVuZ3RoIC0gMV0hO1xuXG4gICAgRklORF9DSFVOSzogZm9yIChjb25zdCByZWNvcmQgb2YgcmVjb3Jkcykge1xuICAgICAgY29uc3QgcmVjb3JkQnl0ZXMgPSByZWNvcmQuYnl0ZXM7XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYnl0ZUxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWNvcmRCeXRlc1tqXSAhPT0gYnl0ZXNbaW5wdXRPZmZzZXQgKyBqXSkge1xuICAgICAgICAgIGNvbnRpbnVlIEZJTkRfQ0hVTks7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZWNvcmQuc3RyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgc3RvcmUoYnl0ZXM6IFVpbnQ4QXJyYXksIHZhbHVlOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZWNvcmRzID0gdGhpcy5jYWNoZXNbYnl0ZXMubGVuZ3RoIC0gMV0hO1xuICAgIGNvbnN0IHJlY29yZDogS2V5Q2FjaGVSZWNvcmQgPSB7IGJ5dGVzLCBzdHI6IHZhbHVlIH07XG5cbiAgICBpZiAocmVjb3Jkcy5sZW5ndGggPj0gdGhpcy5tYXhMZW5ndGhQZXJLZXkpIHtcbiAgICAgIC8vIGByZWNvcmRzYCBhcmUgZnVsbCFcbiAgICAgIC8vIFNldCBgcmVjb3JkYCB0byBhbiBhcmJpdHJhcnkgcG9zaXRpb24uXG4gICAgICByZWNvcmRzWyhNYXRoLnJhbmRvbSgpICogcmVjb3Jkcy5sZW5ndGgpIHwgMF0gPSByZWNvcmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29yZHMucHVzaChyZWNvcmQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZWNvZGUoYnl0ZXM6IFVpbnQ4QXJyYXksIGlucHV0T2Zmc2V0OiBudW1iZXIsIGJ5dGVMZW5ndGg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgY29uc3QgY2FjaGVkVmFsdWUgPSB0aGlzLmZpbmQoYnl0ZXMsIGlucHV0T2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICBpZiAoY2FjaGVkVmFsdWUgIT0gbnVsbCkge1xuICAgICAgdGhpcy5oaXQrKztcbiAgICAgIHJldHVybiBjYWNoZWRWYWx1ZTtcbiAgICB9XG4gICAgdGhpcy5taXNzKys7XG5cbiAgICBjb25zdCBzdHIgPSB1dGY4RGVjb2RlSnMoYnl0ZXMsIGlucHV0T2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAvLyBFbnN1cmUgdG8gY29weSBhIHNsaWNlIG9mIGJ5dGVzIGJlY2F1c2UgdGhlIGJ5dGUgbWF5IGJlIE5vZGVKUyBCdWZmZXIgYW5kIEJ1ZmZlciNzbGljZSgpIHJldHVybnMgYSByZWZlcmVuY2UgdG8gaXRzIGludGVybmFsIEFycmF5QnVmZmVyLlxuICAgIGNvbnN0IHNsaWNlZENvcHlPZkJ5dGVzID0gVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcywgaW5wdXRPZmZzZXQsIGlucHV0T2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG4gICAgdGhpcy5zdG9yZShzbGljZWRDb3B5T2ZCeXRlcywgc3RyKTtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgcHJldHR5Qnl0ZSB9IGZyb20gXCIuL3V0aWxzL3ByZXR0eUJ5dGVcIjtcbmltcG9ydCB7IEV4dGVuc2lvbkNvZGVjLCBFeHRlbnNpb25Db2RlY1R5cGUgfSBmcm9tIFwiLi9FeHRlbnNpb25Db2RlY1wiO1xuaW1wb3J0IHsgZ2V0SW50NjQsIGdldFVpbnQ2NCwgVUlOVDMyX01BWCB9IGZyb20gXCIuL3V0aWxzL2ludFwiO1xuaW1wb3J0IHsgdXRmOERlY29kZUpzLCBURVhUX0RFQ09ERVJfVEhSRVNIT0xELCB1dGY4RGVjb2RlVEQgfSBmcm9tIFwiLi91dGlscy91dGY4XCI7XG5pbXBvcnQgeyBjcmVhdGVEYXRhVmlldywgZW5zdXJlVWludDhBcnJheSB9IGZyb20gXCIuL3V0aWxzL3R5cGVkQXJyYXlzXCI7XG5pbXBvcnQgeyBDYWNoZWRLZXlEZWNvZGVyLCBLZXlEZWNvZGVyIH0gZnJvbSBcIi4vQ2FjaGVkS2V5RGVjb2RlclwiO1xuaW1wb3J0IHsgRGVjb2RlRXJyb3IgfSBmcm9tIFwiLi9EZWNvZGVFcnJvclwiO1xuXG5jb25zdCBlbnVtIFN0YXRlIHtcbiAgQVJSQVksXG4gIE1BUF9LRVksXG4gIE1BUF9WQUxVRSxcbn1cblxudHlwZSBNYXBLZXlUeXBlID0gc3RyaW5nIHwgbnVtYmVyO1xuXG5jb25zdCBpc1ZhbGlkTWFwS2V5VHlwZSA9IChrZXk6IHVua25vd24pOiBrZXkgaXMgTWFwS2V5VHlwZSA9PiB7XG4gIGNvbnN0IGtleVR5cGUgPSB0eXBlb2Yga2V5O1xuXG4gIHJldHVybiBrZXlUeXBlID09PSBcInN0cmluZ1wiIHx8IGtleVR5cGUgPT09IFwibnVtYmVyXCI7XG59O1xuXG50eXBlIFN0YWNrTWFwU3RhdGUgPSB7XG4gIHR5cGU6IFN0YXRlLk1BUF9LRVkgfCBTdGF0ZS5NQVBfVkFMVUU7XG4gIHNpemU6IG51bWJlcjtcbiAga2V5OiBNYXBLZXlUeXBlIHwgbnVsbDtcbiAgcmVhZENvdW50OiBudW1iZXI7XG4gIG1hcDogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG59O1xuXG50eXBlIFN0YWNrQXJyYXlTdGF0ZSA9IHtcbiAgdHlwZTogU3RhdGUuQVJSQVk7XG4gIHNpemU6IG51bWJlcjtcbiAgYXJyYXk6IEFycmF5PHVua25vd24+O1xuICBwb3NpdGlvbjogbnVtYmVyO1xufTtcblxudHlwZSBTdGFja1N0YXRlID0gU3RhY2tBcnJheVN0YXRlIHwgU3RhY2tNYXBTdGF0ZTtcblxuY29uc3QgSEVBRF9CWVRFX1JFUVVJUkVEID0gLTE7XG5cbmNvbnN0IEVNUFRZX1ZJRVcgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKTtcbmNvbnN0IEVNUFRZX0JZVEVTID0gbmV3IFVpbnQ4QXJyYXkoRU1QVFlfVklFVy5idWZmZXIpO1xuXG4vLyBJRTExOiBIYWNrIHRvIHN1cHBvcnQgSUUxMS5cbi8vIElFMTE6IERyb3AgdGhpcyBoYWNrIGFuZCBqdXN0IHVzZSBSYW5nZUVycm9yIHdoZW4gSUUxMSBpcyBvYnNvbGV0ZS5cbmV4cG9ydCBjb25zdCBEYXRhVmlld0luZGV4T3V0T2ZCb3VuZHNFcnJvcjogdHlwZW9mIEVycm9yID0gKCgpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBJRTExOiBUaGUgc3BlYyBzYXlzIGl0IHNob3VsZCB0aHJvdyBSYW5nZUVycm9yLFxuICAgIC8vIElFMTE6IGJ1dCBpbiBJRTExIGl0IHRocm93cyBUeXBlRXJyb3IuXG4gICAgRU1QVFlfVklFVy5nZXRJbnQ4KDApO1xuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICByZXR1cm4gZS5jb25zdHJ1Y3RvcjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJuZXZlciByZWFjaGVkXCIpO1xufSkoKTtcblxuY29uc3QgTU9SRV9EQVRBID0gbmV3IERhdGFWaWV3SW5kZXhPdXRPZkJvdW5kc0Vycm9yKFwiSW5zdWZmaWNpZW50IGRhdGFcIik7XG5cbmNvbnN0IHNoYXJlZENhY2hlZEtleURlY29kZXIgPSBuZXcgQ2FjaGVkS2V5RGVjb2RlcigpO1xuXG5leHBvcnQgY2xhc3MgRGVjb2RlcjxDb250ZXh0VHlwZSA9IHVuZGVmaW5lZD4ge1xuICBwcml2YXRlIHRvdGFsUG9zID0gMDtcbiAgcHJpdmF0ZSBwb3MgPSAwO1xuXG4gIHByaXZhdGUgdmlldyA9IEVNUFRZX1ZJRVc7XG4gIHByaXZhdGUgYnl0ZXMgPSBFTVBUWV9CWVRFUztcbiAgcHJpdmF0ZSBoZWFkQnl0ZSA9IEhFQURfQllURV9SRVFVSVJFRDtcbiAgcHJpdmF0ZSByZWFkb25seSBzdGFjazogQXJyYXk8U3RhY2tTdGF0ZT4gPSBbXTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBleHRlbnNpb25Db2RlYzogRXh0ZW5zaW9uQ29kZWNUeXBlPENvbnRleHRUeXBlPiA9IEV4dGVuc2lvbkNvZGVjLmRlZmF1bHRDb2RlYyBhcyBhbnksXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb250ZXh0OiBDb250ZXh0VHlwZSA9IHVuZGVmaW5lZCBhcyBhbnksXG4gICAgcHJpdmF0ZSByZWFkb25seSBtYXhTdHJMZW5ndGggPSBVSU5UMzJfTUFYLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbWF4QmluTGVuZ3RoID0gVUlOVDMyX01BWCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1heEFycmF5TGVuZ3RoID0gVUlOVDMyX01BWCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1heE1hcExlbmd0aCA9IFVJTlQzMl9NQVgsXG4gICAgcHJpdmF0ZSByZWFkb25seSBtYXhFeHRMZW5ndGggPSBVSU5UMzJfTUFYLFxuICAgIHByaXZhdGUgcmVhZG9ubHkga2V5RGVjb2RlcjogS2V5RGVjb2RlciB8IG51bGwgPSBzaGFyZWRDYWNoZWRLZXlEZWNvZGVyLFxuICApIHt9XG5cbiAgcHJpdmF0ZSByZWluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0aGlzLnRvdGFsUG9zID0gMDtcbiAgICB0aGlzLmhlYWRCeXRlID0gSEVBRF9CWVRFX1JFUVVJUkVEO1xuICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcblxuICAgIC8vIHZpZXcsIGJ5dGVzLCBhbmQgcG9zIHdpbGwgYmUgcmUtaW5pdGlhbGl6ZWQgaW4gc2V0QnVmZmVyKClcbiAgfVxuXG4gIHByaXZhdGUgc2V0QnVmZmVyKGJ1ZmZlcjogQXJyYXlMaWtlPG51bWJlcj4gfCBCdWZmZXJTb3VyY2UpOiB2b2lkIHtcbiAgICB0aGlzLmJ5dGVzID0gZW5zdXJlVWludDhBcnJheShidWZmZXIpO1xuICAgIHRoaXMudmlldyA9IGNyZWF0ZURhdGFWaWV3KHRoaXMuYnl0ZXMpO1xuICAgIHRoaXMucG9zID0gMDtcbiAgfVxuXG4gIHByaXZhdGUgYXBwZW5kQnVmZmVyKGJ1ZmZlcjogQXJyYXlMaWtlPG51bWJlcj4gfCBCdWZmZXJTb3VyY2UpIHtcbiAgICBpZiAodGhpcy5oZWFkQnl0ZSA9PT0gSEVBRF9CWVRFX1JFUVVJUkVEICYmICF0aGlzLmhhc1JlbWFpbmluZygxKSkge1xuICAgICAgdGhpcy5zZXRCdWZmZXIoYnVmZmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVtYWluaW5nRGF0YSA9IHRoaXMuYnl0ZXMuc3ViYXJyYXkodGhpcy5wb3MpO1xuICAgICAgY29uc3QgbmV3RGF0YSA9IGVuc3VyZVVpbnQ4QXJyYXkoYnVmZmVyKTtcblxuICAgICAgLy8gY29uY2F0IHJlbWFpbmluZ0RhdGEgKyBuZXdEYXRhXG4gICAgICBjb25zdCBuZXdCdWZmZXIgPSBuZXcgVWludDhBcnJheShyZW1haW5pbmdEYXRhLmxlbmd0aCArIG5ld0RhdGEubGVuZ3RoKTtcbiAgICAgIG5ld0J1ZmZlci5zZXQocmVtYWluaW5nRGF0YSk7XG4gICAgICBuZXdCdWZmZXIuc2V0KG5ld0RhdGEsIHJlbWFpbmluZ0RhdGEubGVuZ3RoKTtcbiAgICAgIHRoaXMuc2V0QnVmZmVyKG5ld0J1ZmZlcik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYXNSZW1haW5pbmcoc2l6ZTogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5ieXRlTGVuZ3RoIC0gdGhpcy5wb3MgPj0gc2l6ZTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRXh0cmFCeXRlRXJyb3IocG9zVG9TaG93OiBudW1iZXIpOiBFcnJvciB7XG4gICAgY29uc3QgeyB2aWV3LCBwb3MgfSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKGBFeHRyYSAke3ZpZXcuYnl0ZUxlbmd0aCAtIHBvc30gb2YgJHt2aWV3LmJ5dGVMZW5ndGh9IGJ5dGUocykgZm91bmQgYXQgYnVmZmVyWyR7cG9zVG9TaG93fV1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhyb3dzIHtAbGluayBEZWNvZGVFcnJvcn1cbiAgICogQHRocm93cyB7QGxpbmsgUmFuZ2VFcnJvcn1cbiAgICovXG4gIHB1YmxpYyBkZWNvZGUoYnVmZmVyOiBBcnJheUxpa2U8bnVtYmVyPiB8IEJ1ZmZlclNvdXJjZSk6IHVua25vd24ge1xuICAgIHRoaXMucmVpbml0aWFsaXplU3RhdGUoKTtcbiAgICB0aGlzLnNldEJ1ZmZlcihidWZmZXIpO1xuXG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy5kb0RlY29kZVN5bmMoKTtcbiAgICBpZiAodGhpcy5oYXNSZW1haW5pbmcoMSkpIHtcbiAgICAgIHRocm93IHRoaXMuY3JlYXRlRXh0cmFCeXRlRXJyb3IodGhpcy5wb3MpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgcHVibGljICpkZWNvZGVNdWx0aShidWZmZXI6IEFycmF5TGlrZTxudW1iZXI+IHwgQnVmZmVyU291cmNlKTogR2VuZXJhdG9yPHVua25vd24sIHZvaWQsIHVua25vd24+IHtcbiAgICB0aGlzLnJlaW5pdGlhbGl6ZVN0YXRlKCk7XG4gICAgdGhpcy5zZXRCdWZmZXIoYnVmZmVyKTtcblxuICAgIHdoaWxlICh0aGlzLmhhc1JlbWFpbmluZygxKSkge1xuICAgICAgeWllbGQgdGhpcy5kb0RlY29kZVN5bmMoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVjb2RlQXN5bmMoc3RyZWFtOiBBc3luY0l0ZXJhYmxlPEFycmF5TGlrZTxudW1iZXI+IHwgQnVmZmVyU291cmNlPik6IFByb21pc2U8dW5rbm93bj4ge1xuICAgIGxldCBkZWNvZGVkID0gZmFsc2U7XG4gICAgbGV0IG9iamVjdDogdW5rbm93bjtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGJ1ZmZlciBvZiBzdHJlYW0pIHtcbiAgICAgIGlmIChkZWNvZGVkKSB7XG4gICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXh0cmFCeXRlRXJyb3IodGhpcy50b3RhbFBvcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQnVmZmVyKGJ1ZmZlcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuZG9EZWNvZGVTeW5jKCk7XG4gICAgICAgIGRlY29kZWQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgRGF0YVZpZXdJbmRleE91dE9mQm91bmRzRXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZTsgLy8gcmV0aHJvd1xuICAgICAgICB9XG4gICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICB9XG4gICAgICB0aGlzLnRvdGFsUG9zICs9IHRoaXMucG9zO1xuICAgIH1cblxuICAgIGlmIChkZWNvZGVkKSB7XG4gICAgICBpZiAodGhpcy5oYXNSZW1haW5pbmcoMSkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFeHRyYUJ5dGVFcnJvcih0aGlzLnRvdGFsUG9zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgY29uc3QgeyBoZWFkQnl0ZSwgcG9zLCB0b3RhbFBvcyB9ID0gdGhpcztcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgIGBJbnN1ZmZpY2llbnQgZGF0YSBpbiBwYXJzaW5nICR7cHJldHR5Qnl0ZShoZWFkQnl0ZSl9IGF0ICR7dG90YWxQb3N9ICgke3Bvc30gaW4gdGhlIGN1cnJlbnQgYnVmZmVyKWAsXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBkZWNvZGVBcnJheVN0cmVhbShcbiAgICBzdHJlYW06IEFzeW5jSXRlcmFibGU8QXJyYXlMaWtlPG51bWJlcj4gfCBCdWZmZXJTb3VyY2U+LFxuICApOiBBc3luY0dlbmVyYXRvcjx1bmtub3duLCB2b2lkLCB1bmtub3duPiB7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlTXVsdGlBc3luYyhzdHJlYW0sIHRydWUpO1xuICB9XG5cbiAgcHVibGljIGRlY29kZVN0cmVhbShzdHJlYW06IEFzeW5jSXRlcmFibGU8QXJyYXlMaWtlPG51bWJlcj4gfCBCdWZmZXJTb3VyY2U+KTogQXN5bmNHZW5lcmF0b3I8dW5rbm93biwgdm9pZCwgdW5rbm93bj4ge1xuICAgIHJldHVybiB0aGlzLmRlY29kZU11bHRpQXN5bmMoc3RyZWFtLCBmYWxzZSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jICpkZWNvZGVNdWx0aUFzeW5jKHN0cmVhbTogQXN5bmNJdGVyYWJsZTxBcnJheUxpa2U8bnVtYmVyPiB8IEJ1ZmZlclNvdXJjZT4sIGlzQXJyYXk6IGJvb2xlYW4pIHtcbiAgICBsZXQgaXNBcnJheUhlYWRlclJlcXVpcmVkID0gaXNBcnJheTtcbiAgICBsZXQgYXJyYXlJdGVtc0xlZnQgPSAtMTtcblxuICAgIGZvciBhd2FpdCAoY29uc3QgYnVmZmVyIG9mIHN0cmVhbSkge1xuICAgICAgaWYgKGlzQXJyYXkgJiYgYXJyYXlJdGVtc0xlZnQgPT09IDApIHtcbiAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFeHRyYUJ5dGVFcnJvcih0aGlzLnRvdGFsUG9zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcHBlbmRCdWZmZXIoYnVmZmVyKTtcblxuICAgICAgaWYgKGlzQXJyYXlIZWFkZXJSZXF1aXJlZCkge1xuICAgICAgICBhcnJheUl0ZW1zTGVmdCA9IHRoaXMucmVhZEFycmF5U2l6ZSgpO1xuICAgICAgICBpc0FycmF5SGVhZGVyUmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuZG9EZWNvZGVTeW5jKCk7XG4gICAgICAgICAgaWYgKC0tYXJyYXlJdGVtc0xlZnQgPT09IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgRGF0YVZpZXdJbmRleE91dE9mQm91bmRzRXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZTsgLy8gcmV0aHJvd1xuICAgICAgICB9XG4gICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICB9XG4gICAgICB0aGlzLnRvdGFsUG9zICs9IHRoaXMucG9zO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZG9EZWNvZGVTeW5jKCk6IHVua25vd24ge1xuICAgIERFQ09ERTogd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGhlYWRCeXRlID0gdGhpcy5yZWFkSGVhZEJ5dGUoKTtcbiAgICAgIGxldCBvYmplY3Q6IHVua25vd247XG5cbiAgICAgIGlmIChoZWFkQnl0ZSA+PSAweGUwKSB7XG4gICAgICAgIC8vIG5lZ2F0aXZlIGZpeGludCAoMTExeCB4eHh4KSAweGUwIC0gMHhmZlxuICAgICAgICBvYmplY3QgPSBoZWFkQnl0ZSAtIDB4MTAwO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA8IDB4YzApIHtcbiAgICAgICAgaWYgKGhlYWRCeXRlIDwgMHg4MCkge1xuICAgICAgICAgIC8vIHBvc2l0aXZlIGZpeGludCAoMHh4eCB4eHh4KSAweDAwIC0gMHg3ZlxuICAgICAgICAgIG9iamVjdCA9IGhlYWRCeXRlO1xuICAgICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlIDwgMHg5MCkge1xuICAgICAgICAgIC8vIGZpeG1hcCAoMTAwMCB4eHh4KSAweDgwIC0gMHg4ZlxuICAgICAgICAgIGNvbnN0IHNpemUgPSBoZWFkQnl0ZSAtIDB4ODA7XG4gICAgICAgICAgaWYgKHNpemUgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHVzaE1hcFN0YXRlKHNpemUpO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgY29udGludWUgREVDT0RFO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmplY3QgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPCAweGEwKSB7XG4gICAgICAgICAgLy8gZml4YXJyYXkgKDEwMDEgeHh4eCkgMHg5MCAtIDB4OWZcbiAgICAgICAgICBjb25zdCBzaXplID0gaGVhZEJ5dGUgLSAweDkwO1xuICAgICAgICAgIGlmIChzaXplICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hBcnJheVN0YXRlKHNpemUpO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgY29udGludWUgREVDT0RFO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmplY3QgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZml4c3RyICgxMDF4IHh4eHgpIDB4YTAgLSAweGJmXG4gICAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGhlYWRCeXRlIC0gMHhhMDtcbiAgICAgICAgICBvYmplY3QgPSB0aGlzLmRlY29kZVV0ZjhTdHJpbmcoYnl0ZUxlbmd0aCwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4YzApIHtcbiAgICAgICAgLy8gbmlsXG4gICAgICAgIG9iamVjdCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGMyKSB7XG4gICAgICAgIC8vIGZhbHNlXG4gICAgICAgIG9iamVjdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhjMykge1xuICAgICAgICAvLyB0cnVlXG4gICAgICAgIG9iamVjdCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGNhKSB7XG4gICAgICAgIC8vIGZsb2F0IDMyXG4gICAgICAgIG9iamVjdCA9IHRoaXMucmVhZEYzMigpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhjYikge1xuICAgICAgICAvLyBmbG9hdCA2NFxuICAgICAgICBvYmplY3QgPSB0aGlzLnJlYWRGNjQoKTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4Y2MpIHtcbiAgICAgICAgLy8gdWludCA4XG4gICAgICAgIG9iamVjdCA9IHRoaXMucmVhZFU4KCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGNkKSB7XG4gICAgICAgIC8vIHVpbnQgMTZcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5yZWFkVTE2KCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGNlKSB7XG4gICAgICAgIC8vIHVpbnQgMzJcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5yZWFkVTMyKCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGNmKSB7XG4gICAgICAgIC8vIHVpbnQgNjRcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5yZWFkVTY0KCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGQwKSB7XG4gICAgICAgIC8vIGludCA4XG4gICAgICAgIG9iamVjdCA9IHRoaXMucmVhZEk4KCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGQxKSB7XG4gICAgICAgIC8vIGludCAxNlxuICAgICAgICBvYmplY3QgPSB0aGlzLnJlYWRJMTYoKTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4ZDIpIHtcbiAgICAgICAgLy8gaW50IDMyXG4gICAgICAgIG9iamVjdCA9IHRoaXMucmVhZEkzMigpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhkMykge1xuICAgICAgICAvLyBpbnQgNjRcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5yZWFkSTY0KCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGQ5KSB7XG4gICAgICAgIC8vIHN0ciA4XG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSB0aGlzLmxvb2tVOCgpO1xuICAgICAgICBvYmplY3QgPSB0aGlzLmRlY29kZVV0ZjhTdHJpbmcoYnl0ZUxlbmd0aCwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGRhKSB7XG4gICAgICAgIC8vIHN0ciAxNlxuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gdGhpcy5sb29rVTE2KCk7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuZGVjb2RlVXRmOFN0cmluZyhieXRlTGVuZ3RoLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4ZGIpIHtcbiAgICAgICAgLy8gc3RyIDMyXG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSB0aGlzLmxvb2tVMzIoKTtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5kZWNvZGVVdGY4U3RyaW5nKGJ5dGVMZW5ndGgsIDQpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhkYykge1xuICAgICAgICAvLyBhcnJheSAxNlxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5yZWFkVTE2KCk7XG4gICAgICAgIGlmIChzaXplICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5wdXNoQXJyYXlTdGF0ZShzaXplKTtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgY29udGludWUgREVDT0RFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iamVjdCA9IFtdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGRkKSB7XG4gICAgICAgIC8vIGFycmF5IDMyXG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnJlYWRVMzIoKTtcbiAgICAgICAgaWYgKHNpemUgIT09IDApIHtcbiAgICAgICAgICB0aGlzLnB1c2hBcnJheVN0YXRlKHNpemUpO1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgICBjb250aW51ZSBERUNPREU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqZWN0ID0gW107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4ZGUpIHtcbiAgICAgICAgLy8gbWFwIDE2XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnJlYWRVMTYoKTtcbiAgICAgICAgaWYgKHNpemUgIT09IDApIHtcbiAgICAgICAgICB0aGlzLnB1c2hNYXBTdGF0ZShzaXplKTtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgY29udGludWUgREVDT0RFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iamVjdCA9IHt9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGRmKSB7XG4gICAgICAgIC8vIG1hcCAzMlxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5yZWFkVTMyKCk7XG4gICAgICAgIGlmIChzaXplICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5wdXNoTWFwU3RhdGUoc2l6ZSk7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgICAgIGNvbnRpbnVlIERFQ09ERTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmplY3QgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhjNCkge1xuICAgICAgICAvLyBiaW4gOFxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5sb29rVTgoKTtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5kZWNvZGVCaW5hcnkoc2l6ZSwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGM1KSB7XG4gICAgICAgIC8vIGJpbiAxNlxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5sb29rVTE2KCk7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuZGVjb2RlQmluYXJ5KHNpemUsIDIpO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhjNikge1xuICAgICAgICAvLyBiaW4gMzJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMubG9va1UzMigpO1xuICAgICAgICBvYmplY3QgPSB0aGlzLmRlY29kZUJpbmFyeShzaXplLCA0KTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4ZDQpIHtcbiAgICAgICAgLy8gZml4ZXh0IDFcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5kZWNvZGVFeHRlbnNpb24oMSwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGQ1KSB7XG4gICAgICAgIC8vIGZpeGV4dCAyXG4gICAgICAgIG9iamVjdCA9IHRoaXMuZGVjb2RlRXh0ZW5zaW9uKDIsIDApO1xuICAgICAgfSBlbHNlIGlmIChoZWFkQnl0ZSA9PT0gMHhkNikge1xuICAgICAgICAvLyBmaXhleHQgNFxuICAgICAgICBvYmplY3QgPSB0aGlzLmRlY29kZUV4dGVuc2lvbig0LCAwKTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4ZDcpIHtcbiAgICAgICAgLy8gZml4ZXh0IDhcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5kZWNvZGVFeHRlbnNpb24oOCwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGQ4KSB7XG4gICAgICAgIC8vIGZpeGV4dCAxNlxuICAgICAgICBvYmplY3QgPSB0aGlzLmRlY29kZUV4dGVuc2lvbigxNiwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGM3KSB7XG4gICAgICAgIC8vIGV4dCA4XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmxvb2tVOCgpO1xuICAgICAgICBvYmplY3QgPSB0aGlzLmRlY29kZUV4dGVuc2lvbihzaXplLCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZEJ5dGUgPT09IDB4YzgpIHtcbiAgICAgICAgLy8gZXh0IDE2XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmxvb2tVMTYoKTtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5kZWNvZGVFeHRlbnNpb24oc2l6ZSwgMik7XG4gICAgICB9IGVsc2UgaWYgKGhlYWRCeXRlID09PSAweGM5KSB7XG4gICAgICAgIC8vIGV4dCAzMlxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5sb29rVTMyKCk7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuZGVjb2RlRXh0ZW5zaW9uKHNpemUsIDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IERlY29kZUVycm9yKGBVbnJlY29nbml6ZWQgdHlwZSBieXRlOiAke3ByZXR0eUJ5dGUoaGVhZEJ5dGUpfWApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbXBsZXRlKCk7XG5cbiAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5zdGFjaztcbiAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGFycmF5cyBhbmQgbWFwc1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdITtcbiAgICAgICAgaWYgKHN0YXRlLnR5cGUgPT09IFN0YXRlLkFSUkFZKSB7XG4gICAgICAgICAgc3RhdGUuYXJyYXlbc3RhdGUucG9zaXRpb25dID0gb2JqZWN0O1xuICAgICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICAgICAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5zaXplKSB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIG9iamVjdCA9IHN0YXRlLmFycmF5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250aW51ZSBERUNPREU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLnR5cGUgPT09IFN0YXRlLk1BUF9LRVkpIHtcbiAgICAgICAgICBpZiAoIWlzVmFsaWRNYXBLZXlUeXBlKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEZWNvZGVFcnJvcihcIlRoZSB0eXBlIG9mIGtleSBtdXN0IGJlIHN0cmluZyBvciBudW1iZXIgYnV0IFwiICsgdHlwZW9mIG9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QgPT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEZWNvZGVFcnJvcihcIlRoZSBrZXkgX19wcm90b19fIGlzIG5vdCBhbGxvd2VkXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXRlLmtleSA9IG9iamVjdDtcbiAgICAgICAgICBzdGF0ZS50eXBlID0gU3RhdGUuTUFQX1ZBTFVFO1xuICAgICAgICAgIGNvbnRpbnVlIERFQ09ERTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpdCBtdXN0IGJlIGBzdGF0ZS50eXBlID09PSBTdGF0ZS5NQVBfVkFMVUVgIGhlcmVcblxuICAgICAgICAgIHN0YXRlLm1hcFtzdGF0ZS5rZXkhXSA9IG9iamVjdDtcbiAgICAgICAgICBzdGF0ZS5yZWFkQ291bnQrKztcblxuICAgICAgICAgIGlmIChzdGF0ZS5yZWFkQ291bnQgPT09IHN0YXRlLnNpemUpIHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgb2JqZWN0ID0gc3RhdGUubWFwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5rZXkgPSBudWxsO1xuICAgICAgICAgICAgc3RhdGUudHlwZSA9IFN0YXRlLk1BUF9LRVk7XG4gICAgICAgICAgICBjb250aW51ZSBERUNPREU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZWFkSGVhZEJ5dGUoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5oZWFkQnl0ZSA9PT0gSEVBRF9CWVRFX1JFUVVJUkVEKSB7XG4gICAgICB0aGlzLmhlYWRCeXRlID0gdGhpcy5yZWFkVTgoKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiaGVhZEJ5dGVcIiwgcHJldHR5Qnl0ZSh0aGlzLmhlYWRCeXRlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaGVhZEJ5dGU7XG4gIH1cblxuICBwcml2YXRlIGNvbXBsZXRlKCk6IHZvaWQge1xuICAgIHRoaXMuaGVhZEJ5dGUgPSBIRUFEX0JZVEVfUkVRVUlSRUQ7XG4gIH1cblxuICBwcml2YXRlIHJlYWRBcnJheVNpemUoKTogbnVtYmVyIHtcbiAgICBjb25zdCBoZWFkQnl0ZSA9IHRoaXMucmVhZEhlYWRCeXRlKCk7XG5cbiAgICBzd2l0Y2ggKGhlYWRCeXRlKSB7XG4gICAgICBjYXNlIDB4ZGM6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRVMTYoKTtcbiAgICAgIGNhc2UgMHhkZDpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFUzMigpO1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAoaGVhZEJ5dGUgPCAweGEwKSB7XG4gICAgICAgICAgcmV0dXJuIGhlYWRCeXRlIC0gMHg5MDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRGVjb2RlRXJyb3IoYFVucmVjb2duaXplZCBhcnJheSB0eXBlIGJ5dGU6ICR7cHJldHR5Qnl0ZShoZWFkQnl0ZSl9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHB1c2hNYXBTdGF0ZShzaXplOiBudW1iZXIpIHtcbiAgICBpZiAoc2l6ZSA+IHRoaXMubWF4TWFwTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRGVjb2RlRXJyb3IoYE1heCBsZW5ndGggZXhjZWVkZWQ6IG1hcCBsZW5ndGggKCR7c2l6ZX0pID4gbWF4TWFwTGVuZ3RoTGVuZ3RoICgke3RoaXMubWF4TWFwTGVuZ3RofSlgKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgdHlwZTogU3RhdGUuTUFQX0tFWSxcbiAgICAgIHNpemUsXG4gICAgICBrZXk6IG51bGwsXG4gICAgICByZWFkQ291bnQ6IDAsXG4gICAgICBtYXA6IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBwdXNoQXJyYXlTdGF0ZShzaXplOiBudW1iZXIpIHtcbiAgICBpZiAoc2l6ZSA+IHRoaXMubWF4QXJyYXlMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBEZWNvZGVFcnJvcihgTWF4IGxlbmd0aCBleGNlZWRlZDogYXJyYXkgbGVuZ3RoICgke3NpemV9KSA+IG1heEFycmF5TGVuZ3RoICgke3RoaXMubWF4QXJyYXlMZW5ndGh9KWApO1xuICAgIH1cblxuICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICB0eXBlOiBTdGF0ZS5BUlJBWSxcbiAgICAgIHNpemUsXG4gICAgICBhcnJheTogbmV3IEFycmF5PHVua25vd24+KHNpemUpLFxuICAgICAgcG9zaXRpb246IDAsXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGRlY29kZVV0ZjhTdHJpbmcoYnl0ZUxlbmd0aDogbnVtYmVyLCBoZWFkZXJPZmZzZXQ6IG51bWJlcik6IHN0cmluZyB7XG4gICAgaWYgKGJ5dGVMZW5ndGggPiB0aGlzLm1heFN0ckxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IERlY29kZUVycm9yKFxuICAgICAgICBgTWF4IGxlbmd0aCBleGNlZWRlZDogVVRGLTggYnl0ZSBsZW5ndGggKCR7Ynl0ZUxlbmd0aH0pID4gbWF4U3RyTGVuZ3RoICgke3RoaXMubWF4U3RyTGVuZ3RofSlgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ieXRlcy5ieXRlTGVuZ3RoIDwgdGhpcy5wb3MgKyBoZWFkZXJPZmZzZXQgKyBieXRlTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBNT1JFX0RBVEE7XG4gICAgfVxuXG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5wb3MgKyBoZWFkZXJPZmZzZXQ7XG4gICAgbGV0IG9iamVjdDogc3RyaW5nO1xuICAgIGlmICh0aGlzLnN0YXRlSXNNYXBLZXkoKSAmJiB0aGlzLmtleURlY29kZXI/LmNhbkJlQ2FjaGVkKGJ5dGVMZW5ndGgpKSB7XG4gICAgICBvYmplY3QgPSB0aGlzLmtleURlY29kZXIuZGVjb2RlKHRoaXMuYnl0ZXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChieXRlTGVuZ3RoID4gVEVYVF9ERUNPREVSX1RIUkVTSE9MRCkge1xuICAgICAgb2JqZWN0ID0gdXRmOERlY29kZVREKHRoaXMuYnl0ZXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdCA9IHV0ZjhEZWNvZGVKcyh0aGlzLmJ5dGVzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICB0aGlzLnBvcyArPSBoZWFkZXJPZmZzZXQgKyBieXRlTGVuZ3RoO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICBwcml2YXRlIHN0YXRlSXNNYXBLZXkoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0hO1xuICAgICAgcmV0dXJuIHN0YXRlLnR5cGUgPT09IFN0YXRlLk1BUF9LRVk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgZGVjb2RlQmluYXJ5KGJ5dGVMZW5ndGg6IG51bWJlciwgaGVhZE9mZnNldDogbnVtYmVyKTogVWludDhBcnJheSB7XG4gICAgaWYgKGJ5dGVMZW5ndGggPiB0aGlzLm1heEJpbkxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IERlY29kZUVycm9yKGBNYXggbGVuZ3RoIGV4Y2VlZGVkOiBiaW4gbGVuZ3RoICgke2J5dGVMZW5ndGh9KSA+IG1heEJpbkxlbmd0aCAoJHt0aGlzLm1heEJpbkxlbmd0aH0pYCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmhhc1JlbWFpbmluZyhieXRlTGVuZ3RoICsgaGVhZE9mZnNldCkpIHtcbiAgICAgIHRocm93IE1PUkVfREFUQTtcbiAgICB9XG5cbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLnBvcyArIGhlYWRPZmZzZXQ7XG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy5ieXRlcy5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGJ5dGVMZW5ndGgpO1xuICAgIHRoaXMucG9zICs9IGhlYWRPZmZzZXQgKyBieXRlTGVuZ3RoO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICBwcml2YXRlIGRlY29kZUV4dGVuc2lvbihzaXplOiBudW1iZXIsIGhlYWRPZmZzZXQ6IG51bWJlcik6IHVua25vd24ge1xuICAgIGlmIChzaXplID4gdGhpcy5tYXhFeHRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBEZWNvZGVFcnJvcihgTWF4IGxlbmd0aCBleGNlZWRlZDogZXh0IGxlbmd0aCAoJHtzaXplfSkgPiBtYXhFeHRMZW5ndGggKCR7dGhpcy5tYXhFeHRMZW5ndGh9KWApO1xuICAgIH1cblxuICAgIGNvbnN0IGV4dFR5cGUgPSB0aGlzLnZpZXcuZ2V0SW50OCh0aGlzLnBvcyArIGhlYWRPZmZzZXQpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRlY29kZUJpbmFyeShzaXplLCBoZWFkT2Zmc2V0ICsgMSAvKiBleHRUeXBlICovKTtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb25Db2RlYy5kZWNvZGUoZGF0YSwgZXh0VHlwZSwgdGhpcy5jb250ZXh0KTtcbiAgfVxuXG4gIHByaXZhdGUgbG9va1U4KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3MpO1xuICB9XG5cbiAgcHJpdmF0ZSBsb29rVTE2KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMucG9zKTtcbiAgfVxuXG4gIHByaXZhdGUgbG9va1UzMigpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLnBvcyk7XG4gIH1cblxuICBwcml2YXRlIHJlYWRVOCgpOiBudW1iZXIge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcysrO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZEk4KCk6IG51bWJlciB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50OCh0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MrKztcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIHJlYWRVMTYoKTogbnVtYmVyIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDI7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkSTE2KCk6IG51bWJlciB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50MTYodGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDI7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkVTMyKCk6IG51bWJlciB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZEkzMigpOiBudW1iZXIge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy52aWV3LmdldEludDMyKHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZFU2NCgpOiBudW1iZXIge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludDY0KHRoaXMudmlldywgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkSTY0KCk6IG51bWJlciB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRJbnQ2NCh0aGlzLnZpZXcsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZEYzMigpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmlldy5nZXRGbG9hdDMyKHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZEY2NCgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmlldy5nZXRGbG9hdDY0KHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuIiwgImltcG9ydCB7IERlY29kZXIgfSBmcm9tIFwiLi9EZWNvZGVyXCI7XG5pbXBvcnQgdHlwZSB7IEV4dGVuc2lvbkNvZGVjVHlwZSB9IGZyb20gXCIuL0V4dGVuc2lvbkNvZGVjXCI7XG5pbXBvcnQgdHlwZSB7IENvbnRleHRPZiwgU3BsaXRVbmRlZmluZWQgfSBmcm9tIFwiLi9jb250ZXh0XCI7XG5cbmV4cG9ydCB0eXBlIERlY29kZU9wdGlvbnM8Q29udGV4dFR5cGUgPSB1bmRlZmluZWQ+ID0gUmVhZG9ubHk8XG4gIFBhcnRpYWw8e1xuICAgIGV4dGVuc2lvbkNvZGVjOiBFeHRlbnNpb25Db2RlY1R5cGU8Q29udGV4dFR5cGU+O1xuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqXG4gICAgICogRGVmYXVsdHMgdG8gNF8yOTRfOTY3XzI5NSAoVUlOVDMyX01BWCkuXG4gICAgICovXG4gICAgbWF4U3RyTGVuZ3RoOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogTWF4aW11bSBiaW5hcnkgbGVuZ3RoLlxuICAgICAqXG4gICAgICogRGVmYXVsdHMgdG8gNF8yOTRfOTY3XzI5NSAoVUlOVDMyX01BWCkuXG4gICAgICovXG4gICAgbWF4QmluTGVuZ3RoOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogTWF4aW11bSBhcnJheSBsZW5ndGguXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byA0XzI5NF85NjdfMjk1IChVSU5UMzJfTUFYKS5cbiAgICAgKi9cbiAgICBtYXhBcnJheUxlbmd0aDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIE1heGltdW0gbWFwIGxlbmd0aC5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIDRfMjk0Xzk2N18yOTUgKFVJTlQzMl9NQVgpLlxuICAgICAqL1xuICAgIG1heE1hcExlbmd0aDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIE1heGltdW0gZXh0ZW5zaW9uIGxlbmd0aC5cbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRvIDRfMjk0Xzk2N18yOTUgKFVJTlQzMl9NQVgpLlxuICAgICAqL1xuICAgIG1heEV4dExlbmd0aDogbnVtYmVyO1xuICB9PlxuPiAmXG4gIENvbnRleHRPZjxDb250ZXh0VHlwZT47XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0RGVjb2RlT3B0aW9uczogRGVjb2RlT3B0aW9ucyA9IHt9O1xuXG4vKipcbiAqIEl0IGRlY29kZXMgYSBzaW5nbGUgTWVzc2FnZVBhY2sgb2JqZWN0IGluIGEgYnVmZmVyLlxuICpcbiAqIFRoaXMgaXMgYSBzeW5jaHJvbm91cyBkZWNvZGluZyBmdW5jdGlvbi5cbiAqIFNlZSBvdGhlciB2YXJpYW50cyBmb3IgYXN5bmNocm9ub3VzIGRlY29kaW5nOiB7QGxpbmsgZGVjb2RlQXN5bmMoKX0sIHtAbGluayBkZWNvZGVTdHJlYW0oKX0sIG9yIHtAbGluayBkZWNvZGVBcnJheVN0cmVhbSgpfS5cbiAqXG4gKiBAdGhyb3dzIHtAbGluayBSYW5nZUVycm9yfSBpZiB0aGUgYnVmZmVyIGlzIGluY29tcGxldGUsIGluY2x1ZGluZyB0aGUgY2FzZSB3aGVyZSB0aGUgYnVmZmVyIGlzIGVtcHR5LlxuICogQHRocm93cyB7QGxpbmsgRGVjb2RlRXJyb3J9IGlmIHRoZSBidWZmZXIgY29udGFpbnMgaW52YWxpZCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlPENvbnRleHRUeXBlID0gdW5kZWZpbmVkPihcbiAgYnVmZmVyOiBBcnJheUxpa2U8bnVtYmVyPiB8IEJ1ZmZlclNvdXJjZSxcbiAgb3B0aW9uczogRGVjb2RlT3B0aW9uczxTcGxpdFVuZGVmaW5lZDxDb250ZXh0VHlwZT4+ID0gZGVmYXVsdERlY29kZU9wdGlvbnMgYXMgYW55LFxuKTogdW5rbm93biB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgRGVjb2RlcihcbiAgICBvcHRpb25zLmV4dGVuc2lvbkNvZGVjLFxuICAgIChvcHRpb25zIGFzIHR5cGVvZiBvcHRpb25zICYgeyBjb250ZXh0OiBhbnkgfSkuY29udGV4dCxcbiAgICBvcHRpb25zLm1heFN0ckxlbmd0aCxcbiAgICBvcHRpb25zLm1heEJpbkxlbmd0aCxcbiAgICBvcHRpb25zLm1heEFycmF5TGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4TWFwTGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4RXh0TGVuZ3RoLFxuICApO1xuICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoYnVmZmVyKTtcbn1cblxuLyoqXG4gKiBJdCBkZWNvZGVzIG11bHRpcGxlIE1lc3NhZ2VQYWNrIG9iamVjdHMgaW4gYSBidWZmZXIuXG4gKiBUaGlzIGlzIGNvcnJlc3BvbmRpbmcgdG8ge0BsaW5rIGRlY29kZU11bHRpU3RyZWFtKCl9LlxuICpcbiAqIEB0aHJvd3Mge0BsaW5rIFJhbmdlRXJyb3J9IGlmIHRoZSBidWZmZXIgaXMgaW5jb21wbGV0ZSwgaW5jbHVkaW5nIHRoZSBjYXNlIHdoZXJlIHRoZSBidWZmZXIgaXMgZW1wdHkuXG4gKiBAdGhyb3dzIHtAbGluayBEZWNvZGVFcnJvcn0gaWYgdGhlIGJ1ZmZlciBjb250YWlucyBpbnZhbGlkIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVNdWx0aTxDb250ZXh0VHlwZSA9IHVuZGVmaW5lZD4oXG4gIGJ1ZmZlcjogQXJyYXlMaWtlPG51bWJlcj4gfCBCdWZmZXJTb3VyY2UsXG4gIG9wdGlvbnM6IERlY29kZU9wdGlvbnM8U3BsaXRVbmRlZmluZWQ8Q29udGV4dFR5cGU+PiA9IGRlZmF1bHREZWNvZGVPcHRpb25zIGFzIGFueSxcbik6IEdlbmVyYXRvcjx1bmtub3duLCB2b2lkLCB1bmtub3duPiB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgRGVjb2RlcihcbiAgICBvcHRpb25zLmV4dGVuc2lvbkNvZGVjLFxuICAgIChvcHRpb25zIGFzIHR5cGVvZiBvcHRpb25zICYgeyBjb250ZXh0OiBhbnkgfSkuY29udGV4dCxcbiAgICBvcHRpb25zLm1heFN0ckxlbmd0aCxcbiAgICBvcHRpb25zLm1heEJpbkxlbmd0aCxcbiAgICBvcHRpb25zLm1heEFycmF5TGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4TWFwTGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4RXh0TGVuZ3RoLFxuICApO1xuICByZXR1cm4gZGVjb2Rlci5kZWNvZGVNdWx0aShidWZmZXIpO1xufVxuIiwgIi8vIHV0aWxpdHkgZm9yIHdoYXR3ZyBzdHJlYW1zXG5cbi8vIFRoZSBsaXZpbmcgc3RhbmRhcmQgb2Ygd2hhdHdnIHN0cmVhbXMgc2F5c1xuLy8gUmVhZGFibGVTdHJlYW0gaXMgYWxzbyBBc3luY0l0ZXJhYmxlLCBidXRcbi8vIGFzIG9mIEp1bmUgMjAxOSwgbm8gYnJvd3NlciBpbXBsZW1lbnRzIGl0LlxuLy8gU2VlIGh0dHBzOi8vc3RyZWFtcy5zcGVjLndoYXR3Zy5vcmcvIGZvciBkZXRhaWxzXG5leHBvcnQgdHlwZSBSZWFkYWJsZVN0cmVhbUxpa2U8VD4gPSBBc3luY0l0ZXJhYmxlPFQ+IHwgUmVhZGFibGVTdHJlYW08VD47XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FzeW5jSXRlcmFibGU8VD4ob2JqZWN0OiBSZWFkYWJsZVN0cmVhbUxpa2U8VD4pOiBvYmplY3QgaXMgQXN5bmNJdGVyYWJsZTxUPiB7XG4gIHJldHVybiAob2JqZWN0IGFzIGFueSlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE5vbk51bGw8VD4odmFsdWU6IFQgfCBudWxsIHwgdW5kZWZpbmVkKTogYXNzZXJ0cyB2YWx1ZSBpcyBUIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gRmFpbHVyZTogdmFsdWUgbXVzdCBub3QgYmUgbnVsbCBub3IgdW5kZWZpbmVkXCIpO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogYXN5bmNJdGVyYWJsZUZyb21TdHJlYW08VD4oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxUPik6IEFzeW5jSXRlcmFibGU8VD4ge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG5cbiAgdHJ5IHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFzc2VydE5vbk51bGwodmFsdWUpO1xuICAgICAgeWllbGQgdmFsdWU7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVBc3luY0l0ZXJhYmxlPFQ+KHN0cmVhbUxpa2U6IFJlYWRhYmxlU3RyZWFtTGlrZTxUPik6IEFzeW5jSXRlcmFibGU8VD4ge1xuICBpZiAoaXNBc3luY0l0ZXJhYmxlKHN0cmVhbUxpa2UpKSB7XG4gICAgcmV0dXJuIHN0cmVhbUxpa2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFzeW5jSXRlcmFibGVGcm9tU3RyZWFtKHN0cmVhbUxpa2UpO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgRGVjb2RlciB9IGZyb20gXCIuL0RlY29kZXJcIjtcbmltcG9ydCB7IGVuc3VyZUFzeW5jSXRlcmFibGUgfSBmcm9tIFwiLi91dGlscy9zdHJlYW1cIjtcbmltcG9ydCB7IGRlZmF1bHREZWNvZGVPcHRpb25zIH0gZnJvbSBcIi4vZGVjb2RlXCI7XG5pbXBvcnQgdHlwZSB7IFJlYWRhYmxlU3RyZWFtTGlrZSB9IGZyb20gXCIuL3V0aWxzL3N0cmVhbVwiO1xuaW1wb3J0IHR5cGUgeyBEZWNvZGVPcHRpb25zIH0gZnJvbSBcIi4vZGVjb2RlXCI7XG5pbXBvcnQgdHlwZSB7IFNwbGl0VW5kZWZpbmVkIH0gZnJvbSBcIi4vY29udGV4dFwiO1xuXG4vKipcbiAqIEB0aHJvd3Mge0BsaW5rIFJhbmdlRXJyb3J9IGlmIHRoZSBidWZmZXIgaXMgaW5jb21wbGV0ZSwgaW5jbHVkaW5nIHRoZSBjYXNlIHdoZXJlIHRoZSBidWZmZXIgaXMgZW1wdHkuXG4gKiBAdGhyb3dzIHtAbGluayBEZWNvZGVFcnJvcn0gaWYgdGhlIGJ1ZmZlciBjb250YWlucyBpbnZhbGlkIGRhdGEuXG4gKi9cbiBleHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVjb2RlQXN5bmM8Q29udGV4dFR5cGU+KFxuICBzdHJlYW1MaWtlOiBSZWFkYWJsZVN0cmVhbUxpa2U8QXJyYXlMaWtlPG51bWJlcj4gfCBCdWZmZXJTb3VyY2U+LFxuICBvcHRpb25zOiBEZWNvZGVPcHRpb25zPFNwbGl0VW5kZWZpbmVkPENvbnRleHRUeXBlPj4gPSBkZWZhdWx0RGVjb2RlT3B0aW9ucyBhcyBhbnksXG4pOiBQcm9taXNlPHVua25vd24+IHtcbiAgY29uc3Qgc3RyZWFtID0gZW5zdXJlQXN5bmNJdGVyYWJsZShzdHJlYW1MaWtlKTtcblxuICBjb25zdCBkZWNvZGVyID0gbmV3IERlY29kZXIoXG4gICAgb3B0aW9ucy5leHRlbnNpb25Db2RlYyxcbiAgICAob3B0aW9ucyBhcyB0eXBlb2Ygb3B0aW9ucyAmIHsgY29udGV4dDogYW55IH0pLmNvbnRleHQsXG4gICAgb3B0aW9ucy5tYXhTdHJMZW5ndGgsXG4gICAgb3B0aW9ucy5tYXhCaW5MZW5ndGgsXG4gICAgb3B0aW9ucy5tYXhBcnJheUxlbmd0aCxcbiAgICBvcHRpb25zLm1heE1hcExlbmd0aCxcbiAgICBvcHRpb25zLm1heEV4dExlbmd0aCxcbiAgKTtcbiAgcmV0dXJuIGRlY29kZXIuZGVjb2RlQXN5bmMoc3RyZWFtKTtcbn1cblxuLyoqXG4gKiBAdGhyb3dzIHtAbGluayBSYW5nZUVycm9yfSBpZiB0aGUgYnVmZmVyIGlzIGluY29tcGxldGUsIGluY2x1ZGluZyB0aGUgY2FzZSB3aGVyZSB0aGUgYnVmZmVyIGlzIGVtcHR5LlxuICogQHRocm93cyB7QGxpbmsgRGVjb2RlRXJyb3J9IGlmIHRoZSBidWZmZXIgY29udGFpbnMgaW52YWxpZCBkYXRhLlxuICovXG4gZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUFycmF5U3RyZWFtPENvbnRleHRUeXBlPihcbiAgc3RyZWFtTGlrZTogUmVhZGFibGVTdHJlYW1MaWtlPEFycmF5TGlrZTxudW1iZXI+IHwgQnVmZmVyU291cmNlPixcbiAgb3B0aW9uczogRGVjb2RlT3B0aW9uczxTcGxpdFVuZGVmaW5lZDxDb250ZXh0VHlwZT4+ID0gZGVmYXVsdERlY29kZU9wdGlvbnMgYXMgYW55LFxuKTogQXN5bmNHZW5lcmF0b3I8dW5rbm93biwgdm9pZCwgdW5rbm93bj4ge1xuICBjb25zdCBzdHJlYW0gPSBlbnN1cmVBc3luY0l0ZXJhYmxlKHN0cmVhbUxpa2UpO1xuXG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgRGVjb2RlcihcbiAgICBvcHRpb25zLmV4dGVuc2lvbkNvZGVjLFxuICAgIChvcHRpb25zIGFzIHR5cGVvZiBvcHRpb25zICYgeyBjb250ZXh0OiBhbnkgfSkuY29udGV4dCxcbiAgICBvcHRpb25zLm1heFN0ckxlbmd0aCxcbiAgICBvcHRpb25zLm1heEJpbkxlbmd0aCxcbiAgICBvcHRpb25zLm1heEFycmF5TGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4TWFwTGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4RXh0TGVuZ3RoLFxuICApO1xuXG4gIHJldHVybiBkZWNvZGVyLmRlY29kZUFycmF5U3RyZWFtKHN0cmVhbSk7XG59XG5cbi8qKlxuICogQHRocm93cyB7QGxpbmsgUmFuZ2VFcnJvcn0gaWYgdGhlIGJ1ZmZlciBpcyBpbmNvbXBsZXRlLCBpbmNsdWRpbmcgdGhlIGNhc2Ugd2hlcmUgdGhlIGJ1ZmZlciBpcyBlbXB0eS5cbiAqIEB0aHJvd3Mge0BsaW5rIERlY29kZUVycm9yfSBpZiB0aGUgYnVmZmVyIGNvbnRhaW5zIGludmFsaWQgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU11bHRpU3RyZWFtPENvbnRleHRUeXBlPihcbiAgc3RyZWFtTGlrZTogUmVhZGFibGVTdHJlYW1MaWtlPEFycmF5TGlrZTxudW1iZXI+IHwgQnVmZmVyU291cmNlPixcbiAgb3B0aW9uczogRGVjb2RlT3B0aW9uczxTcGxpdFVuZGVmaW5lZDxDb250ZXh0VHlwZT4+ID0gZGVmYXVsdERlY29kZU9wdGlvbnMgYXMgYW55LFxuKTogQXN5bmNHZW5lcmF0b3I8dW5rbm93biwgdm9pZCwgdW5rbm93bj4ge1xuICBjb25zdCBzdHJlYW0gPSBlbnN1cmVBc3luY0l0ZXJhYmxlKHN0cmVhbUxpa2UpO1xuXG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgRGVjb2RlcihcbiAgICBvcHRpb25zLmV4dGVuc2lvbkNvZGVjLFxuICAgIChvcHRpb25zIGFzIHR5cGVvZiBvcHRpb25zICYgeyBjb250ZXh0OiBhbnkgfSkuY29udGV4dCxcbiAgICBvcHRpb25zLm1heFN0ckxlbmd0aCxcbiAgICBvcHRpb25zLm1heEJpbkxlbmd0aCxcbiAgICBvcHRpb25zLm1heEFycmF5TGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4TWFwTGVuZ3RoLFxuICAgIG9wdGlvbnMubWF4RXh0TGVuZ3RoLFxuICApO1xuXG4gIHJldHVybiBkZWNvZGVyLmRlY29kZVN0cmVhbShzdHJlYW0pO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgZGVjb2RlTXVsdGlTdHJlYW0oKX0gaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVN0cmVhbTxDb250ZXh0VHlwZT4oXG4gIHN0cmVhbUxpa2U6IFJlYWRhYmxlU3RyZWFtTGlrZTxBcnJheUxpa2U8bnVtYmVyPiB8IEJ1ZmZlclNvdXJjZT4sXG4gIG9wdGlvbnM6IERlY29kZU9wdGlvbnM8U3BsaXRVbmRlZmluZWQ8Q29udGV4dFR5cGU+PiA9IGRlZmF1bHREZWNvZGVPcHRpb25zIGFzIGFueSxcbik6IEFzeW5jR2VuZXJhdG9yPHVua25vd24sIHZvaWQsIHVua25vd24+IHtcbiAgcmV0dXJuIGRlY29kZU11bHRpU3RyZWFtKHN0cmVhbUxpa2UsIG9wdGlvbnMpO1xufVxuIiwgIi8vIE1haW4gRnVuY3Rpb25zOlxuXG5pbXBvcnQgeyBlbmNvZGUgfSBmcm9tIFwiLi9lbmNvZGVcIjtcbmV4cG9ydCB7IGVuY29kZSB9O1xuaW1wb3J0IHR5cGUgeyBFbmNvZGVPcHRpb25zIH0gZnJvbSBcIi4vZW5jb2RlXCI7XG5leHBvcnQgdHlwZSB7IEVuY29kZU9wdGlvbnMgfTtcblxuaW1wb3J0IHsgZGVjb2RlLCBkZWNvZGVNdWx0aSB9IGZyb20gXCIuL2RlY29kZVwiO1xuZXhwb3J0IHsgZGVjb2RlLCBkZWNvZGVNdWx0aSB9O1xuaW1wb3J0IHR5cGUgeyBEZWNvZGVPcHRpb25zIH0gZnJvbSBcIi4vZGVjb2RlXCI7XG5leHBvcnQgeyBEZWNvZGVPcHRpb25zIH07XG5cbmltcG9ydCB7IGRlY29kZUFzeW5jLCBkZWNvZGVBcnJheVN0cmVhbSwgZGVjb2RlTXVsdGlTdHJlYW0sIGRlY29kZVN0cmVhbSB9IGZyb20gXCIuL2RlY29kZUFzeW5jXCI7XG5leHBvcnQgeyBkZWNvZGVBc3luYywgZGVjb2RlQXJyYXlTdHJlYW0sIGRlY29kZU11bHRpU3RyZWFtLCBkZWNvZGVTdHJlYW0gfTtcblxuaW1wb3J0IHsgRGVjb2RlciwgRGF0YVZpZXdJbmRleE91dE9mQm91bmRzRXJyb3IgfSBmcm9tIFwiLi9EZWNvZGVyXCI7XG5pbXBvcnQgeyBEZWNvZGVFcnJvciB9IGZyb20gXCIuL0RlY29kZUVycm9yXCI7XG5leHBvcnQgeyBEZWNvZGVyLCBEZWNvZGVFcnJvciwgRGF0YVZpZXdJbmRleE91dE9mQm91bmRzRXJyb3IgfTtcblxuaW1wb3J0IHsgRW5jb2RlciB9IGZyb20gXCIuL0VuY29kZXJcIjtcbmV4cG9ydCB7IEVuY29kZXIgfTtcblxuLy8gVXRpbGl0aWllcyBmb3IgRXh0ZW5zaW9uIFR5cGVzOlxuXG5pbXBvcnQgeyBFeHRlbnNpb25Db2RlYyB9IGZyb20gXCIuL0V4dGVuc2lvbkNvZGVjXCI7XG5leHBvcnQgeyBFeHRlbnNpb25Db2RlYyB9O1xuaW1wb3J0IHR5cGUgeyBFeHRlbnNpb25Db2RlY1R5cGUsIEV4dGVuc2lvbkRlY29kZXJUeXBlLCBFeHRlbnNpb25FbmNvZGVyVHlwZSB9IGZyb20gXCIuL0V4dGVuc2lvbkNvZGVjXCI7XG5leHBvcnQgdHlwZSB7IEV4dGVuc2lvbkNvZGVjVHlwZSwgRXh0ZW5zaW9uRGVjb2RlclR5cGUsIEV4dGVuc2lvbkVuY29kZXJUeXBlIH07XG5pbXBvcnQgeyBFeHREYXRhIH0gZnJvbSBcIi4vRXh0RGF0YVwiO1xuZXhwb3J0IHsgRXh0RGF0YSB9O1xuXG5pbXBvcnQge1xuICBFWFRfVElNRVNUQU1QLFxuICBlbmNvZGVEYXRlVG9UaW1lU3BlYyxcbiAgZW5jb2RlVGltZVNwZWNUb1RpbWVzdGFtcCxcbiAgZGVjb2RlVGltZXN0YW1wVG9UaW1lU3BlYyxcbiAgZW5jb2RlVGltZXN0YW1wRXh0ZW5zaW9uLFxuICBkZWNvZGVUaW1lc3RhbXBFeHRlbnNpb24sXG59IGZyb20gXCIuL3RpbWVzdGFtcFwiO1xuZXhwb3J0IHtcbiAgRVhUX1RJTUVTVEFNUCxcbiAgZW5jb2RlRGF0ZVRvVGltZVNwZWMsXG4gIGVuY29kZVRpbWVTcGVjVG9UaW1lc3RhbXAsXG4gIGRlY29kZVRpbWVzdGFtcFRvVGltZVNwZWMsXG4gIGVuY29kZVRpbWVzdGFtcEV4dGVuc2lvbixcbiAgZGVjb2RlVGltZXN0YW1wRXh0ZW5zaW9uLFxufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFydGlhbENsb25lID0gdm9pZCAwO1xuLyoqXG4gKiBDbG9uZXMgYW4gb2JqZWN0IChjb3BpZXMgXCJvd24gcHJvcGVydGllc1wiKSB1bnRpbCBgZGVwdGhgLCB3aGVyZTpcbiAqIC0gZGVwdGg9MCByZXR1cm5zIG5vbi1vYmplY3QgdmFsdWUsIG9yIGVtcHR5IG9iamVjdCAoYHt9YCBvciBgW11gKS5cbiAqIC0gZGVwdGg9MSByZXR1cm5zIGBvYmpgIHdpdGggaXRzIGltbWVkaWF0ZSBjaGlsZHJlbiAoYnV0IG5vdCB0aGVpciBjaGlsZHJlbikuXG4gKiAtIGRlcHRoPTIgcmV0dXJucyBgb2JqYCB3aXRoIGl0cyBjaGlsZHJlbiBhbmQgdGhlaXIgY2hpbGRyZW4uXG4gKiAtIGFuZCBzbyBvbi4uLlxuICpcbiAqIFRPRE86IG5vZGUncyBgdXRpbC5pbnNwZWN0KClgIGZ1bmN0aW9uIGlzIGJldHRlciwgYnV0IGRvZXNuJ3Qgd29yayBpbiB3ZWIgYnJvd3Nlcj9cbiAqXG4gKiBAcGFyYW0gb2JqIE9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSBkZXB0aFxuICogQHBhcmFtIG9taXRLZXlzIE9taXQgcHJvcGVydGllcyBtYXRjaGluZyB0aGVzZSBuYW1lcyAoYXQgYW55IGRlcHRoKS5cbiAqIEBwYXJhbSByZXBsYWNlbWVudCBSZXBsYWNlbWVudCBmb3Igb2JqZWN0IHdob3NlIGZpZWxkcyBleHRlbmQgYmV5b25kIGBkZXB0aGAsIGFuZCBwcm9wZXJ0aWVzIG1hdGNoaW5nIGBvbWl0S2V5c2AuXG4gKi9cbmZ1bmN0aW9uIHBhcnRpYWxDbG9uZShvYmosIGRlcHRoID0gMywgb21pdEtleXMgPSBbXSwgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQpIHtcbiAgICAvLyBCYXNlIGNhc2U6IElmIGlucHV0IGlzIG5vdCBhbiBvYmplY3Qgb3IgaGFzIG5vIGNoaWxkcmVuLCByZXR1cm4gaXQuXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8XG4gICAgICAgIG9iaiA9PT0gbnVsbCB8fFxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBuZXcgb2JqZWN0IG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlIGlucHV0IG9iamVjdC5cbiAgICBjb25zdCBjbG9uZWRPYmogPSBBcnJheS5pc0FycmF5KG9iaikgPyBbXSA6IHt9O1xuICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQgfHwgY2xvbmVkT2JqO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjbG9uZSBwcm9wZXJ0aWVzIG9mIHRoZSBpbnB1dCBvYmplY3RcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICAgIGlmIChvbWl0S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBjbG9uZWRPYmpba2V5XSA9IHJlcGxhY2VtZW50IHx8IChBcnJheS5pc0FycmF5KG9iaikgPyBbXSA6IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICBjbG9uZWRPYmpba2V5XSA9IHBhcnRpYWxDbG9uZShvYmpba2V5XSwgZGVwdGggLSAxLCBvbWl0S2V5cywgcmVwbGFjZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWRPYmo7XG59XG5leHBvcnRzLnBhcnRpYWxDbG9uZSA9IHBhcnRpYWxDbG9uZTtcbiIsICIndXNlIHN0cmljdCc7XG5cbi8qXG4gKiBEaXNwbGF5cyBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgdGhlIHNvdXJjZSBvZlxuICogdGhlIGZvcm1hdCB3aGVuIGl0IGlzIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRGb3JtYXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZm9ybWF0Rm4pIHtcbiAgICBzdXBlcihgRm9ybWF0IGZ1bmN0aW9ucyBtdXN0IGJlIHN5bmNocm9ub3VzIHRha2luZyBhIHR3byBhcmd1bWVudHM6IChpbmZvLCBvcHRzKVxuRm91bmQ6ICR7Zm9ybWF0Rm4udG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF19XFxuYCk7XG5cbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBJbnZhbGlkRm9ybWF0RXJyb3IpO1xuICB9XG59XG5cbi8qXG4gKiBmdW5jdGlvbiBmb3JtYXQgKGZvcm1hdEZuKVxuICogUmV0dXJucyBhIGNyZWF0ZSBmdW5jdGlvbiBmb3IgdGhlIGBmb3JtYXRGbmAuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZm9ybWF0Rm4gPT4ge1xuICBpZiAoZm9ybWF0Rm4ubGVuZ3RoID4gMikge1xuICAgIHRocm93IG5ldyBJbnZhbGlkRm9ybWF0RXJyb3IoZm9ybWF0Rm4pO1xuICB9XG5cbiAgLypcbiAgICogZnVuY3Rpb24gRm9ybWF0IChvcHRpb25zKVxuICAgKiBCYXNlIHByb3RvdHlwZSB3aGljaCBjYWxscyBhIGBfZm9ybWF0YFxuICAgKiBmdW5jdGlvbiBhbmQgcHVzaGVzIHRoZSByZXN1bHQuXG4gICAqL1xuICBmdW5jdGlvbiBGb3JtYXQob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIEZvcm1hdC5wcm90b3R5cGUudHJhbnNmb3JtID0gZm9ybWF0Rm47XG5cbiAgLy9cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBuZXcgaW5zdGFuY2VzIG9mXG4gIC8vIEZvcm1hdFdyYXAgZm9yIHNpbXBsZSBzeW50YXggbGlrZTpcbiAgLy9cbiAgLy8gcmVxdWlyZSgnd2luc3RvbicpLmZvcm1hdHMuanNvbigpO1xuICAvL1xuICBmdW5jdGlvbiBjcmVhdGVGb3JtYXRXcmFwKG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IEZvcm1hdChvcHRzKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEV4cG9zZSB0aGUgRm9ybWF0V3JhcCB0aHJvdWdoIHRoZSBjcmVhdGUgZnVuY3Rpb25cbiAgLy8gZm9yIHRlc3RhYmlsaXR5LlxuICAvL1xuICBjcmVhdGVGb3JtYXRXcmFwLkZvcm1hdCA9IEZvcm1hdDtcbiAgcmV0dXJuIGNyZWF0ZUZvcm1hdFdyYXA7XG59O1xuIiwgIi8qXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuQ29weXJpZ2h0IChjKSBTaW5kcmUgU29yaHVzIDxzaW5kcmVzb3JodXNAZ21haWwuY29tPiAoc2luZHJlc29yaHVzLmNvbSlcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4qL1xuXG52YXIgc3R5bGVzID0ge307XG5tb2R1bGVbJ2V4cG9ydHMnXSA9IHN0eWxlcztcblxudmFyIGNvZGVzID0ge1xuICByZXNldDogWzAsIDBdLFxuXG4gIGJvbGQ6IFsxLCAyMl0sXG4gIGRpbTogWzIsIDIyXSxcbiAgaXRhbGljOiBbMywgMjNdLFxuICB1bmRlcmxpbmU6IFs0LCAyNF0sXG4gIGludmVyc2U6IFs3LCAyN10sXG4gIGhpZGRlbjogWzgsIDI4XSxcbiAgc3RyaWtldGhyb3VnaDogWzksIDI5XSxcblxuICBibGFjazogWzMwLCAzOV0sXG4gIHJlZDogWzMxLCAzOV0sXG4gIGdyZWVuOiBbMzIsIDM5XSxcbiAgeWVsbG93OiBbMzMsIDM5XSxcbiAgYmx1ZTogWzM0LCAzOV0sXG4gIG1hZ2VudGE6IFszNSwgMzldLFxuICBjeWFuOiBbMzYsIDM5XSxcbiAgd2hpdGU6IFszNywgMzldLFxuICBncmF5OiBbOTAsIDM5XSxcbiAgZ3JleTogWzkwLCAzOV0sXG5cbiAgYnJpZ2h0UmVkOiBbOTEsIDM5XSxcbiAgYnJpZ2h0R3JlZW46IFs5MiwgMzldLFxuICBicmlnaHRZZWxsb3c6IFs5MywgMzldLFxuICBicmlnaHRCbHVlOiBbOTQsIDM5XSxcbiAgYnJpZ2h0TWFnZW50YTogWzk1LCAzOV0sXG4gIGJyaWdodEN5YW46IFs5NiwgMzldLFxuICBicmlnaHRXaGl0ZTogWzk3LCAzOV0sXG5cbiAgYmdCbGFjazogWzQwLCA0OV0sXG4gIGJnUmVkOiBbNDEsIDQ5XSxcbiAgYmdHcmVlbjogWzQyLCA0OV0sXG4gIGJnWWVsbG93OiBbNDMsIDQ5XSxcbiAgYmdCbHVlOiBbNDQsIDQ5XSxcbiAgYmdNYWdlbnRhOiBbNDUsIDQ5XSxcbiAgYmdDeWFuOiBbNDYsIDQ5XSxcbiAgYmdXaGl0ZTogWzQ3LCA0OV0sXG4gIGJnR3JheTogWzEwMCwgNDldLFxuICBiZ0dyZXk6IFsxMDAsIDQ5XSxcblxuICBiZ0JyaWdodFJlZDogWzEwMSwgNDldLFxuICBiZ0JyaWdodEdyZWVuOiBbMTAyLCA0OV0sXG4gIGJnQnJpZ2h0WWVsbG93OiBbMTAzLCA0OV0sXG4gIGJnQnJpZ2h0Qmx1ZTogWzEwNCwgNDldLFxuICBiZ0JyaWdodE1hZ2VudGE6IFsxMDUsIDQ5XSxcbiAgYmdCcmlnaHRDeWFuOiBbMTA2LCA0OV0sXG4gIGJnQnJpZ2h0V2hpdGU6IFsxMDcsIDQ5XSxcblxuICAvLyBsZWdhY3kgc3R5bGVzIGZvciBjb2xvcnMgcHJlIHYxLjAuMFxuICBibGFja0JHOiBbNDAsIDQ5XSxcbiAgcmVkQkc6IFs0MSwgNDldLFxuICBncmVlbkJHOiBbNDIsIDQ5XSxcbiAgeWVsbG93Qkc6IFs0MywgNDldLFxuICBibHVlQkc6IFs0NCwgNDldLFxuICBtYWdlbnRhQkc6IFs0NSwgNDldLFxuICBjeWFuQkc6IFs0NiwgNDldLFxuICB3aGl0ZUJHOiBbNDcsIDQ5XSxcblxufTtcblxuT2JqZWN0LmtleXMoY29kZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gIHZhciB2YWwgPSBjb2Rlc1trZXldO1xuICB2YXIgc3R5bGUgPSBzdHlsZXNba2V5XSA9IFtdO1xuICBzdHlsZS5vcGVuID0gJ1xcdTAwMWJbJyArIHZhbFswXSArICdtJztcbiAgc3R5bGUuY2xvc2UgPSAnXFx1MDAxYlsnICsgdmFsWzFdICsgJ20nO1xufSk7XG4iLCAiLypcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgU2luZHJlIFNvcmh1cyA8c2luZHJlc29yaHVzQGdtYWlsLmNvbT4gKHNpbmRyZXNvcmh1cy5jb20pXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2ZcbnRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cbnRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbnVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG5vZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbnNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbGFnLCBhcmd2KSB7XG4gIGFyZ3YgPSBhcmd2IHx8IHByb2Nlc3MuYXJndiB8fCBbXTtcblxuICB2YXIgdGVybWluYXRvclBvcyA9IGFyZ3YuaW5kZXhPZignLS0nKTtcbiAgdmFyIHByZWZpeCA9IC9eLXsxLDJ9Ly50ZXN0KGZsYWcpID8gJycgOiAnLS0nO1xuICB2YXIgcG9zID0gYXJndi5pbmRleE9mKHByZWZpeCArIGZsYWcpO1xuXG4gIHJldHVybiBwb3MgIT09IC0xICYmICh0ZXJtaW5hdG9yUG9zID09PSAtMSA/IHRydWUgOiBwb3MgPCB0ZXJtaW5hdG9yUG9zKTtcbn07XG4iLCAiLypcblRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG5Db3B5cmlnaHQgKGMpIFNpbmRyZSBTb3JodXMgPHNpbmRyZXNvcmh1c0BnbWFpbC5jb20+IChzaW5kcmVzb3JodXMuY29tKVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG9zID0gcmVxdWlyZSgnb3MnKTtcbnZhciBoYXNGbGFnID0gcmVxdWlyZSgnLi9oYXMtZmxhZy5qcycpO1xuXG52YXIgZW52ID0gcHJvY2Vzcy5lbnY7XG5cbnZhciBmb3JjZUNvbG9yID0gdm9pZCAwO1xuaWYgKGhhc0ZsYWcoJ25vLWNvbG9yJykgfHwgaGFzRmxhZygnbm8tY29sb3JzJykgfHwgaGFzRmxhZygnY29sb3I9ZmFsc2UnKSkge1xuICBmb3JjZUNvbG9yID0gZmFsc2U7XG59IGVsc2UgaWYgKGhhc0ZsYWcoJ2NvbG9yJykgfHwgaGFzRmxhZygnY29sb3JzJykgfHwgaGFzRmxhZygnY29sb3I9dHJ1ZScpXG4gICAgICAgICAgIHx8IGhhc0ZsYWcoJ2NvbG9yPWFsd2F5cycpKSB7XG4gIGZvcmNlQ29sb3IgPSB0cnVlO1xufVxuaWYgKCdGT1JDRV9DT0xPUicgaW4gZW52KSB7XG4gIGZvcmNlQ29sb3IgPSBlbnYuRk9SQ0VfQ09MT1IubGVuZ3RoID09PSAwXG4gICAgfHwgcGFyc2VJbnQoZW52LkZPUkNFX0NPTE9SLCAxMCkgIT09IDA7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUxldmVsKGxldmVsKSB7XG4gIGlmIChsZXZlbCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGV2ZWw6IGxldmVsLFxuICAgIGhhc0Jhc2ljOiB0cnVlLFxuICAgIGhhczI1NjogbGV2ZWwgPj0gMixcbiAgICBoYXMxNm06IGxldmVsID49IDMsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzQ29sb3Ioc3RyZWFtKSB7XG4gIGlmIChmb3JjZUNvbG9yID09PSBmYWxzZSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGhhc0ZsYWcoJ2NvbG9yPTE2bScpIHx8IGhhc0ZsYWcoJ2NvbG9yPWZ1bGwnKVxuICAgICAgfHwgaGFzRmxhZygnY29sb3I9dHJ1ZWNvbG9yJykpIHtcbiAgICByZXR1cm4gMztcbiAgfVxuXG4gIGlmIChoYXNGbGFnKCdjb2xvcj0yNTYnKSkge1xuICAgIHJldHVybiAyO1xuICB9XG5cbiAgaWYgKHN0cmVhbSAmJiAhc3RyZWFtLmlzVFRZICYmIGZvcmNlQ29sb3IgIT09IHRydWUpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBtaW4gPSBmb3JjZUNvbG9yID8gMSA6IDA7XG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAvLyBOb2RlLmpzIDcuNS4wIGlzIHRoZSBmaXJzdCB2ZXJzaW9uIG9mIE5vZGUuanMgdG8gaW5jbHVkZSBhIHBhdGNoIHRvXG4gICAgLy8gbGlidXYgdGhhdCBlbmFibGVzIDI1NiBjb2xvciBvdXRwdXQgb24gV2luZG93cy4gQW55dGhpbmcgZWFybGllciBhbmQgaXRcbiAgICAvLyB3b24ndCB3b3JrLiBIb3dldmVyLCBoZXJlIHdlIHRhcmdldCBOb2RlLmpzIDggYXQgbWluaW11bSBhcyBpdCBpcyBhbiBMVFNcbiAgICAvLyByZWxlYXNlLCBhbmQgTm9kZS5qcyA3IGlzIG5vdC4gV2luZG93cyAxMCBidWlsZCAxMDU4NiBpcyB0aGUgZmlyc3RcbiAgICAvLyBXaW5kb3dzIHJlbGVhc2UgdGhhdCBzdXBwb3J0cyAyNTYgY29sb3JzLiBXaW5kb3dzIDEwIGJ1aWxkIDE0OTMxIGlzIHRoZVxuICAgIC8vIGZpcnN0IHJlbGVhc2UgdGhhdCBzdXBwb3J0cyAxNm0vVHJ1ZUNvbG9yLlxuICAgIHZhciBvc1JlbGVhc2UgPSBvcy5yZWxlYXNlKCkuc3BsaXQoJy4nKTtcbiAgICBpZiAoTnVtYmVyKHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpWzBdKSA+PSA4XG4gICAgICAgICYmIE51bWJlcihvc1JlbGVhc2VbMF0pID49IDEwICYmIE51bWJlcihvc1JlbGVhc2VbMl0pID49IDEwNTg2KSB7XG4gICAgICByZXR1cm4gTnVtYmVyKG9zUmVsZWFzZVsyXSkgPj0gMTQ5MzEgPyAzIDogMjtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIGlmICgnQ0knIGluIGVudikge1xuICAgIGlmIChbJ1RSQVZJUycsICdDSVJDTEVDSScsICdBUFBWRVlPUicsICdHSVRMQUJfQ0knXS5zb21lKGZ1bmN0aW9uKHNpZ24pIHtcbiAgICAgIHJldHVybiBzaWduIGluIGVudjtcbiAgICB9KSB8fCBlbnYuQ0lfTkFNRSA9PT0gJ2NvZGVzaGlwJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuXG4gIGlmICgnVEVBTUNJVFlfVkVSU0lPTicgaW4gZW52KSB7XG4gICAgcmV0dXJuICgvXig5XFwuKDAqWzEtOV1cXGQqKVxcLnxcXGR7Mix9XFwuKS8udGVzdChlbnYuVEVBTUNJVFlfVkVSU0lPTikgPyAxIDogMFxuICAgICk7XG4gIH1cblxuICBpZiAoJ1RFUk1fUFJPR1JBTScgaW4gZW52KSB7XG4gICAgdmFyIHZlcnNpb24gPSBwYXJzZUludCgoZW52LlRFUk1fUFJPR1JBTV9WRVJTSU9OIHx8ICcnKS5zcGxpdCgnLicpWzBdLCAxMCk7XG5cbiAgICBzd2l0Y2ggKGVudi5URVJNX1BST0dSQU0pIHtcbiAgICAgIGNhc2UgJ2lUZXJtLmFwcCc6XG4gICAgICAgIHJldHVybiB2ZXJzaW9uID49IDMgPyAzIDogMjtcbiAgICAgIGNhc2UgJ0h5cGVyJzpcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgICBjYXNlICdBcHBsZV9UZXJtaW5hbCc6XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgLy8gTm8gZGVmYXVsdFxuICAgIH1cbiAgfVxuXG4gIGlmICgvLTI1Nihjb2xvcik/JC9pLnRlc3QoZW52LlRFUk0pKSB7XG4gICAgcmV0dXJuIDI7XG4gIH1cblxuICBpZiAoL15zY3JlZW58Xnh0ZXJtfF52dDEwMHxecnh2dHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QoZW52LlRFUk0pKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBpZiAoJ0NPTE9SVEVSTScgaW4gZW52KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBpZiAoZW52LlRFUk0gPT09ICdkdW1iJykge1xuICAgIHJldHVybiBtaW47XG4gIH1cblxuICByZXR1cm4gbWluO1xufVxuXG5mdW5jdGlvbiBnZXRTdXBwb3J0TGV2ZWwoc3RyZWFtKSB7XG4gIHZhciBsZXZlbCA9IHN1cHBvcnRzQ29sb3Ioc3RyZWFtKTtcbiAgcmV0dXJuIHRyYW5zbGF0ZUxldmVsKGxldmVsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN1cHBvcnRzQ29sb3I6IGdldFN1cHBvcnRMZXZlbCxcbiAgc3Rkb3V0OiBnZXRTdXBwb3J0TGV2ZWwocHJvY2Vzcy5zdGRvdXQpLFxuICBzdGRlcnI6IGdldFN1cHBvcnRMZXZlbChwcm9jZXNzLnN0ZGVyciksXG59O1xuIiwgIm1vZHVsZVsnZXhwb3J0cyddID0gZnVuY3Rpb24gcnVuVGhlVHJhcCh0ZXh0LCBvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdGV4dCA9IHRleHQgfHwgJ1J1biB0aGUgdHJhcCwgZHJvcCB0aGUgYmFzcyc7XG4gIHRleHQgPSB0ZXh0LnNwbGl0KCcnKTtcbiAgdmFyIHRyYXAgPSB7XG4gICAgYTogWydcXHUwMDQwJywgJ1xcdTAxMDQnLCAnXFx1MDIzYScsICdcXHUwMjQ1JywgJ1xcdTAzOTQnLCAnXFx1MDM5YicsICdcXHUwNDE0J10sXG4gICAgYjogWydcXHUwMGRmJywgJ1xcdTAxODEnLCAnXFx1MDI0MycsICdcXHUwMjZlJywgJ1xcdTAzYjInLCAnXFx1MGUzZiddLFxuICAgIGM6IFsnXFx1MDBhOScsICdcXHUwMjNiJywgJ1xcdTAzZmUnXSxcbiAgICBkOiBbJ1xcdTAwZDAnLCAnXFx1MDE4YScsICdcXHUwNTAwJywgJ1xcdTA1MDEnLCAnXFx1MDUwMicsICdcXHUwNTAzJ10sXG4gICAgZTogWydcXHUwMGNiJywgJ1xcdTAxMTUnLCAnXFx1MDE4ZScsICdcXHUwMjU4JywgJ1xcdTAzYTMnLCAnXFx1MDNiZScsICdcXHUwNGJjJyxcbiAgICAgICdcXHUwYTZjJ10sXG4gICAgZjogWydcXHUwNGZhJ10sXG4gICAgZzogWydcXHUwMjYyJ10sXG4gICAgaDogWydcXHUwMTI2JywgJ1xcdTAxOTUnLCAnXFx1MDRhMicsICdcXHUwNGJhJywgJ1xcdTA0YzcnLCAnXFx1MDUwYSddLFxuICAgIGk6IFsnXFx1MGYwZiddLFxuICAgIGo6IFsnXFx1MDEzNCddLFxuICAgIGs6IFsnXFx1MDEzOCcsICdcXHUwNGEwJywgJ1xcdTA0YzMnLCAnXFx1MDUxZSddLFxuICAgIGw6IFsnXFx1MDEzOSddLFxuICAgIG06IFsnXFx1MDI4ZCcsICdcXHUwNGNkJywgJ1xcdTA0Y2UnLCAnXFx1MDUyMCcsICdcXHUwNTIxJywgJ1xcdTBkNjknXSxcbiAgICBuOiBbJ1xcdTAwZDEnLCAnXFx1MDE0YicsICdcXHUwMTlkJywgJ1xcdTAzNzYnLCAnXFx1MDNhMCcsICdcXHUwNDhhJ10sXG4gICAgbzogWydcXHUwMGQ4JywgJ1xcdTAwZjUnLCAnXFx1MDBmOCcsICdcXHUwMWZlJywgJ1xcdTAyOTgnLCAnXFx1MDQ3YScsICdcXHUwNWRkJyxcbiAgICAgICdcXHUwNmRkJywgJ1xcdTBlNGYnXSxcbiAgICBwOiBbJ1xcdTAxZjcnLCAnXFx1MDQ4ZSddLFxuICAgIHE6IFsnXFx1MDljZCddLFxuICAgIHI6IFsnXFx1MDBhZScsICdcXHUwMWE2JywgJ1xcdTAyMTAnLCAnXFx1MDI0YycsICdcXHUwMjgwJywgJ1xcdTA0MmYnXSxcbiAgICBzOiBbJ1xcdTAwYTcnLCAnXFx1MDNkZScsICdcXHUwM2RmJywgJ1xcdTAzZTgnXSxcbiAgICB0OiBbJ1xcdTAxNDEnLCAnXFx1MDE2NicsICdcXHUwMzczJ10sXG4gICAgdTogWydcXHUwMWIxJywgJ1xcdTA1NGQnXSxcbiAgICB2OiBbJ1xcdTA1ZDgnXSxcbiAgICB3OiBbJ1xcdTA0MjgnLCAnXFx1MDQ2MCcsICdcXHUwNDdjJywgJ1xcdTBkNzAnXSxcbiAgICB4OiBbJ1xcdTA0YjInLCAnXFx1MDRmZScsICdcXHUwNGZjJywgJ1xcdTA0ZmQnXSxcbiAgICB5OiBbJ1xcdTAwYTUnLCAnXFx1MDRiMCcsICdcXHUwNGNiJ10sXG4gICAgejogWydcXHUwMWI1JywgJ1xcdTAyNDAnXSxcbiAgfTtcbiAgdGV4dC5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICBjID0gYy50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBjaGFycyA9IHRyYXBbY10gfHwgWycgJ107XG4gICAgdmFyIHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpO1xuICAgIGlmICh0eXBlb2YgdHJhcFtjXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdCArPSB0cmFwW2NdW3JhbmRdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gYztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsICIvLyBwbGVhc2Ugbm9cbm1vZHVsZVsnZXhwb3J0cyddID0gZnVuY3Rpb24gemFsZ28odGV4dCwgb3B0aW9ucykge1xuICB0ZXh0ID0gdGV4dCB8fCAnICAgaGUgaXMgaGVyZSAgICc7XG4gIHZhciBzb3VsID0ge1xuICAgICd1cCc6IFtcbiAgICAgICdcdTAzMEQnLCAnXHUwMzBFJywgJ1x1MDMwNCcsICdcdTAzMDUnLFxuICAgICAgJ1x1MDMzRicsICdcdTAzMTEnLCAnXHUwMzA2JywgJ1x1MDMxMCcsXG4gICAgICAnXHUwMzUyJywgJ1x1MDM1NycsICdcdTAzNTEnLCAnXHUwMzA3JyxcbiAgICAgICdcdTAzMDgnLCAnXHUwMzBBJywgJ1x1MDM0MicsICdcdTAzMTMnLFxuICAgICAgJ1x1MDMwOCcsICdcdTAzNEEnLCAnXHUwMzRCJywgJ1x1MDM0QycsXG4gICAgICAnXHUwMzAzJywgJ1x1MDMwMicsICdcdTAzMEMnLCAnXHUwMzUwJyxcbiAgICAgICdcdTAzMDAnLCAnXHUwMzAxJywgJ1x1MDMwQicsICdcdTAzMEYnLFxuICAgICAgJ1x1MDMxMicsICdcdTAzMTMnLCAnXHUwMzE0JywgJ1x1MDMzRCcsXG4gICAgICAnXHUwMzA5JywgJ1x1MDM2MycsICdcdTAzNjQnLCAnXHUwMzY1JyxcbiAgICAgICdcdTAzNjYnLCAnXHUwMzY3JywgJ1x1MDM2OCcsICdcdTAzNjknLFxuICAgICAgJ1x1MDM2QScsICdcdTAzNkInLCAnXHUwMzZDJywgJ1x1MDM2RCcsXG4gICAgICAnXHUwMzZFJywgJ1x1MDM2RicsICdcdTAzM0UnLCAnXHUwMzVCJyxcbiAgICAgICdcdTAzNDYnLCAnXHUwMzFBJyxcbiAgICBdLFxuICAgICdkb3duJzogW1xuICAgICAgJ1x1MDMxNicsICdcdTAzMTcnLCAnXHUwMzE4JywgJ1x1MDMxOScsXG4gICAgICAnXHUwMzFDJywgJ1x1MDMxRCcsICdcdTAzMUUnLCAnXHUwMzFGJyxcbiAgICAgICdcdTAzMjAnLCAnXHUwMzI0JywgJ1x1MDMyNScsICdcdTAzMjYnLFxuICAgICAgJ1x1MDMyOScsICdcdTAzMkEnLCAnXHUwMzJCJywgJ1x1MDMyQycsXG4gICAgICAnXHUwMzJEJywgJ1x1MDMyRScsICdcdTAzMkYnLCAnXHUwMzMwJyxcbiAgICAgICdcdTAzMzEnLCAnXHUwMzMyJywgJ1x1MDMzMycsICdcdTAzMzknLFxuICAgICAgJ1x1MDMzQScsICdcdTAzM0InLCAnXHUwMzNDJywgJ1x1MDM0NScsXG4gICAgICAnXHUwMzQ3JywgJ1x1MDM0OCcsICdcdTAzNDknLCAnXHUwMzREJyxcbiAgICAgICdcdTAzNEUnLCAnXHUwMzUzJywgJ1x1MDM1NCcsICdcdTAzNTUnLFxuICAgICAgJ1x1MDM1NicsICdcdTAzNTknLCAnXHUwMzVBJywgJ1x1MDMyMycsXG4gICAgXSxcbiAgICAnbWlkJzogW1xuICAgICAgJ1x1MDMxNScsICdcdTAzMUInLCAnXHUwMzAwJywgJ1x1MDMwMScsXG4gICAgICAnXHUwMzU4JywgJ1x1MDMyMScsICdcdTAzMjInLCAnXHUwMzI3JyxcbiAgICAgICdcdTAzMjgnLCAnXHUwMzM0JywgJ1x1MDMzNScsICdcdTAzMzYnLFxuICAgICAgJ1x1MDM1QycsICdcdTAzNUQnLCAnXHUwMzVFJyxcbiAgICAgICdcdTAzNUYnLCAnXHUwMzYwJywgJ1x1MDM2MicsICdcdTAzMzgnLFxuICAgICAgJ1x1MDMzNycsICdcdTAzNjEnLCAnIFx1MDQ4OScsXG4gICAgXSxcbiAgfTtcbiAgdmFyIGFsbCA9IFtdLmNvbmNhdChzb3VsLnVwLCBzb3VsLmRvd24sIHNvdWwubWlkKTtcblxuICBmdW5jdGlvbiByYW5kb21OdW1iZXIocmFuZ2UpIHtcbiAgICB2YXIgciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJhbmdlKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ2hhcihjaGFyYWN0ZXIpIHtcbiAgICB2YXIgYm9vbCA9IGZhbHNlO1xuICAgIGFsbC5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgICAgYm9vbCA9IChpID09PSBjaGFyYWN0ZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBib29sO1xuICB9XG5cblxuICBmdW5jdGlvbiBoZUNvbWVzKHRleHQsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGNvdW50cztcbiAgICB2YXIgbDtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zWyd1cCddID1cbiAgICAgIHR5cGVvZiBvcHRpb25zWyd1cCddICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnNbJ3VwJ10gOiB0cnVlO1xuICAgIG9wdGlvbnNbJ21pZCddID1cbiAgICAgIHR5cGVvZiBvcHRpb25zWydtaWQnXSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zWydtaWQnXSA6IHRydWU7XG4gICAgb3B0aW9uc1snZG93biddID1cbiAgICAgIHR5cGVvZiBvcHRpb25zWydkb3duJ10gIT09ICd1bmRlZmluZWQnID8gb3B0aW9uc1snZG93biddIDogdHJ1ZTtcbiAgICBvcHRpb25zWydzaXplJ10gPVxuICAgICAgdHlwZW9mIG9wdGlvbnNbJ3NpemUnXSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zWydzaXplJ10gOiAnbWF4aSc7XG4gICAgdGV4dCA9IHRleHQuc3BsaXQoJycpO1xuICAgIGZvciAobCBpbiB0ZXh0KSB7XG4gICAgICBpZiAoaXNDaGFyKGwpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgdGV4dFtsXTtcbiAgICAgIGNvdW50cyA9IHsndXAnOiAwLCAnZG93bic6IDAsICdtaWQnOiAwfTtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5zaXplKSB7XG4gICAgICAgIGNhc2UgJ21pbmknOlxuICAgICAgICAgIGNvdW50cy51cCA9IHJhbmRvbU51bWJlcig4KTtcbiAgICAgICAgICBjb3VudHMubWlkID0gcmFuZG9tTnVtYmVyKDIpO1xuICAgICAgICAgIGNvdW50cy5kb3duID0gcmFuZG9tTnVtYmVyKDgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtYXhpJzpcbiAgICAgICAgICBjb3VudHMudXAgPSByYW5kb21OdW1iZXIoMTYpICsgMztcbiAgICAgICAgICBjb3VudHMubWlkID0gcmFuZG9tTnVtYmVyKDQpICsgMTtcbiAgICAgICAgICBjb3VudHMuZG93biA9IHJhbmRvbU51bWJlcig2NCkgKyAzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvdW50cy51cCA9IHJhbmRvbU51bWJlcig4KSArIDE7XG4gICAgICAgICAgY291bnRzLm1pZCA9IHJhbmRvbU51bWJlcig2KSAvIDI7XG4gICAgICAgICAgY291bnRzLmRvd24gPSByYW5kb21OdW1iZXIoOCkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJyID0gWyd1cCcsICdtaWQnLCAnZG93biddO1xuICAgICAgZm9yICh2YXIgZCBpbiBhcnIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYXJyW2RdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBjb3VudHNbaW5kZXhdOyBpKyspIHtcbiAgICAgICAgICBpZiAob3B0aW9uc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCArIHNvdWxbaW5kZXhdW3JhbmRvbU51bWJlcihzb3VsW2luZGV4XS5sZW5ndGgpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvLyBkb24ndCBzdW1tb24gaGltXG4gIHJldHVybiBoZUNvbWVzKHRleHQsIG9wdGlvbnMpO1xufTtcblxuIiwgIm1vZHVsZVsnZXhwb3J0cyddID0gZnVuY3Rpb24oY29sb3JzKSB7XG4gIHJldHVybiBmdW5jdGlvbihsZXR0ZXIsIGksIGV4cGxvZGVkKSB7XG4gICAgaWYgKGxldHRlciA9PT0gJyAnKSByZXR1cm4gbGV0dGVyO1xuICAgIHN3aXRjaCAoaSUzKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBjb2xvcnMucmVkKGxldHRlcik7XG4gICAgICBjYXNlIDE6IHJldHVybiBjb2xvcnMud2hpdGUobGV0dGVyKTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGNvbG9ycy5ibHVlKGxldHRlcik7XG4gICAgfVxuICB9O1xufTtcbiIsICJtb2R1bGVbJ2V4cG9ydHMnXSA9IGZ1bmN0aW9uKGNvbG9ycykge1xuICByZXR1cm4gZnVuY3Rpb24obGV0dGVyLCBpLCBleHBsb2RlZCkge1xuICAgIHJldHVybiBpICUgMiA9PT0gMCA/IGxldHRlciA6IGNvbG9ycy5pbnZlcnNlKGxldHRlcik7XG4gIH07XG59O1xuIiwgIm1vZHVsZVsnZXhwb3J0cyddID0gZnVuY3Rpb24oY29sb3JzKSB7XG4gIC8vIFJvWSBHIEJpVlxuICB2YXIgcmFpbmJvd0NvbG9ycyA9IFsncmVkJywgJ3llbGxvdycsICdncmVlbicsICdibHVlJywgJ21hZ2VudGEnXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxldHRlciwgaSwgZXhwbG9kZWQpIHtcbiAgICBpZiAobGV0dGVyID09PSAnICcpIHtcbiAgICAgIHJldHVybiBsZXR0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb2xvcnNbcmFpbmJvd0NvbG9yc1tpKysgJSByYWluYm93Q29sb3JzLmxlbmd0aF1dKGxldHRlcik7XG4gICAgfVxuICB9O1xufTtcblxuIiwgIm1vZHVsZVsnZXhwb3J0cyddID0gZnVuY3Rpb24oY29sb3JzKSB7XG4gIHZhciBhdmFpbGFibGUgPSBbJ3VuZGVybGluZScsICdpbnZlcnNlJywgJ2dyZXknLCAneWVsbG93JywgJ3JlZCcsICdncmVlbicsXG4gICAgJ2JsdWUnLCAnd2hpdGUnLCAnY3lhbicsICdtYWdlbnRhJywgJ2JyaWdodFllbGxvdycsICdicmlnaHRSZWQnLFxuICAgICdicmlnaHRHcmVlbicsICdicmlnaHRCbHVlJywgJ2JyaWdodFdoaXRlJywgJ2JyaWdodEN5YW4nLCAnYnJpZ2h0TWFnZW50YSddO1xuICByZXR1cm4gZnVuY3Rpb24obGV0dGVyLCBpLCBleHBsb2RlZCkge1xuICAgIHJldHVybiBsZXR0ZXIgPT09ICcgJyA/IGxldHRlciA6XG4gICAgICBjb2xvcnNbXG4gICAgICAgICAgYXZhaWxhYmxlW01hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIChhdmFpbGFibGUubGVuZ3RoIC0gMikpXVxuICAgICAgXShsZXR0ZXIpO1xuICB9O1xufTtcbiIsICIvKlxuXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuT3JpZ2luYWwgTGlicmFyeVxuICAtIENvcHlyaWdodCAoYykgTWFyYWsgU3F1aXJlc1xuXG5BZGRpdGlvbmFsIGZ1bmN0aW9uYWxpdHlcbiAtIENvcHlyaWdodCAoYykgU2luZHJlIFNvcmh1cyA8c2luZHJlc29yaHVzQGdtYWlsLmNvbT4gKHNpbmRyZXNvcmh1cy5jb20pXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cblxuKi9cblxudmFyIGNvbG9ycyA9IHt9O1xubW9kdWxlWydleHBvcnRzJ10gPSBjb2xvcnM7XG5cbmNvbG9ycy50aGVtZXMgPSB7fTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgYW5zaVN0eWxlcyA9IGNvbG9ycy5zdHlsZXMgPSByZXF1aXJlKCcuL3N0eWxlcycpO1xudmFyIGRlZmluZVByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgbmV3TGluZVJlZ2V4ID0gbmV3IFJlZ0V4cCgvW1xcclxcbl0rL2cpO1xuXG5jb2xvcnMuc3VwcG9ydHNDb2xvciA9IHJlcXVpcmUoJy4vc3lzdGVtL3N1cHBvcnRzLWNvbG9ycycpLnN1cHBvcnRzQ29sb3I7XG5cbmlmICh0eXBlb2YgY29sb3JzLmVuYWJsZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gIGNvbG9ycy5lbmFibGVkID0gY29sb3JzLnN1cHBvcnRzQ29sb3IoKSAhPT0gZmFsc2U7XG59XG5cbmNvbG9ycy5lbmFibGUgPSBmdW5jdGlvbigpIHtcbiAgY29sb3JzLmVuYWJsZWQgPSB0cnVlO1xufTtcblxuY29sb3JzLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgY29sb3JzLmVuYWJsZWQgPSBmYWxzZTtcbn07XG5cbmNvbG9ycy5zdHJpcENvbG9ycyA9IGNvbG9ycy5zdHJpcCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gKCcnICsgc3RyKS5yZXBsYWNlKC9cXHgxQlxcW1xcZCttL2csICcnKTtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xudmFyIHN0eWxpemUgPSBjb2xvcnMuc3R5bGl6ZSA9IGZ1bmN0aW9uIHN0eWxpemUoc3RyLCBzdHlsZSkge1xuICBpZiAoIWNvbG9ycy5lbmFibGVkKSB7XG4gICAgcmV0dXJuIHN0cisnJztcbiAgfVxuXG4gIHZhciBzdHlsZU1hcCA9IGFuc2lTdHlsZXNbc3R5bGVdO1xuXG4gIC8vIFN0eWxpemUgc2hvdWxkIHdvcmsgZm9yIG5vbi1BTlNJIHN0eWxlcywgdG9vXG4gIGlmICghc3R5bGVNYXAgJiYgc3R5bGUgaW4gY29sb3JzKSB7XG4gICAgLy8gU3R5bGUgbWFwcyBsaWtlIHRyYXAgb3BlcmF0ZSBhcyBmdW5jdGlvbnMgb24gc3RyaW5ncztcbiAgICAvLyB0aGV5IGRvbid0IGhhdmUgcHJvcGVydGllcyBsaWtlIG9wZW4gb3IgY2xvc2UuXG4gICAgcmV0dXJuIGNvbG9yc1tzdHlsZV0oc3RyKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZU1hcC5vcGVuICsgc3RyICsgc3R5bGVNYXAuY2xvc2U7XG59O1xuXG52YXIgbWF0Y2hPcGVyYXRvcnNSZSA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZztcbnZhciBlc2NhcGVTdHJpbmdSZWdleHAgPSBmdW5jdGlvbihzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuICByZXR1cm4gc3RyLnJlcGxhY2UobWF0Y2hPcGVyYXRvcnNSZSwgJ1xcXFwkJicpO1xufTtcblxuZnVuY3Rpb24gYnVpbGQoX3N0eWxlcykge1xuICB2YXIgYnVpbGRlciA9IGZ1bmN0aW9uIGJ1aWxkZXIoKSB7XG4gICAgcmV0dXJuIGFwcGx5U3R5bGUuYXBwbHkoYnVpbGRlciwgYXJndW1lbnRzKTtcbiAgfTtcbiAgYnVpbGRlci5fc3R5bGVzID0gX3N0eWxlcztcbiAgLy8gX19wcm90b19fIGlzIHVzZWQgYmVjYXVzZSB3ZSBtdXN0IHJldHVybiBhIGZ1bmN0aW9uLCBidXQgdGhlcmUgaXNcbiAgLy8gbm8gd2F5IHRvIGNyZWF0ZSBhIGZ1bmN0aW9uIHdpdGggYSBkaWZmZXJlbnQgcHJvdG90eXBlLlxuICBidWlsZGVyLl9fcHJvdG9fXyA9IHByb3RvO1xuICByZXR1cm4gYnVpbGRlcjtcbn1cblxudmFyIHN0eWxlcyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHJldCA9IHt9O1xuICBhbnNpU3R5bGVzLmdyZXkgPSBhbnNpU3R5bGVzLmdyYXk7XG4gIE9iamVjdC5rZXlzKGFuc2lTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgYW5zaVN0eWxlc1trZXldLmNsb3NlUmUgPVxuICAgICAgbmV3IFJlZ0V4cChlc2NhcGVTdHJpbmdSZWdleHAoYW5zaVN0eWxlc1trZXldLmNsb3NlKSwgJ2cnKTtcbiAgICByZXRba2V5XSA9IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBidWlsZCh0aGlzLl9zdHlsZXMuY29uY2F0KGtleSkpO1xuICAgICAgfSxcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHJldDtcbn0pKCk7XG5cbnZhciBwcm90byA9IGRlZmluZVByb3BzKGZ1bmN0aW9uIGNvbG9ycygpIHt9LCBzdHlsZXMpO1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlKCkge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgdmFyIHN0ciA9IGFyZ3MubWFwKGZ1bmN0aW9uKGFyZykge1xuICAgIC8vIFVzZSB3ZWFrIGVxdWFsaXR5IGNoZWNrIHNvIHdlIGNhbiBjb2xvcml6ZSBudWxsL3VuZGVmaW5lZCBpbiBzYWZlIG1vZGVcbiAgICBpZiAoYXJnICE9IG51bGwgJiYgYXJnLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1dGlsLmluc3BlY3QoYXJnKTtcbiAgICB9XG4gIH0pLmpvaW4oJyAnKTtcblxuICBpZiAoIWNvbG9ycy5lbmFibGVkIHx8ICFzdHIpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIG5ld0xpbmVzUHJlc2VudCA9IHN0ci5pbmRleE9mKCdcXG4nKSAhPSAtMTtcblxuICB2YXIgbmVzdGVkU3R5bGVzID0gdGhpcy5fc3R5bGVzO1xuXG4gIHZhciBpID0gbmVzdGVkU3R5bGVzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBjb2RlID0gYW5zaVN0eWxlc1tuZXN0ZWRTdHlsZXNbaV1dO1xuICAgIHN0ciA9IGNvZGUub3BlbiArIHN0ci5yZXBsYWNlKGNvZGUuY2xvc2VSZSwgY29kZS5vcGVuKSArIGNvZGUuY2xvc2U7XG4gICAgaWYgKG5ld0xpbmVzUHJlc2VudCkge1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UobmV3TGluZVJlZ2V4LCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICByZXR1cm4gY29kZS5jbG9zZSArIG1hdGNoICsgY29kZS5vcGVuO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuY29sb3JzLnNldFRoZW1lID0gZnVuY3Rpb24odGhlbWUpIHtcbiAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zb2xlLmxvZygnY29sb3JzLnNldFRoZW1lIG5vdyBvbmx5IGFjY2VwdHMgYW4gb2JqZWN0LCBub3QgYSBzdHJpbmcuICAnICtcbiAgICAgICdJZiB5b3UgYXJlIHRyeWluZyB0byBzZXQgYSB0aGVtZSBmcm9tIGEgZmlsZSwgaXQgaXMgbm93IHlvdXIgKHRoZSAnICtcbiAgICAgICdjYWxsZXJcXCdzKSByZXNwb25zaWJpbGl0eSB0byByZXF1aXJlIHRoZSBmaWxlLiAgVGhlIG9sZCBzeW50YXggJyArXG4gICAgICAnbG9va2VkIGxpa2UgY29sb3JzLnNldFRoZW1lKF9fZGlybmFtZSArICcgK1xuICAgICAgJ1xcJy8uLi90aGVtZXMvZ2VuZXJpYy1sb2dnaW5nLmpzXFwnKTsgVGhlIG5ldyBzeW50YXggbG9va3MgbGlrZSAnK1xuICAgICAgJ2NvbG9ycy5zZXRUaGVtZShyZXF1aXJlKF9fZGlybmFtZSArICcgK1xuICAgICAgJ1xcJy8uLi90aGVtZXMvZ2VuZXJpYy1sb2dnaW5nLmpzXFwnKSk7Jyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIHN0eWxlIGluIHRoZW1lKSB7XG4gICAgKGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICBjb2xvcnNbc3R5bGVdID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhlbWVbc3R5bGVdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHZhciBvdXQgPSBzdHI7XG4gICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGVtZVtzdHlsZV0pIHtcbiAgICAgICAgICAgIG91dCA9IGNvbG9yc1t0aGVtZVtzdHlsZV1baV1dKG91dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbG9yc1t0aGVtZVtzdHlsZV1dKHN0cik7XG4gICAgICB9O1xuICAgIH0pKHN0eWxlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgdmFyIHJldCA9IHt9O1xuICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgIHJldFtuYW1lXSA9IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBidWlsZChbbmFtZV0pO1xuICAgICAgfSxcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHJldDtcbn1cblxudmFyIHNlcXVlbmNlciA9IGZ1bmN0aW9uIHNlcXVlbmNlcihtYXAsIHN0cikge1xuICB2YXIgZXhwbG9kZWQgPSBzdHIuc3BsaXQoJycpO1xuICBleHBsb2RlZCA9IGV4cGxvZGVkLm1hcChtYXApO1xuICByZXR1cm4gZXhwbG9kZWQuam9pbignJyk7XG59O1xuXG4vLyBjdXN0b20gZm9ybWF0dGVyIG1ldGhvZHNcbmNvbG9ycy50cmFwID0gcmVxdWlyZSgnLi9jdXN0b20vdHJhcCcpO1xuY29sb3JzLnphbGdvID0gcmVxdWlyZSgnLi9jdXN0b20vemFsZ28nKTtcblxuLy8gbWFwc1xuY29sb3JzLm1hcHMgPSB7fTtcbmNvbG9ycy5tYXBzLmFtZXJpY2EgPSByZXF1aXJlKCcuL21hcHMvYW1lcmljYScpKGNvbG9ycyk7XG5jb2xvcnMubWFwcy56ZWJyYSA9IHJlcXVpcmUoJy4vbWFwcy96ZWJyYScpKGNvbG9ycyk7XG5jb2xvcnMubWFwcy5yYWluYm93ID0gcmVxdWlyZSgnLi9tYXBzL3JhaW5ib3cnKShjb2xvcnMpO1xuY29sb3JzLm1hcHMucmFuZG9tID0gcmVxdWlyZSgnLi9tYXBzL3JhbmRvbScpKGNvbG9ycyk7XG5cbmZvciAodmFyIG1hcCBpbiBjb2xvcnMubWFwcykge1xuICAoZnVuY3Rpb24obWFwKSB7XG4gICAgY29sb3JzW21hcF0gPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZXIoY29sb3JzLm1hcHNbbWFwXSwgc3RyKTtcbiAgICB9O1xuICB9KShtYXApO1xufVxuXG5kZWZpbmVQcm9wcyhjb2xvcnMsIGluaXQoKSk7XG4iLCAiLy9cbi8vIFJlbWFyazogUmVxdWlyaW5nIHRoaXMgZmlsZSB3aWxsIHVzZSB0aGUgXCJzYWZlXCIgY29sb3JzIEFQSSxcbi8vIHdoaWNoIHdpbGwgbm90IHRvdWNoIFN0cmluZy5wcm90b3R5cGUuXG4vL1xuLy8gICB2YXIgY29sb3JzID0gcmVxdWlyZSgnY29sb3JzL3NhZmUnKTtcbi8vICAgY29sb3JzLnJlZChcImZvb1wiKVxuLy9cbi8vXG52YXIgY29sb3JzID0gcmVxdWlyZSgnLi9saWIvY29sb3JzJyk7XG5tb2R1bGVbJ2V4cG9ydHMnXSA9IGNvbG9ycztcbiIsICIvKipcbiAqIGNsaS5qczogQ29uZmlnIHRoYXQgY29uZm9ybSB0byBjb21tb25seSB1c2VkIENMSSBsb2dnaW5nIGxldmVscy5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERlZmF1bHQgbGV2ZWxzIGZvciB0aGUgQ0xJIGNvbmZpZ3VyYXRpb24uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLmxldmVscyA9IHtcbiAgZXJyb3I6IDAsXG4gIHdhcm46IDEsXG4gIGhlbHA6IDIsXG4gIGRhdGE6IDMsXG4gIGluZm86IDQsXG4gIGRlYnVnOiA1LFxuICBwcm9tcHQ6IDYsXG4gIHZlcmJvc2U6IDcsXG4gIGlucHV0OiA4LFxuICBzaWxseTogOVxufTtcblxuLyoqXG4gKiBEZWZhdWx0IGNvbG9ycyBmb3IgdGhlIENMSSBjb25maWd1cmF0aW9uLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5jb2xvcnMgPSB7XG4gIGVycm9yOiAncmVkJyxcbiAgd2FybjogJ3llbGxvdycsXG4gIGhlbHA6ICdjeWFuJyxcbiAgZGF0YTogJ2dyZXknLFxuICBpbmZvOiAnZ3JlZW4nLFxuICBkZWJ1ZzogJ2JsdWUnLFxuICBwcm9tcHQ6ICdncmV5JyxcbiAgdmVyYm9zZTogJ2N5YW4nLFxuICBpbnB1dDogJ2dyZXknLFxuICBzaWxseTogJ21hZ2VudGEnXG59O1xuIiwgIi8qKlxuICogbnBtLmpzOiBDb25maWcgdGhhdCBjb25mb3JtIHRvIG5wbSBsb2dnaW5nIGxldmVscy5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERlZmF1bHQgbGV2ZWxzIGZvciB0aGUgbnBtIGNvbmZpZ3VyYXRpb24uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLmxldmVscyA9IHtcbiAgZXJyb3I6IDAsXG4gIHdhcm46IDEsXG4gIGluZm86IDIsXG4gIGh0dHA6IDMsXG4gIHZlcmJvc2U6IDQsXG4gIGRlYnVnOiA1LFxuICBzaWxseTogNlxufTtcblxuLyoqXG4gKiBEZWZhdWx0IGxldmVscyBmb3IgdGhlIG5wbSBjb25maWd1cmF0aW9uLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5jb2xvcnMgPSB7XG4gIGVycm9yOiAncmVkJyxcbiAgd2FybjogJ3llbGxvdycsXG4gIGluZm86ICdncmVlbicsXG4gIGh0dHA6ICdncmVlbicsXG4gIHZlcmJvc2U6ICdjeWFuJyxcbiAgZGVidWc6ICdibHVlJyxcbiAgc2lsbHk6ICdtYWdlbnRhJ1xufTtcbiIsICIvKipcbiAqIHN5c2xvZy5qczogQ29uZmlnIHRoYXQgY29uZm9ybSB0byBzeXNsb2cgbG9nZ2luZyBsZXZlbHMuXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZWZhdWx0IGxldmVscyBmb3IgdGhlIHN5c2xvZyBjb25maWd1cmF0aW9uLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5sZXZlbHMgPSB7XG4gIGVtZXJnOiAwLFxuICBhbGVydDogMSxcbiAgY3JpdDogMixcbiAgZXJyb3I6IDMsXG4gIHdhcm5pbmc6IDQsXG4gIG5vdGljZTogNSxcbiAgaW5mbzogNixcbiAgZGVidWc6IDdcbn07XG5cbi8qKlxuICogRGVmYXVsdCBsZXZlbHMgZm9yIHRoZSBzeXNsb2cgY29uZmlndXJhdGlvbi5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuY29sb3JzID0ge1xuICBlbWVyZzogJ3JlZCcsXG4gIGFsZXJ0OiAneWVsbG93JyxcbiAgY3JpdDogJ3JlZCcsXG4gIGVycm9yOiAncmVkJyxcbiAgd2FybmluZzogJ3JlZCcsXG4gIG5vdGljZTogJ3llbGxvdycsXG4gIGluZm86ICdncmVlbicsXG4gIGRlYnVnOiAnYmx1ZSdcbn07XG4iLCAiLyoqXG4gKiBpbmRleC5qczogRGVmYXVsdCBzZXR0aW5ncyBmb3IgYWxsIGxldmVscyB0aGF0IHdpbnN0b24ga25vd3MgYWJvdXQuXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFeHBvcnQgY29uZmlnIHNldCBmb3IgdGhlIENMSS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY2xpJywge1xuICB2YWx1ZTogcmVxdWlyZSgnLi9jbGknKVxufSk7XG5cbi8qKlxuICogRXhwb3J0IGNvbmZpZyBzZXQgZm9yIG5wbS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnbnBtJywge1xuICB2YWx1ZTogcmVxdWlyZSgnLi9ucG0nKVxufSk7XG5cbi8qKlxuICogRXhwb3J0IGNvbmZpZyBzZXQgZm9yIHRoZSBzeXNsb2cuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3N5c2xvZycsIHtcbiAgdmFsdWU6IHJlcXVpcmUoJy4vc3lzbG9nJylcbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIHNoYXJlYWJsZSBzeW1ib2wgY29uc3RhbnQgdGhhdCBjYW4gYmUgdXNlZFxuICogYXMgYSBub24tZW51bWVyYWJsZSAvIHNlbWktaGlkZGVuIGxldmVsIGlkZW50aWZpZXJcbiAqIHRvIGFsbG93IHRoZSByZWFkYWJsZSBsZXZlbCBwcm9wZXJ0eSB0byBiZSBtdXRhYmxlIGZvclxuICogb3BlcmF0aW9ucyBsaWtlIGNvbG9yaXphdGlvblxuICpcbiAqIEB0eXBlIHtTeW1ib2x9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTEVWRUwnLCB7XG4gIHZhbHVlOiBTeW1ib2wuZm9yKCdsZXZlbCcpXG59KTtcblxuLyoqXG4gKiBBIHNoYXJlYWJsZSBzeW1ib2wgY29uc3RhbnQgdGhhdCBjYW4gYmUgdXNlZFxuICogYXMgYSBub24tZW51bWVyYWJsZSAvIHNlbWktaGlkZGVuIG1lc3NhZ2UgaWRlbnRpZmllclxuICogdG8gYWxsb3cgdGhlIGZpbmFsIG1lc3NhZ2UgcHJvcGVydHkgdG8gbm90IGhhdmVcbiAqIHNpZGUgZWZmZWN0cyBvbiBhbm90aGVyLlxuICpcbiAqIEB0eXBlIHtTeW1ib2x9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTUVTU0FHRScsIHtcbiAgdmFsdWU6IFN5bWJvbC5mb3IoJ21lc3NhZ2UnKVxufSk7XG5cbi8qKlxuICogQSBzaGFyZWFibGUgc3ltYm9sIGNvbnN0YW50IHRoYXQgY2FuIGJlIHVzZWRcbiAqIGFzIGEgbm9uLWVudW1lcmFibGUgLyBzZW1pLWhpZGRlbiBtZXNzYWdlIGlkZW50aWZpZXJcbiAqIHRvIGFsbG93IHRoZSBleHRyYWN0ZWQgc3BsYXQgcHJvcGVydHkgYmUgaGlkZGVuXG4gKlxuICogQHR5cGUge1N5bWJvbH1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTUExBVCcsIHtcbiAgdmFsdWU6IFN5bWJvbC5mb3IoJ3NwbGF0Jylcbn0pO1xuXG4vKipcbiAqIEEgc2hhcmVhYmxlIG9iamVjdCBjb25zdGFudCAgdGhhdCBjYW4gYmUgdXNlZFxuICogYXMgYSBzdGFuZGFyZCBjb25maWd1cmF0aW9uIGZvciB3aW5zdG9uQDMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjb25maWdzJywge1xuICB2YWx1ZTogcmVxdWlyZSgnLi9jb25maWcnKVxufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjb2xvcnMgPSByZXF1aXJlKCdAY29sb3JzL2NvbG9ycy9zYWZlJyk7XG5jb25zdCB7IExFVkVMLCBNRVNTQUdFIH0gPSByZXF1aXJlKCd0cmlwbGUtYmVhbScpO1xuXG4vL1xuLy8gRml4IGNvbG9ycyBub3QgYXBwZWFyaW5nIGluIG5vbi10dHkgZW52aXJvbm1lbnRzXG4vL1xuY29sb3JzLmVuYWJsZWQgPSB0cnVlO1xuXG4vKipcbiAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBoYXNTcGFjZVxuICogU2ltcGxlIHJlZ2V4IHRvIGNoZWNrIGZvciBwcmVzZW5jZSBvZiBzcGFjZXMuXG4gKi9cbmNvbnN0IGhhc1NwYWNlID0gL1xccysvO1xuXG4vKlxuICogQ29sb3JpemVyIGZvcm1hdC4gV3JhcHMgdGhlIGBsZXZlbGAgYW5kL29yIGBtZXNzYWdlYCBwcm9wZXJ0aWVzXG4gKiBvZiB0aGUgYGluZm9gIG9iamVjdHMgd2l0aCBBTlNJIGNvbG9yIGNvZGVzIGJhc2VkIG9uIGEgZmV3IG9wdGlvbnMuXG4gKi9cbmNsYXNzIENvbG9yaXplciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGlmIChvcHRzLmNvbG9ycykge1xuICAgICAgdGhpcy5hZGRDb2xvcnMob3B0cy5jb2xvcnMpO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdHM7XG4gIH1cblxuICAvKlxuICAgKiBBZGRzIHRoZSBjb2xvcnMgT2JqZWN0IHRvIHRoZSBzZXQgb2YgYWxsQ29sb3JzXG4gICAqIGtub3duIGJ5IHRoZSBDb2xvcml6ZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbG9ycyBTZXQgb2YgY29sb3IgbWFwcGluZ3MgdG8gYWRkLlxuICAgKi9cbiAgc3RhdGljIGFkZENvbG9ycyhjbHJzKSB7XG4gICAgY29uc3QgbmV4dENvbG9ycyA9IE9iamVjdC5rZXlzKGNscnMpLnJlZHVjZSgoYWNjLCBsZXZlbCkgPT4ge1xuICAgICAgYWNjW2xldmVsXSA9IGhhc1NwYWNlLnRlc3QoY2xyc1tsZXZlbF0pXG4gICAgICAgID8gY2xyc1tsZXZlbF0uc3BsaXQoaGFzU3BhY2UpXG4gICAgICAgIDogY2xyc1tsZXZlbF07XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuXG4gICAgQ29sb3JpemVyLmFsbENvbG9ycyA9IE9iamVjdC5hc3NpZ24oe30sIENvbG9yaXplci5hbGxDb2xvcnMgfHwge30sIG5leHRDb2xvcnMpO1xuICAgIHJldHVybiBDb2xvcml6ZXIuYWxsQ29sb3JzO1xuICB9XG5cbiAgLypcbiAgICogQWRkcyB0aGUgY29sb3JzIE9iamVjdCB0byB0aGUgc2V0IG9mIGFsbENvbG9yc1xuICAgKiBrbm93biBieSB0aGUgQ29sb3JpemVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvcnMgU2V0IG9mIGNvbG9yIG1hcHBpbmdzIHRvIGFkZC5cbiAgICovXG4gIGFkZENvbG9ycyhjbHJzKSB7XG4gICAgcmV0dXJuIENvbG9yaXplci5hZGRDb2xvcnMoY2xycyk7XG4gIH1cblxuICAvKlxuICAgKiBmdW5jdGlvbiBjb2xvcml6ZSAobG9va3VwLCBsZXZlbCwgbWVzc2FnZSlcbiAgICogUGVyZm9ybXMgbXVsdGktc3RlcCBjb2xvcml6YXRpb24gdXNpbmcgQGNvbG9ycy9jb2xvcnMvc2FmZVxuICAgKi9cbiAgY29sb3JpemUobG9va3VwLCBsZXZlbCwgbWVzc2FnZSkge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG1lc3NhZ2UgPSBsZXZlbDtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIElmIHRoZSBjb2xvciBmb3IgdGhlIGxldmVsIGlzIGp1c3QgYSBzdHJpbmdcbiAgICAvLyB0aGVuIGF0dGVtcHQgdG8gY29sb3JpemUgdGhlIG1lc3NhZ2Ugd2l0aCBpdC5cbiAgICAvL1xuICAgIGlmICghQXJyYXkuaXNBcnJheShDb2xvcml6ZXIuYWxsQ29sb3JzW2xvb2t1cF0pKSB7XG4gICAgICByZXR1cm4gY29sb3JzW0NvbG9yaXplci5hbGxDb2xvcnNbbG9va3VwXV0obWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBJZiBpdCBpcyBhbiBBcnJheSB0aGVuIGl0ZXJhdGUgb3ZlciB0aGF0IEFycmF5LCBhcHBseWluZ1xuICAgIC8vIHRoZSBjb2xvcnMgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAgICAvL1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBDb2xvcml6ZXIuYWxsQ29sb3JzW2xvb2t1cF0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1lc3NhZ2UgPSBjb2xvcnNbQ29sb3JpemVyLmFsbENvbG9yc1tsb29rdXBdW2ldXShtZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuXG4gIC8qXG4gICAqIGZ1bmN0aW9uIHRyYW5zZm9ybSAoaW5mbywgb3B0cylcbiAgICogQXR0ZW1wdHMgdG8gY29sb3JpemUgdGhlIHsgbGV2ZWwsIG1lc3NhZ2UgfSBvZiB0aGUgZ2l2ZW5cbiAgICogYGxvZ2Zvcm1gIGluZm8gb2JqZWN0LlxuICAgKi9cbiAgdHJhbnNmb3JtKGluZm8sIG9wdHMpIHtcbiAgICBpZiAob3B0cy5hbGwgJiYgdHlwZW9mIGluZm9bTUVTU0FHRV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbmZvW01FU1NBR0VdID0gdGhpcy5jb2xvcml6ZShpbmZvW0xFVkVMXSwgaW5mby5sZXZlbCwgaW5mb1tNRVNTQUdFXSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMubGV2ZWwgfHwgb3B0cy5hbGwgfHwgIW9wdHMubWVzc2FnZSkge1xuICAgICAgaW5mby5sZXZlbCA9IHRoaXMuY29sb3JpemUoaW5mb1tMRVZFTF0sIGluZm8ubGV2ZWwpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmFsbCB8fCBvcHRzLm1lc3NhZ2UpIHtcbiAgICAgIGluZm8ubWVzc2FnZSA9IHRoaXMuY29sb3JpemUoaW5mb1tMRVZFTF0sIGluZm8ubGV2ZWwsIGluZm8ubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cblxuLypcbiAqIGZ1bmN0aW9uIGNvbG9yaXplIChpbmZvKVxuICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgY29sb3JpemUgRm9ybWF0IHRoYXQgYXBwbGllc1xuICogbGV2ZWwgY29sb3JzIHRvIGBpbmZvYCBvYmplY3RzLiBUaGlzIHdhcyBwcmV2aW91c2x5IGV4cG9zZWRcbiAqIGFzIHsgY29sb3JpemU6IHRydWUgfSB0byB0cmFuc3BvcnRzIGluIGB3aW5zdG9uIDwgMy4wLjBgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IG9wdHMgPT4gbmV3IENvbG9yaXplcihvcHRzKTtcblxuLy9cbi8vIEF0dGFjaCB0aGUgQ29sb3JpemVyIGZvciByZWdpc3RyYXRpb24gcHVycG9zZXNcbi8vXG5tb2R1bGUuZXhwb3J0cy5Db2xvcml6ZXJcbiAgPSBtb2R1bGUuZXhwb3J0cy5Gb3JtYXRcbiAgPSBDb2xvcml6ZXI7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IENvbG9yaXplciB9ID0gcmVxdWlyZSgnLi9jb2xvcml6ZScpO1xuXG4vKlxuICogU2ltcGxlIG1ldGhvZCB0byByZWdpc3RlciBjb2xvcnMgd2l0aCBhIHNpbXBsZXIgcmVxdWlyZVxuICogcGF0aCB3aXRoaW4gdGhlIG1vZHVsZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjb25maWcgPT4ge1xuICBDb2xvcml6ZXIuYWRkQ29sb3JzKGNvbmZpZy5jb2xvcnMgfHwgY29uZmlnKTtcbiAgcmV0dXJuIGNvbmZpZztcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBmb3JtYXQgPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xuXG4vKlxuICogZnVuY3Rpb24gYWxpZ24gKGluZm8pXG4gKiBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBhbGlnbiBGb3JtYXQgd2hpY2ggYWRkcyBhIGBcXHRgXG4gKiBkZWxpbWl0ZXIgYmVmb3JlIHRoZSBtZXNzYWdlIHRvIHByb3Blcmx5IGFsaWduIGl0IGluIHRoZSBzYW1lIHBsYWNlLlxuICogSXQgd2FzIHByZXZpb3VzbHkgeyBhbGlnbjogdHJ1ZSB9IGluIHdpbnN0b24gPCAzLjAuMFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcm1hdChpbmZvID0+IHtcbiAgaW5mby5tZXNzYWdlID0gYFxcdCR7aW5mby5tZXNzYWdlfWA7XG4gIHJldHVybiBpbmZvO1xufSk7XG4iLCAiLyogZXNsaW50IG5vLXVuZGVmaW5lZDogMCAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBmb3JtYXQgPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xuY29uc3QgeyBMRVZFTCwgTUVTU0FHRSB9ID0gcmVxdWlyZSgndHJpcGxlLWJlYW0nKTtcblxuLypcbiAqIGZ1bmN0aW9uIGVycm9ycyAoaW5mbylcbiAqIElmIHRoZSBgbWVzc2FnZWAgcHJvcGVydHkgb2YgdGhlIGBpbmZvYCBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgYEVycm9yYCxcbiAqIHJlcGxhY2UgdGhlIGBFcnJvcmAgb2JqZWN0IGl0cyBvd24gYG1lc3NhZ2VgIHByb3BlcnR5LlxuICpcbiAqIE9wdGlvbmFsbHksIHRoZSBFcnJvcidzIGBzdGFja2AgYW5kL29yIGBjYXVzZWAgcHJvcGVydGllcyBjYW4gYWxzbyBiZSBhcHBlbmRlZCB0byB0aGUgYGluZm9gIG9iamVjdC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JtYXQoKGVpbmZvLCB7IHN0YWNrLCBjYXVzZSB9KSA9PiB7XG4gIGlmIChlaW5mbyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgY29uc3QgaW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIGVpbmZvLCB7XG4gICAgICBsZXZlbDogZWluZm8ubGV2ZWwsXG4gICAgICBbTEVWRUxdOiBlaW5mb1tMRVZFTF0gfHwgZWluZm8ubGV2ZWwsXG4gICAgICBtZXNzYWdlOiBlaW5mby5tZXNzYWdlLFxuICAgICAgW01FU1NBR0VdOiBlaW5mb1tNRVNTQUdFXSB8fCBlaW5mby5tZXNzYWdlXG4gICAgfSk7XG5cbiAgICBpZiAoc3RhY2spIGluZm8uc3RhY2sgPSBlaW5mby5zdGFjaztcbiAgICBpZiAoY2F1c2UpIGluZm8uY2F1c2UgPSBlaW5mby5jYXVzZTtcbiAgICByZXR1cm4gaW5mbztcbiAgfVxuXG4gIGlmICghKGVpbmZvLm1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikpIHJldHVybiBlaW5mbztcblxuICAvLyBBc3NpZ24gYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyBhbmQgdGhlXG4gIC8vIG1lc3NhZ2UgcHJvcGVydHkgZnJvbSB0aGUgZXJyb3IgcHJvdmlkZWQuXG4gIGNvbnN0IGVyciA9IGVpbmZvLm1lc3NhZ2U7XG4gIE9iamVjdC5hc3NpZ24oZWluZm8sIGVycik7XG4gIGVpbmZvLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgZWluZm9bTUVTU0FHRV0gPSBlcnIubWVzc2FnZTtcblxuICAvLyBBc3NpZ24gdGhlIHN0YWNrIGFuZC9vciBjYXVzZSBpZiByZXF1ZXN0ZWQuXG4gIGlmIChzdGFjaykgZWluZm8uc3RhY2sgPSBlcnIuc3RhY2s7XG4gIGlmIChjYXVzZSkgZWluZm8uY2F1c2UgPSBlcnIuY2F1c2U7XG4gIHJldHVybiBlaW5mbztcbn0pO1xuIiwgIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogMCAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IGNvbmZpZ3MsIExFVkVMLCBNRVNTQUdFIH0gPSByZXF1aXJlKCd0cmlwbGUtYmVhbScpO1xuXG5jbGFzcyBQYWRkZXIge1xuICBjb25zdHJ1Y3RvcihvcHRzID0geyBsZXZlbHM6IGNvbmZpZ3MubnBtLmxldmVscyB9KSB7XG4gICAgdGhpcy5wYWRkaW5ncyA9IFBhZGRlci5wYWRkaW5nRm9yTGV2ZWxzKG9wdHMubGV2ZWxzLCBvcHRzLmZpbGxlcik7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIGxlbmd0aCBvZiBrZXlzIGluIHRoZSBzcGVjaWZpZWQgYGxldmVsc2AgT2JqZWN0LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGxldmVscyBTZXQgb2YgYWxsIGxldmVscyB0byBjYWxjdWxhdGUgbG9uZ2VzdCBsZXZlbCBhZ2FpbnN0LlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBNYXhpbXVtIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdCBsZXZlbCBzdHJpbmcuXG4gICAqL1xuICBzdGF0aWMgZ2V0TG9uZ2VzdExldmVsKGxldmVscykge1xuICAgIGNvbnN0IGx2bHMgPSBPYmplY3Qua2V5cyhsZXZlbHMpLm1hcChsZXZlbCA9PiBsZXZlbC5sZW5ndGgpO1xuICAgIHJldHVybiBNYXRoLm1heCguLi5sdmxzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYWRkaW5nIGZvciB0aGUgc3BlY2lmaWVkIGBsZXZlbGAgYXNzdW1pbmcgdGhhdCB0aGVcbiAgICogbWF4aW11bSBsZW5ndGggb2YgYWxsIGxldmVscyBpdCdzIGFzc29jaWF0ZWQgd2l0aCBpcyBgbWF4TGVuZ3RoYC5cbiAgICogQHBhcmFtICB7U3RyaW5nfSBsZXZlbCBMZXZlbCB0byBjYWxjdWxhdGUgcGFkZGluZyBmb3IuXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZmlsbGVyIFJlcGVhdGFibGUgdGV4dCB0byB1c2UgZm9yIHBhZGRpbmcuXG4gICAqIEBwYXJhbSAge051bWJlcn0gbWF4TGVuZ3RoIExlbmd0aCBvZiB0aGUgbG9uZ2VzdCBsZXZlbFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBQYWRkaW5nIHN0cmluZyBmb3IgdGhlIGBsZXZlbGBcbiAgICovXG4gIHN0YXRpYyBwYWRkaW5nRm9yTGV2ZWwobGV2ZWwsIGZpbGxlciwgbWF4TGVuZ3RoKSB7XG4gICAgY29uc3QgdGFyZ2V0TGVuID0gbWF4TGVuZ3RoICsgMSAtIGxldmVsLmxlbmd0aDtcbiAgICBjb25zdCByZXAgPSBNYXRoLmZsb29yKHRhcmdldExlbiAvIGZpbGxlci5sZW5ndGgpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBgJHtmaWxsZXJ9JHtmaWxsZXIucmVwZWF0KHJlcCl9YDtcbiAgICByZXR1cm4gcGFkZGluZy5zbGljZSgwLCB0YXJnZXRMZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHN0cmluZyBwYWRkaW5ncyBmb3IgdGhlIGdpdmVuIGBsZXZlbHNgXG4gICAqIHVzaW5nIHRoZSBzcGVjaWZpZWQgYGZpbGxlcmAuXG4gICAqIEBwYXJhbSAge09iamVjdH0gbGV2ZWxzIFNldCBvZiBhbGwgbGV2ZWxzIHRvIGNhbGN1bGF0ZSBwYWRkaW5nIGZvci5cbiAgICogQHBhcmFtICB7U3RyaW5nfSBmaWxsZXIgUmVwZWF0YWJsZSB0ZXh0IHRvIHVzZSBmb3IgcGFkZGluZy5cbiAgICogQHJldHVybnMge09iamVjdH0gTWFwcGluZyBvZiBsZXZlbCB0byBkZXNpcmVkIHBhZGRpbmcuXG4gICAqL1xuICBzdGF0aWMgcGFkZGluZ0ZvckxldmVscyhsZXZlbHMsIGZpbGxlciA9ICcgJykge1xuICAgIGNvbnN0IG1heExlbmd0aCA9IFBhZGRlci5nZXRMb25nZXN0TGV2ZWwobGV2ZWxzKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobGV2ZWxzKS5yZWR1Y2UoKGFjYywgbGV2ZWwpID0+IHtcbiAgICAgIGFjY1tsZXZlbF0gPSBQYWRkZXIucGFkZGluZ0ZvckxldmVsKGxldmVsLCBmaWxsZXIsIG1heExlbmd0aCk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwZW5kcyB0aGUgcGFkZGluZyBvbnRvIHRoZSBgbWVzc2FnZWAgYmFzZWQgb24gdGhlIGBMRVZFTGAgb2ZcbiAgICogdGhlIGBpbmZvYC4gVGhpcyBpcyBiYXNlZCBvbiB0aGUgYmVoYXZpb3Igb2YgYHdpbnN0b25AMmAgd2hpY2ggYWxzb1xuICAgKiBwcmVwZW5kZWQgdGhlIGxldmVsIG9udG8gdGhlIG1lc3NhZ2UuXG4gICAqXG4gICAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3dpbnN0b25qcy93aW5zdG9uL2Jsb2IvMi54L2xpYi93aW5zdG9uL2xvZ2dlci5qcyNMMTk4LUwyMDFcbiAgICpcbiAgICogQHBhcmFtICB7SW5mb30gaW5mbyBMb2dmb3JtIGluZm8gb2JqZWN0XG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBPcHRpb25zIHBhc3NlZCBhbG9uZyB0byB0aGlzIGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyB7SW5mb30gTW9kaWZpZWQgbG9nZm9ybSBpbmZvIG9iamVjdC5cbiAgICovXG4gIHRyYW5zZm9ybShpbmZvLCBvcHRzKSB7XG4gICAgaW5mby5tZXNzYWdlID0gYCR7dGhpcy5wYWRkaW5nc1tpbmZvW0xFVkVMXV19JHtpbmZvLm1lc3NhZ2V9YDtcbiAgICBpZiAoaW5mb1tNRVNTQUdFXSkge1xuICAgICAgaW5mb1tNRVNTQUdFXSA9IGAke3RoaXMucGFkZGluZ3NbaW5mb1tMRVZFTF1dfSR7aW5mb1tNRVNTQUdFXX1gO1xuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG5cbi8qXG4gKiBmdW5jdGlvbiBwYWRMZXZlbHMgKGluZm8pXG4gKiBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBwYWRMZXZlbHMgRm9ybWF0IHdoaWNoIHBhZHNcbiAqIGxldmVscyB0byBiZSB0aGUgc2FtZSBsZW5ndGguIFRoaXMgd2FzIHByZXZpb3VzbHkgZXhwb3NlZCBhc1xuICogeyBwYWRMZXZlbHM6IHRydWUgfSB0byB0cmFuc3BvcnRzIGluIGB3aW5zdG9uIDwgMy4wLjBgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IG9wdHMgPT4gbmV3IFBhZGRlcihvcHRzKTtcblxubW9kdWxlLmV4cG9ydHMuUGFkZGVyXG4gID0gbW9kdWxlLmV4cG9ydHMuRm9ybWF0XG4gID0gUGFkZGVyO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBDb2xvcml6ZXIgfSA9IHJlcXVpcmUoJy4vY29sb3JpemUnKTtcbmNvbnN0IHsgUGFkZGVyIH0gPSByZXF1aXJlKCcuL3BhZC1sZXZlbHMnKTtcbmNvbnN0IHsgY29uZmlncywgTUVTU0FHRSB9ID0gcmVxdWlyZSgndHJpcGxlLWJlYW0nKTtcblxuXG4vKipcbiAqIENsaSBmb3JtYXQgY2xhc3MgdGhhdCBoYW5kbGVzIGluaXRpYWwgc3RhdGUgZm9yIGEgYSBzZXBhcmF0ZVxuICogQ29sb3JpemVyIGFuZCBQYWRkZXIgaW5zdGFuY2UuXG4gKi9cbmNsYXNzIENsaUZvcm1hdCB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGlmICghb3B0cy5sZXZlbHMpIHtcbiAgICAgIG9wdHMubGV2ZWxzID0gY29uZmlncy5jbGkubGV2ZWxzO1xuICAgIH1cblxuICAgIHRoaXMuY29sb3JpemVyID0gbmV3IENvbG9yaXplcihvcHRzKTtcbiAgICB0aGlzLnBhZGRlciA9IG5ldyBQYWRkZXIob3B0cyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0cztcbiAgfVxuXG4gIC8qXG4gICAqIGZ1bmN0aW9uIHRyYW5zZm9ybSAoaW5mbywgb3B0cylcbiAgICogQXR0ZW1wdHMgdG8gYm90aDpcbiAgICogMS4gUGFkIHRoZSB7IGxldmVsIH1cbiAgICogMi4gQ29sb3JpemUgdGhlIHsgbGV2ZWwsIG1lc3NhZ2UgfVxuICAgKiBvZiB0aGUgZ2l2ZW4gYGxvZ2Zvcm1gIGluZm8gb2JqZWN0IGRlcGVuZGluZyBvbiB0aGUgYG9wdHNgLlxuICAgKi9cbiAgdHJhbnNmb3JtKGluZm8sIG9wdHMpIHtcbiAgICB0aGlzLmNvbG9yaXplci50cmFuc2Zvcm0oXG4gICAgICB0aGlzLnBhZGRlci50cmFuc2Zvcm0oaW5mbywgb3B0cyksXG4gICAgICBvcHRzXG4gICAgKTtcblxuICAgIGluZm9bTUVTU0FHRV0gPSBgJHtpbmZvLmxldmVsfToke2luZm8ubWVzc2FnZX1gO1xuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG5cbi8qXG4gKiBmdW5jdGlvbiBjbGkgKG9wdHMpXG4gKiBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBDTEkgZm9ybWF0IHRoYXQgdHVybnMgYSBsb2dcbiAqIGBpbmZvYCBvYmplY3QgaW50byB0aGUgc2FtZSBmb3JtYXQgcHJldmlvdXNseSBhdmFpbGFibGVcbiAqIGluIGB3aW5zdG9uLmNsaSgpYCBpbiBgd2luc3RvbiA8IDMuMC4wYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBvcHRzID0+IG5ldyBDbGlGb3JtYXQob3B0cyk7XG5cbi8vXG4vLyBBdHRhY2ggdGhlIENsaUZvcm1hdCBmb3IgcmVnaXN0cmF0aW9uIHB1cnBvc2VzXG4vL1xubW9kdWxlLmV4cG9ydHMuRm9ybWF0ID0gQ2xpRm9ybWF0O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZm9ybWF0ID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcblxuLypcbiAqIGZ1bmN0aW9uIGNhc2NhZGUoZm9ybWF0cylcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIGAuX2Zvcm1hdGAgZnVuY3Rpb24gaW4tb3JkZXJcbiAqIGZvciB0aGUgc3BlY2lmaWVkIHNldCBvZiBgZm9ybWF0c2AuIEluIHRoaXMgbWFubmVyIHdlIHNheSB0aGF0IEZvcm1hdHNcbiAqIGFyZSBcInBpcGUtbGlrZVwiLCBidXQgbm90IGEgcHVyZSBwdW1waWZ5IGltcGxlbWVudGF0aW9uLiBTaW5jZSB0aGVyZSBpcyBubyBiYWNrXG4gKiBwcmVzc3VyZSB3ZSBjYW4gcmVtb3ZlIGFsbCBvZiB0aGUgXCJyZWFkYWJsZVwiIHBsdW1iaW5nIGluIE5vZGUgc3RyZWFtcy5cbiAqL1xuZnVuY3Rpb24gY2FzY2FkZShmb3JtYXRzKSB7XG4gIGlmICghZm9ybWF0cy5ldmVyeShpc1ZhbGlkRm9ybWF0KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBpbmZvID0+IHtcbiAgICBsZXQgb2JqID0gaW5mbztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iaiA9IGZvcm1hdHNbaV0udHJhbnNmb3JtKG9iaiwgZm9ybWF0c1tpXS5vcHRpb25zKTtcbiAgICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufVxuXG4vKlxuICogZnVuY3Rpb24gaXNWYWxpZEZvcm1hdChmb3JtYXQpXG4gKiBJZiB0aGUgZm9ybWF0IGRvZXMgbm90IGRlZmluZSBhIGB0cmFuc2Zvcm1gIGZ1bmN0aW9uIHRocm93IGFuIGVycm9yXG4gKiB3aXRoIG1vcmUgZGV0YWlsZWQgdXNhZ2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRGb3JtYXQoZm10KSB7XG4gIGlmICh0eXBlb2YgZm10LnRyYW5zZm9ybSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAnTm8gdHJhbnNmb3JtIGZ1bmN0aW9uIGZvdW5kIG9uIGZvcm1hdC4gRGlkIHlvdSBjcmVhdGUgYSBmb3JtYXQgaW5zdGFuY2U/JyxcbiAgICAgICdjb25zdCBteUZvcm1hdCA9IGZvcm1hdChmb3JtYXRGbik7JyxcbiAgICAgICdjb25zdCBpbnN0YW5jZSA9IG15Rm9ybWF0KCk7J1xuICAgIF0uam9pbignXFxuJykpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qXG4gKiBmdW5jdGlvbiBjb21iaW5lIChpbmZvKVxuICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgY29tYmluZSBGb3JtYXQgd2hpY2ggY29tYmluZXMgdGhlIHNwZWNpZmllZFxuICogZm9ybWF0cyBpbnRvIGEgbmV3IGZvcm1hdC4gVGhpcyBpcyBzaW1pbGFyIHRvIGEgcGlwZS1jaGFpbiBpbiB0cmFuc2Zvcm0gc3RyZWFtcy5cbiAqIFdlIGNob29zZSB0byBjb21iaW5lIHRoZSBwcm90b3R5cGVzIHRoaXMgd2F5IGJlY2F1c2UgdGhlcmUgaXMgbm8gYmFjayBwcmVzc3VyZSBpblxuICogYW4gaW4tbWVtb3J5IHRyYW5zZm9ybSBjaGFpbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoLi4uZm9ybWF0cykgPT4ge1xuICBjb25zdCBjb21iaW5lZEZvcm1hdCA9IGZvcm1hdChjYXNjYWRlKGZvcm1hdHMpKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBjb21iaW5lZEZvcm1hdCgpO1xuICBpbnN0YW5jZS5Gb3JtYXQgPSBjb21iaW5lZEZvcm1hdC5Gb3JtYXQ7XG4gIHJldHVybiBpbnN0YW5jZTtcbn07XG5cbi8vXG4vLyBFeHBvcnQgdGhlIGNhc2NhZGUgbWV0aG9kIGZvciB1c2UgaW4gY2xpIGFuZCBvdGhlclxuLy8gY29tYmluZWQgZm9ybWF0cyB0aGF0IHNob3VsZCBub3QgYmUgYXNzdW1lZCB0byBiZVxuLy8gc2luZ2xldG9ucy5cbi8vXG5tb2R1bGUuZXhwb3J0cy5jYXNjYWRlID0gY2FzY2FkZTtcbiIsICIndXNlIHN0cmljdCdcblxuY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSB9ID0gT2JqZWN0LnByb3RvdHlwZVxuXG5jb25zdCBzdHJpbmdpZnkgPSBjb25maWd1cmUoKVxuXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5zdHJpbmdpZnkuY29uZmlndXJlID0gY29uZmlndXJlXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5zdHJpbmdpZnkuc3RyaW5naWZ5ID0gc3RyaW5naWZ5XG5cbi8vIEB0cy1leHBlY3QtZXJyb3JcbnN0cmluZ2lmeS5kZWZhdWx0ID0gc3RyaW5naWZ5XG5cbi8vIEB0cy1leHBlY3QtZXJyb3IgdXNlZCBmb3IgbmFtZWQgZXhwb3J0XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeVxuLy8gQHRzLWV4cGVjdC1lcnJvciB1c2VkIGZvciBuYW1lZCBleHBvcnRcbmV4cG9ydHMuY29uZmlndXJlID0gY29uZmlndXJlXG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG5jb25zdCBzdHJFc2NhcGVTZXF1ZW5jZXNSZWdFeHAgPSAvW1xcdTAwMDAtXFx1MDAxZlxcdTAwMjJcXHUwMDVjXFx1ZDgwMC1cXHVkZmZmXXxbXFx1ZDgwMC1cXHVkYmZmXSg/IVtcXHVkYzAwLVxcdWRmZmZdKXwoPzpbXlxcdWQ4MDAtXFx1ZGJmZl18XilbXFx1ZGMwMC1cXHVkZmZmXS9cblxuLy8gRXNjYXBlIEMwIGNvbnRyb2wgY2hhcmFjdGVycywgZG91YmxlIHF1b3RlcywgdGhlIGJhY2tzbGFzaCBhbmQgZXZlcnkgY29kZVxuLy8gdW5pdCB3aXRoIGEgbnVtZXJpYyB2YWx1ZSBpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIDB4RDgwMCB0byAweERGRkYuXG5mdW5jdGlvbiBzdHJFc2NhcGUgKHN0cikge1xuICAvLyBTb21lIG1hZ2ljIG51bWJlcnMgdGhhdCB3b3JrZWQgb3V0IGZpbmUgd2hpbGUgYmVuY2htYXJraW5nIHdpdGggdjggOC4wXG4gIGlmIChzdHIubGVuZ3RoIDwgNTAwMCAmJiAhc3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBgXCIke3N0cn1cImBcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RyKVxufVxuXG5mdW5jdGlvbiBpbnNlcnRTb3J0IChhcnJheSkge1xuICAvLyBJbnNlcnRpb24gc29ydCBpcyB2ZXJ5IGVmZmljaWVudCBmb3Igc21hbGwgaW5wdXQgc2l6ZXMgYnV0IGl0IGhhcyBhIGJhZFxuICAvLyB3b3JzdCBjYXNlIGNvbXBsZXhpdHkuIFRodXMsIHVzZSBuYXRpdmUgYXJyYXkgc29ydCBmb3IgYmlnZ2VyIHZhbHVlcy5cbiAgaWYgKGFycmF5Lmxlbmd0aCA+IDJlMikge1xuICAgIHJldHVybiBhcnJheS5zb3J0KClcbiAgfVxuICBmb3IgKGxldCBpID0gMTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gYXJyYXlbaV1cbiAgICBsZXQgcG9zaXRpb24gPSBpXG4gICAgd2hpbGUgKHBvc2l0aW9uICE9PSAwICYmIGFycmF5W3Bvc2l0aW9uIC0gMV0gPiBjdXJyZW50VmFsdWUpIHtcbiAgICAgIGFycmF5W3Bvc2l0aW9uXSA9IGFycmF5W3Bvc2l0aW9uIC0gMV1cbiAgICAgIHBvc2l0aW9uLS1cbiAgICB9XG4gICAgYXJyYXlbcG9zaXRpb25dID0gY3VycmVudFZhbHVlXG4gIH1cbiAgcmV0dXJuIGFycmF5XG59XG5cbmNvbnN0IHR5cGVkQXJyYXlQcm90b3R5cGVHZXRTeW1ib2xUb1N0cmluZ1RhZyA9XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKFxuICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKFxuICAgICAgICBuZXcgSW50OEFycmF5KClcbiAgICAgIClcbiAgICApLFxuICAgIFN5bWJvbC50b1N0cmluZ1RhZ1xuICApLmdldFxuXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXlXaXRoRW50cmllcyAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVkQXJyYXlQcm90b3R5cGVHZXRTeW1ib2xUb1N0cmluZ1RhZy5jYWxsKHZhbHVlKSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCAhPT0gMFxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlUeXBlZEFycmF5IChhcnJheSwgc2VwYXJhdG9yLCBtYXhpbXVtQnJlYWR0aCkge1xuICBpZiAoYXJyYXkubGVuZ3RoIDwgbWF4aW11bUJyZWFkdGgpIHtcbiAgICBtYXhpbXVtQnJlYWR0aCA9IGFycmF5Lmxlbmd0aFxuICB9XG4gIGNvbnN0IHdoaXRlc3BhY2UgPSBzZXBhcmF0b3IgPT09ICcsJyA/ICcnIDogJyAnXG4gIGxldCByZXMgPSBgXCIwXCI6JHt3aGl0ZXNwYWNlfSR7YXJyYXlbMF19YFxuICBmb3IgKGxldCBpID0gMTsgaSA8IG1heGltdW1CcmVhZHRoOyBpKyspIHtcbiAgICByZXMgKz0gYCR7c2VwYXJhdG9yfVwiJHtpfVwiOiR7d2hpdGVzcGFjZX0ke2FycmF5W2ldfWBcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldENpcmN1bGFyVmFsdWVPcHRpb24gKG9wdGlvbnMpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ2NpcmN1bGFyVmFsdWUnKSkge1xuICAgIGNvbnN0IGNpcmN1bGFyVmFsdWUgPSBvcHRpb25zLmNpcmN1bGFyVmFsdWVcbiAgICBpZiAodHlwZW9mIGNpcmN1bGFyVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gYFwiJHtjaXJjdWxhclZhbHVlfVwiYFxuICAgIH1cbiAgICBpZiAoY2lyY3VsYXJWYWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2lyY3VsYXJWYWx1ZVxuICAgIH1cbiAgICBpZiAoY2lyY3VsYXJWYWx1ZSA9PT0gRXJyb3IgfHwgY2lyY3VsYXJWYWx1ZSA9PT0gVHlwZUVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b1N0cmluZyAoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gSlNPTicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiY2lyY3VsYXJWYWx1ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcgb3IgdGhlIHZhbHVlIG51bGwgb3IgdW5kZWZpbmVkJylcbiAgfVxuICByZXR1cm4gJ1wiW0NpcmN1bGFyXVwiJ1xufVxuXG5mdW5jdGlvbiBnZXRCb29sZWFuT3B0aW9uIChvcHRpb25zLCBrZXkpIHtcbiAgbGV0IHZhbHVlXG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIGtleSkpIHtcbiAgICB2YWx1ZSA9IG9wdGlvbnNba2V5XVxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtrZXl9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW5gKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBnZXRQb3NpdGl2ZUludGVnZXJPcHRpb24gKG9wdGlvbnMsIGtleSkge1xuICBsZXQgdmFsdWVcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywga2V5KSkge1xuICAgIHZhbHVlID0gb3B0aW9uc1trZXldXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7a2V5fVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXJgKVxuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke2tleX1cIiBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXJgKVxuICAgIH1cbiAgICBpZiAodmFsdWUgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlIFwiJHtrZXl9XCIgYXJndW1lbnQgbXVzdCBiZSA+PSAxYClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHZhbHVlXG59XG5cbmZ1bmN0aW9uIGdldEl0ZW1Db3VudCAobnVtYmVyKSB7XG4gIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICByZXR1cm4gJzEgaXRlbSdcbiAgfVxuICByZXR1cm4gYCR7bnVtYmVyfSBpdGVtc2Bcbn1cblxuZnVuY3Rpb24gZ2V0VW5pcXVlUmVwbGFjZXJTZXQgKHJlcGxhY2VyQXJyYXkpIHtcbiAgY29uc3QgcmVwbGFjZXJTZXQgPSBuZXcgU2V0KClcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiByZXBsYWNlckFycmF5KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgcmVwbGFjZXJTZXQuYWRkKFN0cmluZyh2YWx1ZSkpXG4gICAgfVxuICB9XG4gIHJldHVybiByZXBsYWNlclNldFxufVxuXG5mdW5jdGlvbiBnZXRTdHJpY3RPcHRpb24gKG9wdGlvbnMpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3N0cmljdCcpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnN0cmljdFxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW4nKVxuICAgIH1cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBgT2JqZWN0IGNhbiBub3Qgc2FmZWx5IGJlIHN0cmluZ2lmaWVkLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIHZhbHVlfWBcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykgbWVzc2FnZSArPSBgICgke3ZhbHVlLnRvU3RyaW5nKCl9KWBcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZSAob3B0aW9ucykge1xuICBvcHRpb25zID0geyAuLi5vcHRpb25zIH1cbiAgY29uc3QgZmFpbCA9IGdldFN0cmljdE9wdGlvbihvcHRpb25zKVxuICBpZiAoZmFpbCkge1xuICAgIGlmIChvcHRpb25zLmJpZ2ludCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLmJpZ2ludCA9IGZhbHNlXG4gICAgfVxuICAgIGlmICghKCdjaXJjdWxhclZhbHVlJyBpbiBvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucy5jaXJjdWxhclZhbHVlID0gRXJyb3JcbiAgICB9XG4gIH1cbiAgY29uc3QgY2lyY3VsYXJWYWx1ZSA9IGdldENpcmN1bGFyVmFsdWVPcHRpb24ob3B0aW9ucylcbiAgY29uc3QgYmlnaW50ID0gZ2V0Qm9vbGVhbk9wdGlvbihvcHRpb25zLCAnYmlnaW50JylcbiAgY29uc3QgZGV0ZXJtaW5pc3RpYyA9IGdldEJvb2xlYW5PcHRpb24ob3B0aW9ucywgJ2RldGVybWluaXN0aWMnKVxuICBjb25zdCBtYXhpbXVtRGVwdGggPSBnZXRQb3NpdGl2ZUludGVnZXJPcHRpb24ob3B0aW9ucywgJ21heGltdW1EZXB0aCcpXG4gIGNvbnN0IG1heGltdW1CcmVhZHRoID0gZ2V0UG9zaXRpdmVJbnRlZ2VyT3B0aW9uKG9wdGlvbnMsICdtYXhpbXVtQnJlYWR0aCcpXG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5Rm5SZXBsYWNlciAoa2V5LCBwYXJlbnQsIHN0YWNrLCByZXBsYWNlciwgc3BhY2VyLCBpbmRlbnRhdGlvbikge1xuICAgIGxldCB2YWx1ZSA9IHBhcmVudFtrZXldXG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpXG4gICAgfVxuICAgIHZhbHVlID0gcmVwbGFjZXIuY2FsbChwYXJlbnQsIGtleSwgdmFsdWUpXG5cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIHN0ckVzY2FwZSh2YWx1ZSlcbiAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICdudWxsJ1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gY2lyY3VsYXJWYWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlcyA9ICcnXG4gICAgICAgIGxldCBqb2luID0gJywnXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSW5kZW50YXRpb24gPSBpbmRlbnRhdGlvblxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnW10nXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhpbXVtRGVwdGggPCBzdGFjay5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1wiW0FycmF5XVwiJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKVxuICAgICAgICAgIGlmIChzcGFjZXIgIT09ICcnKSB7XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSBzcGFjZXJcbiAgICAgICAgICAgIHJlcyArPSBgXFxuJHtpbmRlbnRhdGlvbn1gXG4gICAgICAgICAgICBqb2luID0gYCxcXG4ke2luZGVudGF0aW9ufWBcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbWF4aW11bVZhbHVlc1RvU3RyaW5naWZ5ID0gTWF0aC5taW4odmFsdWUubGVuZ3RoLCBtYXhpbXVtQnJlYWR0aClcbiAgICAgICAgICBsZXQgaSA9IDBcbiAgICAgICAgICBmb3IgKDsgaSA8IG1heGltdW1WYWx1ZXNUb1N0cmluZ2lmeSAtIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG1wID0gc3RyaW5naWZ5Rm5SZXBsYWNlcihTdHJpbmcoaSksIHZhbHVlLCBzdGFjaywgcmVwbGFjZXIsIHNwYWNlciwgaW5kZW50YXRpb24pXG4gICAgICAgICAgICByZXMgKz0gdG1wICE9PSB1bmRlZmluZWQgPyB0bXAgOiAnbnVsbCdcbiAgICAgICAgICAgIHJlcyArPSBqb2luXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRtcCA9IHN0cmluZ2lmeUZuUmVwbGFjZXIoU3RyaW5nKGkpLCB2YWx1ZSwgc3RhY2ssIHJlcGxhY2VyLCBzcGFjZXIsIGluZGVudGF0aW9uKVxuICAgICAgICAgIHJlcyArPSB0bXAgIT09IHVuZGVmaW5lZCA/IHRtcCA6ICdudWxsJ1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggLSAxID4gbWF4aW11bUJyZWFkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRLZXlzID0gdmFsdWUubGVuZ3RoIC0gbWF4aW11bUJyZWFkdGggLSAxXG4gICAgICAgICAgICByZXMgKz0gYCR7am9pbn1cIi4uLiAke2dldEl0ZW1Db3VudChyZW1vdmVkS2V5cyl9IG5vdCBzdHJpbmdpZmllZFwiYFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3BhY2VyICE9PSAnJykge1xuICAgICAgICAgICAgcmVzICs9IGBcXG4ke29yaWdpbmFsSW5kZW50YXRpb259YFxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICAgIHJldHVybiBgWyR7cmVzfV1gXG4gICAgICAgIH1cblxuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKVxuICAgICAgICBjb25zdCBrZXlMZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgICBpZiAoa2V5TGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuICd7fSdcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4aW11bURlcHRoIDwgc3RhY2subGVuZ3RoICsgMSkge1xuICAgICAgICAgIHJldHVybiAnXCJbT2JqZWN0XVwiJ1xuICAgICAgICB9XG4gICAgICAgIGxldCB3aGl0ZXNwYWNlID0gJydcbiAgICAgICAgbGV0IHNlcGFyYXRvciA9ICcnXG4gICAgICAgIGlmIChzcGFjZXIgIT09ICcnKSB7XG4gICAgICAgICAgaW5kZW50YXRpb24gKz0gc3BhY2VyXG4gICAgICAgICAgam9pbiA9IGAsXFxuJHtpbmRlbnRhdGlvbn1gXG4gICAgICAgICAgd2hpdGVzcGFjZSA9ICcgJ1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1heGltdW1Qcm9wZXJ0aWVzVG9TdHJpbmdpZnkgPSBNYXRoLm1pbihrZXlMZW5ndGgsIG1heGltdW1CcmVhZHRoKVxuICAgICAgICBpZiAoZGV0ZXJtaW5pc3RpYyAmJiAhaXNUeXBlZEFycmF5V2l0aEVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAga2V5cyA9IGluc2VydFNvcnQoa2V5cylcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wdXNoKHZhbHVlKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heGltdW1Qcm9wZXJ0aWVzVG9TdHJpbmdpZnk7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICAgICAgICBjb25zdCB0bXAgPSBzdHJpbmdpZnlGblJlcGxhY2VyKGtleSwgdmFsdWUsIHN0YWNrLCByZXBsYWNlciwgc3BhY2VyLCBpbmRlbnRhdGlvbilcbiAgICAgICAgICBpZiAodG1wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlcyArPSBgJHtzZXBhcmF0b3J9JHtzdHJFc2NhcGUoa2V5KX06JHt3aGl0ZXNwYWNlfSR7dG1wfWBcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IGpvaW5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUxlbmd0aCA+IG1heGltdW1CcmVhZHRoKSB7XG4gICAgICAgICAgY29uc3QgcmVtb3ZlZEtleXMgPSBrZXlMZW5ndGggLSBtYXhpbXVtQnJlYWR0aFxuICAgICAgICAgIHJlcyArPSBgJHtzZXBhcmF0b3J9XCIuLi5cIjoke3doaXRlc3BhY2V9XCIke2dldEl0ZW1Db3VudChyZW1vdmVkS2V5cyl9IG5vdCBzdHJpbmdpZmllZFwiYFxuICAgICAgICAgIHNlcGFyYXRvciA9IGpvaW5cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BhY2VyICE9PSAnJyAmJiBzZXBhcmF0b3IubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJlcyA9IGBcXG4ke2luZGVudGF0aW9ufSR7cmVzfVxcbiR7b3JpZ2luYWxJbmRlbnRhdGlvbn1gXG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucG9wKClcbiAgICAgICAgcmV0dXJuIGB7JHtyZXN9fWBcbiAgICAgIH1cbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogZmFpbCA/IGZhaWwodmFsdWUpIDogJ251bGwnXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlID8gJ3RydWUnIDogJ2ZhbHNlJ1xuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgY2FzZSAnYmlnaW50JzpcbiAgICAgICAgaWYgKGJpZ2ludCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWlsID8gZmFpbCh2YWx1ZSkgOiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlBcnJheVJlcGxhY2VyIChrZXksIHZhbHVlLCBzdGFjaywgcmVwbGFjZXIsIHNwYWNlciwgaW5kZW50YXRpb24pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpXG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiBzdHJFc2NhcGUodmFsdWUpXG4gICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAnbnVsbCdcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGNpcmN1bGFyVmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSW5kZW50YXRpb24gPSBpbmRlbnRhdGlvblxuICAgICAgICBsZXQgcmVzID0gJydcbiAgICAgICAgbGV0IGpvaW4gPSAnLCdcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tdJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4aW11bURlcHRoIDwgc3RhY2subGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgcmV0dXJuICdcIltBcnJheV1cIidcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSlcbiAgICAgICAgICBpZiAoc3BhY2VyICE9PSAnJykge1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gc3BhY2VyXG4gICAgICAgICAgICByZXMgKz0gYFxcbiR7aW5kZW50YXRpb259YFxuICAgICAgICAgICAgam9pbiA9IGAsXFxuJHtpbmRlbnRhdGlvbn1gXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG1heGltdW1WYWx1ZXNUb1N0cmluZ2lmeSA9IE1hdGgubWluKHZhbHVlLmxlbmd0aCwgbWF4aW11bUJyZWFkdGgpXG4gICAgICAgICAgbGV0IGkgPSAwXG4gICAgICAgICAgZm9yICg7IGkgPCBtYXhpbXVtVmFsdWVzVG9TdHJpbmdpZnkgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IHN0cmluZ2lmeUFycmF5UmVwbGFjZXIoU3RyaW5nKGkpLCB2YWx1ZVtpXSwgc3RhY2ssIHJlcGxhY2VyLCBzcGFjZXIsIGluZGVudGF0aW9uKVxuICAgICAgICAgICAgcmVzICs9IHRtcCAhPT0gdW5kZWZpbmVkID8gdG1wIDogJ251bGwnXG4gICAgICAgICAgICByZXMgKz0gam9pblxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0bXAgPSBzdHJpbmdpZnlBcnJheVJlcGxhY2VyKFN0cmluZyhpKSwgdmFsdWVbaV0sIHN0YWNrLCByZXBsYWNlciwgc3BhY2VyLCBpbmRlbnRhdGlvbilcbiAgICAgICAgICByZXMgKz0gdG1wICE9PSB1bmRlZmluZWQgPyB0bXAgOiAnbnVsbCdcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoIC0gMSA+IG1heGltdW1CcmVhZHRoKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkS2V5cyA9IHZhbHVlLmxlbmd0aCAtIG1heGltdW1CcmVhZHRoIC0gMVxuICAgICAgICAgICAgcmVzICs9IGAke2pvaW59XCIuLi4gJHtnZXRJdGVtQ291bnQocmVtb3ZlZEtleXMpfSBub3Qgc3RyaW5naWZpZWRcImBcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNwYWNlciAhPT0gJycpIHtcbiAgICAgICAgICAgIHJlcyArPSBgXFxuJHtvcmlnaW5hbEluZGVudGF0aW9ufWBcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhY2sucG9wKClcbiAgICAgICAgICByZXR1cm4gYFske3Jlc31dYFxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2godmFsdWUpXG4gICAgICAgIGxldCB3aGl0ZXNwYWNlID0gJydcbiAgICAgICAgaWYgKHNwYWNlciAhPT0gJycpIHtcbiAgICAgICAgICBpbmRlbnRhdGlvbiArPSBzcGFjZXJcbiAgICAgICAgICBqb2luID0gYCxcXG4ke2luZGVudGF0aW9ufWBcbiAgICAgICAgICB3aGl0ZXNwYWNlID0gJyAnXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlcGFyYXRvciA9ICcnXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHJlcGxhY2VyKSB7XG4gICAgICAgICAgY29uc3QgdG1wID0gc3RyaW5naWZ5QXJyYXlSZXBsYWNlcihrZXksIHZhbHVlW2tleV0sIHN0YWNrLCByZXBsYWNlciwgc3BhY2VyLCBpbmRlbnRhdGlvbilcbiAgICAgICAgICBpZiAodG1wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlcyArPSBgJHtzZXBhcmF0b3J9JHtzdHJFc2NhcGUoa2V5KX06JHt3aGl0ZXNwYWNlfSR7dG1wfWBcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IGpvaW5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwYWNlciAhPT0gJycgJiYgc2VwYXJhdG9yLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXMgPSBgXFxuJHtpbmRlbnRhdGlvbn0ke3Jlc31cXG4ke29yaWdpbmFsSW5kZW50YXRpb259YFxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnBvcCgpXG4gICAgICAgIHJldHVybiBgeyR7cmVzfX1gXG4gICAgICB9XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6IGZhaWwgPyBmYWlsKHZhbHVlKSA6ICdudWxsJ1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSA/ICd0cnVlJyA6ICdmYWxzZSdcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgIGlmIChiaWdpbnQpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKVxuICAgICAgICB9XG4gICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFpbCA/IGZhaWwodmFsdWUpIDogdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5SW5kZW50IChrZXksIHZhbHVlLCBzdGFjaywgc3BhY2VyLCBpbmRlbnRhdGlvbikge1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gc3RyRXNjYXBlKHZhbHVlKVxuICAgICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gJ251bGwnXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpXG4gICAgICAgICAgLy8gUHJldmVudCBjYWxsaW5nIGB0b0pTT05gIGFnYWluLlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5SW5kZW50KGtleSwgdmFsdWUsIHN0YWNrLCBzcGFjZXIsIGluZGVudGF0aW9uKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnbnVsbCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiBjaXJjdWxhclZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxJbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uXG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdbXSdcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heGltdW1EZXB0aCA8IHN0YWNrLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICAgIHJldHVybiAnXCJbQXJyYXldXCInXG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpXG4gICAgICAgICAgaW5kZW50YXRpb24gKz0gc3BhY2VyXG4gICAgICAgICAgbGV0IHJlcyA9IGBcXG4ke2luZGVudGF0aW9ufWBcbiAgICAgICAgICBjb25zdCBqb2luID0gYCxcXG4ke2luZGVudGF0aW9ufWBcbiAgICAgICAgICBjb25zdCBtYXhpbXVtVmFsdWVzVG9TdHJpbmdpZnkgPSBNYXRoLm1pbih2YWx1ZS5sZW5ndGgsIG1heGltdW1CcmVhZHRoKVxuICAgICAgICAgIGxldCBpID0gMFxuICAgICAgICAgIGZvciAoOyBpIDwgbWF4aW11bVZhbHVlc1RvU3RyaW5naWZ5IC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSBzdHJpbmdpZnlJbmRlbnQoU3RyaW5nKGkpLCB2YWx1ZVtpXSwgc3RhY2ssIHNwYWNlciwgaW5kZW50YXRpb24pXG4gICAgICAgICAgICByZXMgKz0gdG1wICE9PSB1bmRlZmluZWQgPyB0bXAgOiAnbnVsbCdcbiAgICAgICAgICAgIHJlcyArPSBqb2luXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRtcCA9IHN0cmluZ2lmeUluZGVudChTdHJpbmcoaSksIHZhbHVlW2ldLCBzdGFjaywgc3BhY2VyLCBpbmRlbnRhdGlvbilcbiAgICAgICAgICByZXMgKz0gdG1wICE9PSB1bmRlZmluZWQgPyB0bXAgOiAnbnVsbCdcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoIC0gMSA+IG1heGltdW1CcmVhZHRoKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkS2V5cyA9IHZhbHVlLmxlbmd0aCAtIG1heGltdW1CcmVhZHRoIC0gMVxuICAgICAgICAgICAgcmVzICs9IGAke2pvaW59XCIuLi4gJHtnZXRJdGVtQ291bnQocmVtb3ZlZEtleXMpfSBub3Qgc3RyaW5naWZpZWRcImBcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzICs9IGBcXG4ke29yaWdpbmFsSW5kZW50YXRpb259YFxuICAgICAgICAgIHN0YWNrLnBvcCgpXG4gICAgICAgICAgcmV0dXJuIGBbJHtyZXN9XWBcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpXG4gICAgICAgIGNvbnN0IGtleUxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAgIGlmIChrZXlMZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gJ3t9J1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhpbXVtRGVwdGggPCBzdGFjay5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgcmV0dXJuICdcIltPYmplY3RdXCInXG4gICAgICAgIH1cbiAgICAgICAgaW5kZW50YXRpb24gKz0gc3BhY2VyXG4gICAgICAgIGNvbnN0IGpvaW4gPSBgLFxcbiR7aW5kZW50YXRpb259YFxuICAgICAgICBsZXQgcmVzID0gJydcbiAgICAgICAgbGV0IHNlcGFyYXRvciA9ICcnXG4gICAgICAgIGxldCBtYXhpbXVtUHJvcGVydGllc1RvU3RyaW5naWZ5ID0gTWF0aC5taW4oa2V5TGVuZ3RoLCBtYXhpbXVtQnJlYWR0aClcbiAgICAgICAgaWYgKGlzVHlwZWRBcnJheVdpdGhFbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgIHJlcyArPSBzdHJpbmdpZnlUeXBlZEFycmF5KHZhbHVlLCBqb2luLCBtYXhpbXVtQnJlYWR0aClcbiAgICAgICAgICBrZXlzID0ga2V5cy5zbGljZSh2YWx1ZS5sZW5ndGgpXG4gICAgICAgICAgbWF4aW11bVByb3BlcnRpZXNUb1N0cmluZ2lmeSAtPSB2YWx1ZS5sZW5ndGhcbiAgICAgICAgICBzZXBhcmF0b3IgPSBqb2luXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRldGVybWluaXN0aWMpIHtcbiAgICAgICAgICBrZXlzID0gaW5zZXJ0U29ydChrZXlzKVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2godmFsdWUpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4aW11bVByb3BlcnRpZXNUb1N0cmluZ2lmeTsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgICAgIGNvbnN0IHRtcCA9IHN0cmluZ2lmeUluZGVudChrZXksIHZhbHVlW2tleV0sIHN0YWNrLCBzcGFjZXIsIGluZGVudGF0aW9uKVxuICAgICAgICAgIGlmICh0bXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzICs9IGAke3NlcGFyYXRvcn0ke3N0ckVzY2FwZShrZXkpfTogJHt0bXB9YFxuICAgICAgICAgICAgc2VwYXJhdG9yID0gam9pblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5TGVuZ3RoID4gbWF4aW11bUJyZWFkdGgpIHtcbiAgICAgICAgICBjb25zdCByZW1vdmVkS2V5cyA9IGtleUxlbmd0aCAtIG1heGltdW1CcmVhZHRoXG4gICAgICAgICAgcmVzICs9IGAke3NlcGFyYXRvcn1cIi4uLlwiOiBcIiR7Z2V0SXRlbUNvdW50KHJlbW92ZWRLZXlzKX0gbm90IHN0cmluZ2lmaWVkXCJgXG4gICAgICAgICAgc2VwYXJhdG9yID0gam9pblxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXBhcmF0b3IgIT09ICcnKSB7XG4gICAgICAgICAgcmVzID0gYFxcbiR7aW5kZW50YXRpb259JHtyZXN9XFxuJHtvcmlnaW5hbEluZGVudGF0aW9ufWBcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICByZXR1cm4gYHske3Jlc319YFxuICAgICAgfVxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiBmYWlsID8gZmFpbCh2YWx1ZSkgOiAnbnVsbCdcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgPyAndHJ1ZScgOiAnZmFsc2UnXG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICBpZiAoYmlnaW50KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhaWwgPyBmYWlsKHZhbHVlKSA6IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeVNpbXBsZSAoa2V5LCB2YWx1ZSwgc3RhY2spIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIHN0ckVzY2FwZSh2YWx1ZSlcbiAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICdudWxsJ1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KVxuICAgICAgICAgIC8vIFByZXZlbnQgY2FsbGluZyBgdG9KU09OYCBhZ2FpblxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5U2ltcGxlKGtleSwgdmFsdWUsIHN0YWNrKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnbnVsbCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiBjaXJjdWxhclZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzID0gJydcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tdJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4aW11bURlcHRoIDwgc3RhY2subGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgcmV0dXJuICdcIltBcnJheV1cIidcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSlcbiAgICAgICAgICBjb25zdCBtYXhpbXVtVmFsdWVzVG9TdHJpbmdpZnkgPSBNYXRoLm1pbih2YWx1ZS5sZW5ndGgsIG1heGltdW1CcmVhZHRoKVxuICAgICAgICAgIGxldCBpID0gMFxuICAgICAgICAgIGZvciAoOyBpIDwgbWF4aW11bVZhbHVlc1RvU3RyaW5naWZ5IC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSBzdHJpbmdpZnlTaW1wbGUoU3RyaW5nKGkpLCB2YWx1ZVtpXSwgc3RhY2spXG4gICAgICAgICAgICByZXMgKz0gdG1wICE9PSB1bmRlZmluZWQgPyB0bXAgOiAnbnVsbCdcbiAgICAgICAgICAgIHJlcyArPSAnLCdcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdG1wID0gc3RyaW5naWZ5U2ltcGxlKFN0cmluZyhpKSwgdmFsdWVbaV0sIHN0YWNrKVxuICAgICAgICAgIHJlcyArPSB0bXAgIT09IHVuZGVmaW5lZCA/IHRtcCA6ICdudWxsJ1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggLSAxID4gbWF4aW11bUJyZWFkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRLZXlzID0gdmFsdWUubGVuZ3RoIC0gbWF4aW11bUJyZWFkdGggLSAxXG4gICAgICAgICAgICByZXMgKz0gYCxcIi4uLiAke2dldEl0ZW1Db3VudChyZW1vdmVkS2V5cyl9IG5vdCBzdHJpbmdpZmllZFwiYFxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICAgIHJldHVybiBgWyR7cmVzfV1gXG4gICAgICAgIH1cblxuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKVxuICAgICAgICBjb25zdCBrZXlMZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgICBpZiAoa2V5TGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuICd7fSdcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4aW11bURlcHRoIDwgc3RhY2subGVuZ3RoICsgMSkge1xuICAgICAgICAgIHJldHVybiAnXCJbT2JqZWN0XVwiJ1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZXBhcmF0b3IgPSAnJ1xuICAgICAgICBsZXQgbWF4aW11bVByb3BlcnRpZXNUb1N0cmluZ2lmeSA9IE1hdGgubWluKGtleUxlbmd0aCwgbWF4aW11bUJyZWFkdGgpXG4gICAgICAgIGlmIChpc1R5cGVkQXJyYXlXaXRoRW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICByZXMgKz0gc3RyaW5naWZ5VHlwZWRBcnJheSh2YWx1ZSwgJywnLCBtYXhpbXVtQnJlYWR0aClcbiAgICAgICAgICBrZXlzID0ga2V5cy5zbGljZSh2YWx1ZS5sZW5ndGgpXG4gICAgICAgICAgbWF4aW11bVByb3BlcnRpZXNUb1N0cmluZ2lmeSAtPSB2YWx1ZS5sZW5ndGhcbiAgICAgICAgICBzZXBhcmF0b3IgPSAnLCdcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0ZXJtaW5pc3RpYykge1xuICAgICAgICAgIGtleXMgPSBpbnNlcnRTb3J0KGtleXMpXG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhpbXVtUHJvcGVydGllc1RvU3RyaW5naWZ5OyBpKyspIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgICAgICAgY29uc3QgdG1wID0gc3RyaW5naWZ5U2ltcGxlKGtleSwgdmFsdWVba2V5XSwgc3RhY2spXG4gICAgICAgICAgaWYgKHRtcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXMgKz0gYCR7c2VwYXJhdG9yfSR7c3RyRXNjYXBlKGtleSl9OiR7dG1wfWBcbiAgICAgICAgICAgIHNlcGFyYXRvciA9ICcsJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5TGVuZ3RoID4gbWF4aW11bUJyZWFkdGgpIHtcbiAgICAgICAgICBjb25zdCByZW1vdmVkS2V5cyA9IGtleUxlbmd0aCAtIG1heGltdW1CcmVhZHRoXG4gICAgICAgICAgcmVzICs9IGAke3NlcGFyYXRvcn1cIi4uLlwiOlwiJHtnZXRJdGVtQ291bnQocmVtb3ZlZEtleXMpfSBub3Qgc3RyaW5naWZpZWRcImBcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICByZXR1cm4gYHske3Jlc319YFxuICAgICAgfVxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiBmYWlsID8gZmFpbCh2YWx1ZSkgOiAnbnVsbCdcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgPyAndHJ1ZScgOiAnZmFsc2UnXG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICBpZiAoYmlnaW50KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhaWwgPyBmYWlsKHZhbHVlKSA6IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeSAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgbGV0IHNwYWNlciA9ICcnXG4gICAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykge1xuICAgICAgICBzcGFjZXIgPSAnICcucmVwZWF0KE1hdGgubWluKHNwYWNlLCAxMCkpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3BhY2VyID0gc3BhY2Uuc2xpY2UoMCwgMTApXG4gICAgICB9XG4gICAgICBpZiAocmVwbGFjZXIgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUZuUmVwbGFjZXIoJycsIHsgJyc6IHZhbHVlIH0sIFtdLCByZXBsYWNlciwgc3BhY2VyLCAnJylcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXlSZXBsYWNlcignJywgdmFsdWUsIFtdLCBnZXRVbmlxdWVSZXBsYWNlclNldChyZXBsYWNlciksIHNwYWNlciwgJycpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzcGFjZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlJbmRlbnQoJycsIHZhbHVlLCBbXSwgc3BhY2VyLCAnJylcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ2lmeVNpbXBsZSgnJywgdmFsdWUsIFtdKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ2lmeVxufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZm9ybWF0ID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcbmNvbnN0IHsgTUVTU0FHRSB9ID0gcmVxdWlyZSgndHJpcGxlLWJlYW0nKTtcbmNvbnN0IHN0cmluZ2lmeSA9IHJlcXVpcmUoJ3NhZmUtc3RhYmxlLXN0cmluZ2lmeScpO1xuXG4vKlxuICogZnVuY3Rpb24gcmVwbGFjZXIgKGtleSwgdmFsdWUpXG4gKiBIYW5kbGVzIHByb3BlciBzdHJpbmdpZmljYXRpb24gb2YgQnVmZmVyIGFuZCBiaWdpbnQgb3V0cHV0LlxuICovXG5mdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIC8vIHNhZmUtc3RhYmxlLXN0cmluZ2lmeSBkb2VzIHN1cHBvcnQgQmlnSW50LCBob3dldmVyLCBpdCBkb2Vzbid0IHdyYXAgdGhlIHZhbHVlIGluIHF1b3Rlcy5cbiAgLy8gTGVhZGluZyB0byBhIGxvc3MgaW4gZmlkZWxpdHkgaWYgdGhlIHJlc3VsdGluZyBzdHJpbmcgaXMgcGFyc2VkLlxuICAvLyBJdCB3b3VsZCBhbHNvIGJlIGEgYnJlYWtpbmcgY2hhbmdlIGZvciBsb2dmb3JtLlxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKlxuICogZnVuY3Rpb24ganNvbiAoaW5mbylcbiAqIFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEpTT04gZm9ybWF0IHRoYXQgdHVybnMgYSBsb2cgYGluZm9gXG4gKiBvYmplY3QgaW50byBwdXJlIEpTT04uIFRoaXMgd2FzIHByZXZpb3VzbHkgZXhwb3NlZCBhcyB7IGpzb246IHRydWUgfVxuICogdG8gdHJhbnNwb3J0cyBpbiBgd2luc3RvbiA8IDMuMC4wYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JtYXQoKGluZm8sIG9wdHMpID0+IHtcbiAgY29uc3QganNvblN0cmluZ2lmeSA9IHN0cmluZ2lmeS5jb25maWd1cmUob3B0cyk7XG4gIGluZm9bTUVTU0FHRV0gPSBqc29uU3RyaW5naWZ5KGluZm8sIG9wdHMucmVwbGFjZXIgfHwgcmVwbGFjZXIsIG9wdHMuc3BhY2UpO1xuICByZXR1cm4gaW5mbztcbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZm9ybWF0ID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcblxuLypcbiAqIGZ1bmN0aW9uIGxhYmVsIChpbmZvKVxuICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgbGFiZWwgRm9ybWF0IHdoaWNoIGFkZHMgdGhlIHNwZWNpZmllZFxuICogYG9wdHMubGFiZWxgIGJlZm9yZSB0aGUgbWVzc2FnZS4gVGhpcyB3YXMgcHJldmlvdXNseSBleHBvc2VkIGFzXG4gKiB7IGxhYmVsOiAnbXkgbGFiZWwnIH0gdG8gdHJhbnNwb3J0cyBpbiBgd2luc3RvbiA8IDMuMC4wYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JtYXQoKGluZm8sIG9wdHMpID0+IHtcbiAgaWYgKG9wdHMubWVzc2FnZSkge1xuICAgIGluZm8ubWVzc2FnZSA9IGBbJHtvcHRzLmxhYmVsfV0gJHtpbmZvLm1lc3NhZ2V9YDtcbiAgICByZXR1cm4gaW5mbztcbiAgfVxuXG4gIGluZm8ubGFiZWwgPSBvcHRzLmxhYmVsO1xuICByZXR1cm4gaW5mbztcbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZm9ybWF0ID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcbmNvbnN0IHsgTUVTU0FHRSB9ID0gcmVxdWlyZSgndHJpcGxlLWJlYW0nKTtcbmNvbnN0IGpzb25TdHJpbmdpZnkgPSByZXF1aXJlKCdzYWZlLXN0YWJsZS1zdHJpbmdpZnknKTtcblxuLypcbiAqIGZ1bmN0aW9uIGxvZ3N0YXNoIChpbmZvKVxuICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgTG9nU3Rhc2ggRm9ybWF0IHRoYXQgdHVybnMgYVxuICogbG9nIGBpbmZvYCBvYmplY3QgaW50byBwdXJlIEpTT04gd2l0aCB0aGUgYXBwcm9wcmlhdGUgbG9nc3Rhc2hcbiAqIG9wdGlvbnMuIFRoaXMgd2FzIHByZXZpb3VzbHkgZXhwb3NlZCBhcyB7IGxvZ3N0YXNoOiB0cnVlIH1cbiAqIHRvIHRyYW5zcG9ydHMgaW4gYHdpbnN0b24gPCAzLjAuMGAuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZm9ybWF0KGluZm8gPT4ge1xuICBjb25zdCBsb2dzdGFzaCA9IHt9O1xuICBpZiAoaW5mby5tZXNzYWdlKSB7XG4gICAgbG9nc3Rhc2hbJ0BtZXNzYWdlJ10gPSBpbmZvLm1lc3NhZ2U7XG4gICAgZGVsZXRlIGluZm8ubWVzc2FnZTtcbiAgfVxuXG4gIGlmIChpbmZvLnRpbWVzdGFtcCkge1xuICAgIGxvZ3N0YXNoWydAdGltZXN0YW1wJ10gPSBpbmZvLnRpbWVzdGFtcDtcbiAgICBkZWxldGUgaW5mby50aW1lc3RhbXA7XG4gIH1cblxuICBsb2dzdGFzaFsnQGZpZWxkcyddID0gaW5mbztcbiAgaW5mb1tNRVNTQUdFXSA9IGpzb25TdHJpbmdpZnkobG9nc3Rhc2gpO1xuICByZXR1cm4gaW5mbztcbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZm9ybWF0ID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcblxuZnVuY3Rpb24gZmlsbEV4Y2VwdChpbmZvLCBmaWxsRXhjZXB0S2V5cywgbWV0YWRhdGFLZXkpIHtcbiAgY29uc3Qgc2F2ZWRLZXlzID0gZmlsbEV4Y2VwdEtleXMucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGFjY1trZXldID0gaW5mb1trZXldO1xuICAgIGRlbGV0ZSBpbmZvW2tleV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICBjb25zdCBtZXRhZGF0YSA9IE9iamVjdC5rZXlzKGluZm8pLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBhY2Nba2V5XSA9IGluZm9ba2V5XTtcbiAgICBkZWxldGUgaW5mb1trZXldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICBPYmplY3QuYXNzaWduKGluZm8sIHNhdmVkS2V5cywge1xuICAgIFttZXRhZGF0YUtleV06IG1ldGFkYXRhXG4gIH0pO1xuICByZXR1cm4gaW5mbztcbn1cblxuZnVuY3Rpb24gZmlsbFdpdGgoaW5mbywgZmlsbFdpdGhLZXlzLCBtZXRhZGF0YUtleSkge1xuICBpbmZvW21ldGFkYXRhS2V5XSA9IGZpbGxXaXRoS2V5cy5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgYWNjW2tleV0gPSBpbmZvW2tleV07XG4gICAgZGVsZXRlIGluZm9ba2V5XTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIEFkZHMgaW4gYSBcIm1ldGFkYXRhXCIgb2JqZWN0IHRvIGNvbGxlY3QgZXh0cmFuZW91cyBkYXRhLCBzaW1pbGFyIHRvIHRoZSBtZXRhZGF0YVxuICogb2JqZWN0IGluIHdpbnN0b24gMi54LlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcm1hdCgoaW5mbywgb3B0cyA9IHt9KSA9PiB7XG4gIGxldCBtZXRhZGF0YUtleSA9ICdtZXRhZGF0YSc7XG4gIGlmIChvcHRzLmtleSkge1xuICAgIG1ldGFkYXRhS2V5ID0gb3B0cy5rZXk7XG4gIH1cblxuICBsZXQgZmlsbEV4Y2VwdEtleXMgPSBbXTtcbiAgaWYgKCFvcHRzLmZpbGxFeGNlcHQgJiYgIW9wdHMuZmlsbFdpdGgpIHtcbiAgICBmaWxsRXhjZXB0S2V5cy5wdXNoKCdsZXZlbCcpO1xuICAgIGZpbGxFeGNlcHRLZXlzLnB1c2goJ21lc3NhZ2UnKTtcbiAgfVxuXG4gIGlmIChvcHRzLmZpbGxFeGNlcHQpIHtcbiAgICBmaWxsRXhjZXB0S2V5cyA9IG9wdHMuZmlsbEV4Y2VwdDtcbiAgfVxuXG4gIGlmIChmaWxsRXhjZXB0S2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGZpbGxFeGNlcHQoaW5mbywgZmlsbEV4Y2VwdEtleXMsIG1ldGFkYXRhS2V5KTtcbiAgfVxuXG4gIGlmIChvcHRzLmZpbGxXaXRoKSB7XG4gICAgcmV0dXJuIGZpbGxXaXRoKGluZm8sIG9wdHMuZmlsbFdpdGgsIG1ldGFkYXRhS2V5KTtcbiAgfVxuXG4gIHJldHVybiBpbmZvO1xufSk7XG4iLCAiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBmb3JtYXQgPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xuY29uc3QgbXMgPSByZXF1aXJlKCdtcycpO1xuXG4vKlxuICogZnVuY3Rpb24gbXMgKGluZm8pXG4gKiBSZXR1cm5zIGFuIGBpbmZvYCB3aXRoIGEgYG1zYCBwcm9wZXJ0eS4gVGhlIGBtc2AgcHJvcGVydHkgaG9sZHMgdGhlIFZhbHVlXG4gKiBvZiB0aGUgdGltZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIGNhbGxzIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JtYXQoaW5mbyA9PiB7XG4gIGNvbnN0IGN1cnIgPSArbmV3IERhdGUoKTtcbiAgdGhpcy5kaWZmID0gY3VyciAtICh0aGlzLnByZXZUaW1lIHx8IGN1cnIpO1xuICB0aGlzLnByZXZUaW1lID0gY3VycjtcbiAgaW5mby5tcyA9IGArJHttcyh0aGlzLmRpZmYpfWA7XG5cbiAgcmV0dXJuIGluZm87XG59KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGluc3BlY3QgPSByZXF1aXJlKCd1dGlsJykuaW5zcGVjdDtcbmNvbnN0IGZvcm1hdCA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG5jb25zdCB7IExFVkVMLCBNRVNTQUdFLCBTUExBVCB9ID0gcmVxdWlyZSgndHJpcGxlLWJlYW0nKTtcblxuLypcbiAqIGZ1bmN0aW9uIHByZXR0eVByaW50IChpbmZvKVxuICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgcHJldHR5UHJpbnQgRm9ybWF0IHRoYXQgXCJwcmV0dHlQcmludFwiXG4gKiBzZXJpYWxpemVzIGBpbmZvYCBvYmplY3RzLiBUaGlzIHdhcyBwcmV2aW91c2x5IGV4cG9zZWQgYXNcbiAqIHsgcHJldHR5UHJpbnQ6IHRydWUgfSB0byB0cmFuc3BvcnRzIGluIGB3aW5zdG9uIDwgMy4wLjBgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcm1hdCgoaW5mbywgb3B0cyA9IHt9KSA9PiB7XG4gIC8vXG4gIC8vIGluZm9be0xFVkVMLCBNRVNTQUdFLCBTUExBVH1dIGFyZSBlbnVtZXJhYmxlIGhlcmUuIFNpbmNlIHRoZXlcbiAgLy8gYXJlIGludGVybmFsLCB3ZSByZW1vdmUgdGhlbSBiZWZvcmUgdXRpbC5pbnNwZWN0IHNvIHRoZXlcbiAgLy8gYXJlIG5vdCBwcmludGVkLlxuICAvL1xuICBjb25zdCBzdHJpcHBlZCA9IE9iamVjdC5hc3NpZ24oe30sIGluZm8pO1xuXG4gIC8vIFJlbWFyayAoaW5kZXh6ZXJvKTogdXBkYXRlIHRoaXMgdGVjaG5pcXVlIGluIEFwcmlsIDIwMTlcbiAgLy8gd2hlbiBub2RlQDYgaXMgRU9MXG4gIGRlbGV0ZSBzdHJpcHBlZFtMRVZFTF07XG4gIGRlbGV0ZSBzdHJpcHBlZFtNRVNTQUdFXTtcbiAgZGVsZXRlIHN0cmlwcGVkW1NQTEFUXTtcblxuICBpbmZvW01FU1NBR0VdID0gaW5zcGVjdChzdHJpcHBlZCwgZmFsc2UsIG9wdHMuZGVwdGggfHwgbnVsbCwgb3B0cy5jb2xvcml6ZSk7XG4gIHJldHVybiBpbmZvO1xufSk7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IE1FU1NBR0UgfSA9IHJlcXVpcmUoJ3RyaXBsZS1iZWFtJyk7XG5cbmNsYXNzIFByaW50ZiB7XG4gIGNvbnN0cnVjdG9yKHRlbXBsYXRlRm4pIHtcbiAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGVGbjtcbiAgfVxuXG4gIHRyYW5zZm9ybShpbmZvKSB7XG4gICAgaW5mb1tNRVNTQUdFXSA9IHRoaXMudGVtcGxhdGUoaW5mbyk7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cblxuLypcbiAqIGZ1bmN0aW9uIHByaW50ZiAodGVtcGxhdGVGbilcbiAqIFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHByaW50ZiBGb3JtYXQgdGhhdCBjcmVhdGVzIGFuXG4gKiBpbnRlcm1lZGlhdGUgcHJvdG90eXBlIHRvIHN0b3JlIHRoZSB0ZW1wbGF0ZSBzdHJpbmctYmFzZWQgZm9ybWF0dGVyXG4gKiBmdW5jdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBvcHRzID0+IG5ldyBQcmludGYob3B0cyk7XG5cbm1vZHVsZS5leHBvcnRzLlByaW50ZlxuICA9IG1vZHVsZS5leHBvcnRzLkZvcm1hdFxuICA9IFByaW50ZjtcbiIsICIvKiBlc2xpbnQgbm8tdW5kZWZpbmVkOiAwICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGZvcm1hdCA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG5jb25zdCB7IE1FU1NBR0UgfSA9IHJlcXVpcmUoJ3RyaXBsZS1iZWFtJyk7XG5jb25zdCBqc29uU3RyaW5naWZ5ID0gcmVxdWlyZSgnc2FmZS1zdGFibGUtc3RyaW5naWZ5Jyk7XG5cbi8qXG4gKiBmdW5jdGlvbiBzaW1wbGUgKGluZm8pXG4gKiBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBzaW1wbGUgZm9ybWF0IFRyYW5zZm9ybVN0cmVhbVxuICogd2hpY2ggd3JpdGVzIGEgc2ltcGxlIHJlcHJlc2VudGF0aW9uIG9mIGxvZ3MuXG4gKlxuICogICAgY29uc3QgeyBsZXZlbCwgbWVzc2FnZSwgc3BsYXQsIC4uLnJlc3QgfSA9IGluZm87XG4gKlxuICogICAgJHtsZXZlbH06ICR7bWVzc2FnZX0gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgcmVzdCBpcyBlbXB0eVxuICogICAgJHtsZXZlbH06ICR7bWVzc2FnZX0gJHtKU09OLnN0cmluZ2lmeShyZXN0KX0gICAgb3RoZXJ3aXNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZm9ybWF0KGluZm8gPT4ge1xuICBjb25zdCBzdHJpbmdpZmllZFJlc3QgPSBqc29uU3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oe30sIGluZm8sIHtcbiAgICBsZXZlbDogdW5kZWZpbmVkLFxuICAgIG1lc3NhZ2U6IHVuZGVmaW5lZCxcbiAgICBzcGxhdDogdW5kZWZpbmVkXG4gIH0pKTtcblxuICBjb25zdCBwYWRkaW5nID0gaW5mby5wYWRkaW5nICYmIGluZm8ucGFkZGluZ1tpbmZvLmxldmVsXSB8fCAnJztcbiAgaWYgKHN0cmluZ2lmaWVkUmVzdCAhPT0gJ3t9Jykge1xuICAgIGluZm9bTUVTU0FHRV0gPSBgJHtpbmZvLmxldmVsfToke3BhZGRpbmd9ICR7aW5mby5tZXNzYWdlfSAke3N0cmluZ2lmaWVkUmVzdH1gO1xuICB9IGVsc2Uge1xuICAgIGluZm9bTUVTU0FHRV0gPSBgJHtpbmZvLmxldmVsfToke3BhZGRpbmd9ICR7aW5mby5tZXNzYWdlfWA7XG4gIH1cblxuICByZXR1cm4gaW5mbztcbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHsgU1BMQVQgfSA9IHJlcXVpcmUoJ3RyaXBsZS1iZWFtJyk7XG5cbi8qKlxuICogQ2FwdHVyZXMgdGhlIG51bWJlciBvZiBmb3JtYXQgKGkuZS4gJXMgc3RyaW5ncykgaW4gYSBnaXZlbiBzdHJpbmcuXG4gKiBCYXNlZCBvbiBgdXRpbC5mb3JtYXRgLCBzZWUgTm9kZS5qcyBzb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9iMWM4ZjE1YzVmMTY5ZTAyMWY3YzQ2ZWI3YjIxOWRlOTVmZTk3NjAzL2xpYi91dGlsLmpzI0wyMDEtTDIzMFxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuY29uc3QgZm9ybWF0UmVnRXhwID0gLyVbc2Nkamlmb08lXS9nO1xuXG4vKipcbiAqIENhcHR1cmVzIHRoZSBudW1iZXIgb2YgZXNjYXBlZCAlIHNpZ25zIGluIGEgZm9ybWF0IHN0cmluZyAoaS5lLiAlcyBzdHJpbmdzKS5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmNvbnN0IGVzY2FwZWRQZXJjZW50ID0gLyUlL2c7XG5cbmNsYXNzIFNwbGF0dGVyIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdHM7XG4gIH1cblxuICAvKipcbiAgICAgKiBDaGVjayB0byBzZWUgaWYgdG9rZW5zIDw9IHNwbGF0Lmxlbmd0aCwgYXNzaWduIHsgc3BsYXQsIG1ldGEgfSBpbnRvIHRoZVxuICAgICAqIGBpbmZvYCBhY2NvcmRpbmdseSwgYW5kIHdyaXRlIHRvIHRoaXMgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtJbmZvfSBpbmZvIExvZ2Zvcm0gaW5mbyBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ1tdfSB0b2tlbnMgU2V0IG9mIHN0cmluZyBpbnRlcnBvbGF0aW9uIHRva2Vucy5cbiAgICAgKiBAcmV0dXJucyB7SW5mb30gTW9kaWZpZWQgaW5mbyBtZXNzYWdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgX3NwbGF0KGluZm8sIHRva2Vucykge1xuICAgIGNvbnN0IG1zZyA9IGluZm8ubWVzc2FnZTtcbiAgICBjb25zdCBzcGxhdCA9IGluZm9bU1BMQVRdIHx8IGluZm8uc3BsYXQgfHwgW107XG4gICAgY29uc3QgcGVyY2VudHMgPSBtc2cubWF0Y2goZXNjYXBlZFBlcmNlbnQpO1xuICAgIGNvbnN0IGVzY2FwZXMgPSBwZXJjZW50cyAmJiBwZXJjZW50cy5sZW5ndGggfHwgMDtcblxuICAgIC8vIFRoZSBleHBlY3RlZCBzcGxhdCBpcyB0aGUgbnVtYmVyIG9mIHRva2VucyBtaW51cyB0aGUgbnVtYmVyIG9mIGVzY2FwZXNcbiAgICAvLyBlLmcuXG4gICAgLy8gLSB7IGV4cGVjdGVkU3BsYXQ6IDMgfSAnJWQgJXMgJWonXG4gICAgLy8gLSB7IGV4cGVjdGVkU3BsYXQ6IDUgfSAnWyVzXSAlZCUlICVkJSUgJXMgJWonXG4gICAgLy9cbiAgICAvLyBBbnkgXCJtZXRhXCIgd2lsbCBiZSBhcnVnbWVudHMgaW4gYWRkaXRpb24gdG8gdGhlIGV4cGVjdGVkIHNwbGF0IHNpemVcbiAgICAvLyByZWdhcmRsZXNzIG9mIHR5cGUuIGUuZy5cbiAgICAvL1xuICAgIC8vIGxvZ2dlci5sb2coJ2luZm8nLCAnJWQlJSAlcyAlaicsIDEwMCwgJ3dvdycsIHsgc3VjaDogJ2pzJyB9LCB7IHRoaXNJc01ldGE6IHRydWUgfSk7XG4gICAgLy8gd291bGQgcmVzdWx0IGluIHNwbGF0IG9mIGZvdXIgKDQpLCBidXQgb25seSB0aHJlZSAoMykgYXJlIGV4cGVjdGVkLiBUaGVyZWZvcmU6XG4gICAgLy9cbiAgICAvLyBleHRyYVNwbGF0ID0gMyAtIDQgPSAtMVxuICAgIC8vIG1ldGFzID0gWzEwMCwgJ3dvdycsIHsgc3VjaDogJ2pzJyB9LCB7IHRoaXNJc01ldGE6IHRydWUgfV0uc3BsaWNlKC0xLCAtMSAqIC0xKTtcbiAgICAvLyBzcGxhdCA9IFsxMDAsICd3b3cnLCB7IHN1Y2g6ICdqcycgfV1cbiAgICBjb25zdCBleHBlY3RlZFNwbGF0ID0gdG9rZW5zLmxlbmd0aCAtIGVzY2FwZXM7XG4gICAgY29uc3QgZXh0cmFTcGxhdCA9IGV4cGVjdGVkU3BsYXQgLSBzcGxhdC5sZW5ndGg7XG4gICAgY29uc3QgbWV0YXMgPSBleHRyYVNwbGF0IDwgMFxuICAgICAgPyBzcGxhdC5zcGxpY2UoZXh0cmFTcGxhdCwgLTEgKiBleHRyYVNwbGF0KVxuICAgICAgOiBbXTtcblxuICAgIC8vIE5vdyB0aGF0IHsgc3BsYXQgfSBoYXMgYmVlbiBzZXBhcmF0ZWQgZnJvbSBhbnkgcG90ZW50aWFsIHsgbWV0YSB9LiB3ZVxuICAgIC8vIGNhbiBhc3NpZ24gdGhpcyB0byB0aGUgYGluZm9gIG9iamVjdCBhbmQgd3JpdGUgaXQgdG8gb3VyIGZvcm1hdCBzdHJlYW0uXG4gICAgLy8gSWYgdGhlIGFkZGl0aW9uYWwgbWV0YXMgYXJlICoqTk9UKiogb2JqZWN0cyBvciAqKkxBQ0sqKiBlbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgICAvLyB5b3UgYXJlIGdvaW5nIHRvIGhhdmUgYSBiYWQgdGltZS5cbiAgICBjb25zdCBtZXRhbGVuID0gbWV0YXMubGVuZ3RoO1xuICAgIGlmIChtZXRhbGVuKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGFsZW47IGkrKykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGluZm8sIG1ldGFzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmZvLm1lc3NhZ2UgPSB1dGlsLmZvcm1hdChtc2csIC4uLnNwbGF0KTtcbiAgICByZXR1cm4gaW5mbztcbiAgfVxuXG4gIC8qKlxuICAgICogVHJhbnNmb3JtcyB0aGUgYGluZm9gIG1lc3NhZ2UgYnkgdXNpbmcgYHV0aWwuZm9ybWF0YCB0byBjb21wbGV0ZVxuICAgICogYW55IGBpbmZvLm1lc3NhZ2VgIHByb3ZpZGVkIGl0IGhhcyBzdHJpbmcgaW50ZXJwb2xhdGlvbiB0b2tlbnMuXG4gICAgKiBJZiBubyB0b2tlbnMgZXhpc3QgdGhlbiBgaW5mb2AgaXMgaW1tdXRhYmxlLlxuICAgICpcbiAgICAqIEBwYXJhbSAge0luZm99IGluZm8gTG9nZm9ybSBpbmZvIG1lc3NhZ2UuXG4gICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3B0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICAqIEByZXR1cm5zIHtJbmZvfSBNb2RpZmllZCBpbmZvIG1lc3NhZ2VcbiAgICAqL1xuICB0cmFuc2Zvcm0oaW5mbykge1xuICAgIGNvbnN0IG1zZyA9IGluZm8ubWVzc2FnZTtcbiAgICBjb25zdCBzcGxhdCA9IGluZm9bU1BMQVRdIHx8IGluZm8uc3BsYXQ7XG5cbiAgICAvLyBObyBuZWVkIHRvIHByb2Nlc3MgYW55dGhpbmcgaWYgc3BsYXQgaXMgdW5kZWZpbmVkXG4gICAgaWYgKCFzcGxhdCB8fCAhc3BsYXQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IHRva2VucywgaWYgbm9uZSBhdmFpbGFibGUgZGVmYXVsdCB0byBlbXB0eSBhcnJheSB0b1xuICAgIC8vIGVuc3VyZSBjb25zaXN0YW5jeSBpbiBleHBlY3RlZCByZXN1bHRzXG4gICAgY29uc3QgdG9rZW5zID0gbXNnICYmIG1zZy5tYXRjaCAmJiBtc2cubWF0Y2goZm9ybWF0UmVnRXhwKTtcblxuICAgIC8vIFRoaXMgY29uZGl0aW9uIHdpbGwgdGFrZSBjYXJlIG9mIGlucHV0cyB3aXRoIGluZm9bU1BMQVRdXG4gICAgLy8gYnV0IG5vIHRva2VucyBwcmVzZW50XG4gICAgaWYgKCF0b2tlbnMgJiYgKHNwbGF0IHx8IHNwbGF0Lmxlbmd0aCkpIHtcbiAgICAgIGNvbnN0IG1ldGFzID0gc3BsYXQubGVuZ3RoID4gMVxuICAgICAgICA/IHNwbGF0LnNwbGljZSgwKVxuICAgICAgICA6IHNwbGF0O1xuXG4gICAgICAvLyBOb3cgdGhhdCB7IHNwbGF0IH0gaGFzIGJlZW4gc2VwYXJhdGVkIGZyb20gYW55IHBvdGVudGlhbCB7IG1ldGEgfS4gd2VcbiAgICAgIC8vIGNhbiBhc3NpZ24gdGhpcyB0byB0aGUgYGluZm9gIG9iamVjdCBhbmQgd3JpdGUgaXQgdG8gb3VyIGZvcm1hdCBzdHJlYW0uXG4gICAgICAvLyBJZiB0aGUgYWRkaXRpb25hbCBtZXRhcyBhcmUgKipOT1QqKiBvYmplY3RzIG9yICoqTEFDSyoqIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAgICAgLy8geW91IGFyZSBnb2luZyB0byBoYXZlIGEgYmFkIHRpbWUuXG4gICAgICBjb25zdCBtZXRhbGVuID0gbWV0YXMubGVuZ3RoO1xuICAgICAgaWYgKG1ldGFsZW4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRhbGVuOyBpKyspIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGluZm8sIG1ldGFzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICBpZiAodG9rZW5zKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3BsYXQoaW5mbywgdG9rZW5zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuXG4vKlxuICogZnVuY3Rpb24gc3BsYXQgKGluZm8pXG4gKiBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBzcGxhdCBmb3JtYXQgVHJhbnNmb3JtU3RyZWFtXG4gKiB3aGljaCBwZXJmb3JtcyBzdHJpbmcgaW50ZXJwb2xhdGlvbiBmcm9tIGBpbmZvYCBvYmplY3RzLiBUaGlzIHdhc1xuICogcHJldmlvdXNseSBleHBvc2VkIGltcGxpY2l0bHkgaW4gYHdpbnN0b24gPCAzLjAuMGAuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gb3B0cyA9PiBuZXcgU3BsYXR0ZXIob3B0cyk7XG4iLCAiY29uc3QgdG9rZW4gPSAvZHsxLDR9fE17MSw0fXxZWSg/OllZKT98U3sxLDN9fERvfFpafFp8KFtIaE1zRG1dKVxcMT98W2FBXXxcIlteXCJdKlwifCdbXiddKicvZztcbmNvbnN0IHR3b0RpZ2l0c09wdGlvbmFsID0gXCJcXFxcZFxcXFxkP1wiO1xuY29uc3QgdHdvRGlnaXRzID0gXCJcXFxcZFxcXFxkXCI7XG5jb25zdCB0aHJlZURpZ2l0cyA9IFwiXFxcXGR7M31cIjtcbmNvbnN0IGZvdXJEaWdpdHMgPSBcIlxcXFxkezR9XCI7XG5jb25zdCB3b3JkID0gXCJbXlxcXFxzXStcIjtcbmNvbnN0IGxpdGVyYWwgPSAvXFxbKFteXSo/KVxcXS9nbTtcblxudHlwZSBEYXRlSW5mbyA9IHtcbiAgeWVhcjogbnVtYmVyO1xuICBtb250aDogbnVtYmVyO1xuICBkYXk6IG51bWJlcjtcbiAgaG91cjogbnVtYmVyO1xuICBtaW51dGU6IG51bWJlcjtcbiAgc2Vjb25kOiBudW1iZXI7XG4gIG1pbGxpc2Vjb25kOiBudW1iZXI7XG4gIGlzUG06IG51bWJlciB8IG51bGw7XG4gIHRpbWV6b25lT2Zmc2V0OiBudW1iZXIgfCBudWxsO1xufTtcblxuZXhwb3J0IHR5cGUgSTE4blNldHRpbmdzID0ge1xuICBhbVBtOiBbc3RyaW5nLCBzdHJpbmddO1xuICBkYXlOYW1lczogRGF5cztcbiAgZGF5TmFtZXNTaG9ydDogRGF5cztcbiAgbW9udGhOYW1lczogTW9udGhzO1xuICBtb250aE5hbWVzU2hvcnQ6IE1vbnRocztcbiAgRG9GbihkYXlPZk1vbnRoOiBudW1iZXIpOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgdHlwZSBJMThuU2V0dGluZ3NPcHRpb25hbCA9IFBhcnRpYWw8STE4blNldHRpbmdzPjtcblxuZXhwb3J0IHR5cGUgRGF5cyA9IFtzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmddO1xuZXhwb3J0IHR5cGUgTW9udGhzID0gW1xuICBzdHJpbmcsXG4gIHN0cmluZyxcbiAgc3RyaW5nLFxuICBzdHJpbmcsXG4gIHN0cmluZyxcbiAgc3RyaW5nLFxuICBzdHJpbmcsXG4gIHN0cmluZyxcbiAgc3RyaW5nLFxuICBzdHJpbmcsXG4gIHN0cmluZyxcbiAgc3RyaW5nXG5dO1xuXG5mdW5jdGlvbiBzaG9ydGVuPFQgZXh0ZW5kcyBzdHJpbmdbXT4oYXJyOiBULCBzTGVuOiBudW1iZXIpOiBzdHJpbmdbXSB7XG4gIGNvbnN0IG5ld0Fycjogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIG5ld0Fyci5wdXNoKGFycltpXS5zdWJzdHIoMCwgc0xlbikpO1xuICB9XG4gIHJldHVybiBuZXdBcnI7XG59XG5cbmNvbnN0IG1vbnRoVXBkYXRlID0gKFxuICBhcnJOYW1lOiBcIm1vbnRoTmFtZXNcIiB8IFwibW9udGhOYW1lc1Nob3J0XCIgfCBcImRheU5hbWVzXCIgfCBcImRheU5hbWVzU2hvcnRcIlxuKSA9PiAodjogc3RyaW5nLCBpMThuOiBJMThuU2V0dGluZ3MpOiBudW1iZXIgfCBudWxsID0+IHtcbiAgY29uc3QgbG93ZXJDYXNlQXJyID0gaTE4blthcnJOYW1lXS5tYXAodiA9PiB2LnRvTG93ZXJDYXNlKCkpO1xuICBjb25zdCBpbmRleCA9IGxvd2VyQ2FzZUFyci5pbmRleE9mKHYudG9Mb3dlckNhc2UoKSk7XG4gIGlmIChpbmRleCA+IC0xKSB7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxBPihhOiBBKTogQTtcbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ248QSwgQj4oYTogQSwgYjogQik6IEEgJiBCO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxBLCBCLCBDPihhOiBBLCBiOiBCLCBjOiBDKTogQSAmIEIgJiBDO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxBLCBCLCBDLCBEPihhOiBBLCBiOiBCLCBjOiBDLCBkOiBEKTogQSAmIEIgJiBDICYgRDtcbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob3JpZ09iajogYW55LCAuLi5hcmdzOiBhbnlbXSk6IGFueSB7XG4gIGZvciAoY29uc3Qgb2JqIG9mIGFyZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgZXhcbiAgICAgIG9yaWdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3JpZ09iajtcbn1cblxuY29uc3QgZGF5TmFtZXM6IERheXMgPSBbXG4gIFwiU3VuZGF5XCIsXG4gIFwiTW9uZGF5XCIsXG4gIFwiVHVlc2RheVwiLFxuICBcIldlZG5lc2RheVwiLFxuICBcIlRodXJzZGF5XCIsXG4gIFwiRnJpZGF5XCIsXG4gIFwiU2F0dXJkYXlcIlxuXTtcbmNvbnN0IG1vbnRoTmFtZXM6IE1vbnRocyA9IFtcbiAgXCJKYW51YXJ5XCIsXG4gIFwiRmVicnVhcnlcIixcbiAgXCJNYXJjaFwiLFxuICBcIkFwcmlsXCIsXG4gIFwiTWF5XCIsXG4gIFwiSnVuZVwiLFxuICBcIkp1bHlcIixcbiAgXCJBdWd1c3RcIixcbiAgXCJTZXB0ZW1iZXJcIixcbiAgXCJPY3RvYmVyXCIsXG4gIFwiTm92ZW1iZXJcIixcbiAgXCJEZWNlbWJlclwiXG5dO1xuXG5jb25zdCBtb250aE5hbWVzU2hvcnQ6IE1vbnRocyA9IHNob3J0ZW4obW9udGhOYW1lcywgMykgYXMgTW9udGhzO1xuY29uc3QgZGF5TmFtZXNTaG9ydDogRGF5cyA9IHNob3J0ZW4oZGF5TmFtZXMsIDMpIGFzIERheXM7XG5cbmNvbnN0IGRlZmF1bHRJMThuOiBJMThuU2V0dGluZ3MgPSB7XG4gIGRheU5hbWVzU2hvcnQsXG4gIGRheU5hbWVzLFxuICBtb250aE5hbWVzU2hvcnQsXG4gIG1vbnRoTmFtZXMsXG4gIGFtUG06IFtcImFtXCIsIFwicG1cIl0sXG4gIERvRm4oZGF5T2ZNb250aDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGRheU9mTW9udGggK1xuICAgICAgW1widGhcIiwgXCJzdFwiLCBcIm5kXCIsIFwicmRcIl1bXG4gICAgICAgIGRheU9mTW9udGggJSAxMCA+IDNcbiAgICAgICAgICA/IDBcbiAgICAgICAgICA6ICgoZGF5T2ZNb250aCAtIChkYXlPZk1vbnRoICUgMTApICE9PSAxMCA/IDEgOiAwKSAqIGRheU9mTW9udGgpICUgMTBcbiAgICAgIF1cbiAgICApO1xuICB9XG59O1xubGV0IGdsb2JhbEkxOG4gPSBhc3NpZ24oe30sIGRlZmF1bHRJMThuKTtcbmNvbnN0IHNldEdsb2JhbERhdGVJMThuID0gKGkxOG46IEkxOG5TZXR0aW5nc09wdGlvbmFsKTogSTE4blNldHRpbmdzID0+XG4gIChnbG9iYWxJMThuID0gYXNzaWduKGdsb2JhbEkxOG4sIGkxOG4pKTtcblxuY29uc3QgcmVnZXhFc2NhcGUgPSAoc3RyOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgc3RyLnJlcGxhY2UoL1t8XFxcXHsoKVteJCsqPy4tXS9nLCBcIlxcXFwkJlwiKTtcblxuY29uc3QgcGFkID0gKHZhbDogc3RyaW5nIHwgbnVtYmVyLCBsZW4gPSAyKTogc3RyaW5nID0+IHtcbiAgdmFsID0gU3RyaW5nKHZhbCk7XG4gIHdoaWxlICh2YWwubGVuZ3RoIDwgbGVuKSB7XG4gICAgdmFsID0gXCIwXCIgKyB2YWw7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbmNvbnN0IGZvcm1hdEZsYWdzOiBSZWNvcmQ8XG4gIHN0cmluZyxcbiAgKGRhdGVPYmo6IERhdGUsIGkxOG46IEkxOG5TZXR0aW5ncykgPT4gc3RyaW5nXG4+ID0ge1xuICBEOiAoZGF0ZU9iajogRGF0ZSk6IHN0cmluZyA9PiBTdHJpbmcoZGF0ZU9iai5nZXREYXRlKCkpLFxuICBERDogKGRhdGVPYmo6IERhdGUpOiBzdHJpbmcgPT4gcGFkKGRhdGVPYmouZ2V0RGF0ZSgpKSxcbiAgRG86IChkYXRlT2JqOiBEYXRlLCBpMThuOiBJMThuU2V0dGluZ3MpOiBzdHJpbmcgPT5cbiAgICBpMThuLkRvRm4oZGF0ZU9iai5nZXREYXRlKCkpLFxuICBkOiAoZGF0ZU9iajogRGF0ZSk6IHN0cmluZyA9PiBTdHJpbmcoZGF0ZU9iai5nZXREYXkoKSksXG4gIGRkOiAoZGF0ZU9iajogRGF0ZSk6IHN0cmluZyA9PiBwYWQoZGF0ZU9iai5nZXREYXkoKSksXG4gIGRkZDogKGRhdGVPYmo6IERhdGUsIGkxOG46IEkxOG5TZXR0aW5ncyk6IHN0cmluZyA9PlxuICAgIGkxOG4uZGF5TmFtZXNTaG9ydFtkYXRlT2JqLmdldERheSgpXSxcbiAgZGRkZDogKGRhdGVPYmo6IERhdGUsIGkxOG46IEkxOG5TZXR0aW5ncyk6IHN0cmluZyA9PlxuICAgIGkxOG4uZGF5TmFtZXNbZGF0ZU9iai5nZXREYXkoKV0sXG4gIE06IChkYXRlT2JqOiBEYXRlKTogc3RyaW5nID0+IFN0cmluZyhkYXRlT2JqLmdldE1vbnRoKCkgKyAxKSxcbiAgTU06IChkYXRlT2JqOiBEYXRlKTogc3RyaW5nID0+IHBhZChkYXRlT2JqLmdldE1vbnRoKCkgKyAxKSxcbiAgTU1NOiAoZGF0ZU9iajogRGF0ZSwgaTE4bjogSTE4blNldHRpbmdzKTogc3RyaW5nID0+XG4gICAgaTE4bi5tb250aE5hbWVzU2hvcnRbZGF0ZU9iai5nZXRNb250aCgpXSxcbiAgTU1NTTogKGRhdGVPYmo6IERhdGUsIGkxOG46IEkxOG5TZXR0aW5ncyk6IHN0cmluZyA9PlxuICAgIGkxOG4ubW9udGhOYW1lc1tkYXRlT2JqLmdldE1vbnRoKCldLFxuICBZWTogKGRhdGVPYmo6IERhdGUpOiBzdHJpbmcgPT5cbiAgICBwYWQoU3RyaW5nKGRhdGVPYmouZ2V0RnVsbFllYXIoKSksIDQpLnN1YnN0cigyKSxcbiAgWVlZWTogKGRhdGVPYmo6IERhdGUpOiBzdHJpbmcgPT4gcGFkKGRhdGVPYmouZ2V0RnVsbFllYXIoKSwgNCksXG4gIGg6IChkYXRlT2JqOiBEYXRlKTogc3RyaW5nID0+IFN0cmluZyhkYXRlT2JqLmdldEhvdXJzKCkgJSAxMiB8fCAxMiksXG4gIGhoOiAoZGF0ZU9iajogRGF0ZSk6IHN0cmluZyA9PiBwYWQoZGF0ZU9iai5nZXRIb3VycygpICUgMTIgfHwgMTIpLFxuICBIOiAoZGF0ZU9iajogRGF0ZSk6IHN0cmluZyA9PiBTdHJpbmcoZGF0ZU9iai5nZXRIb3VycygpKSxcbiAgSEg6IChkYXRlT2JqOiBEYXRlKTogc3RyaW5nID0+IHBhZChkYXRlT2JqLmdldEhvdXJzKCkpLFxuICBtOiAoZGF0ZU9iajogRGF0ZSk6IHN0cmluZyA9PiBTdHJpbmcoZGF0ZU9iai5nZXRNaW51dGVzKCkpLFxuICBtbTogKGRhdGVPYmo6IERhdGUpOiBzdHJpbmcgPT4gcGFkKGRhdGVPYmouZ2V0TWludXRlcygpKSxcbiAgczogKGRhdGVPYmo6IERhdGUpOiBzdHJpbmcgPT4gU3RyaW5nKGRhdGVPYmouZ2V0U2Vjb25kcygpKSxcbiAgc3M6IChkYXRlT2JqOiBEYXRlKTogc3RyaW5nID0+IHBhZChkYXRlT2JqLmdldFNlY29uZHMoKSksXG4gIFM6IChkYXRlT2JqOiBEYXRlKTogc3RyaW5nID0+XG4gICAgU3RyaW5nKE1hdGgucm91bmQoZGF0ZU9iai5nZXRNaWxsaXNlY29uZHMoKSAvIDEwMCkpLFxuICBTUzogKGRhdGVPYmo6IERhdGUpOiBzdHJpbmcgPT5cbiAgICBwYWQoTWF0aC5yb3VuZChkYXRlT2JqLmdldE1pbGxpc2Vjb25kcygpIC8gMTApLCAyKSxcbiAgU1NTOiAoZGF0ZU9iajogRGF0ZSk6IHN0cmluZyA9PiBwYWQoZGF0ZU9iai5nZXRNaWxsaXNlY29uZHMoKSwgMyksXG4gIGE6IChkYXRlT2JqOiBEYXRlLCBpMThuOiBJMThuU2V0dGluZ3MpOiBzdHJpbmcgPT5cbiAgICBkYXRlT2JqLmdldEhvdXJzKCkgPCAxMiA/IGkxOG4uYW1QbVswXSA6IGkxOG4uYW1QbVsxXSxcbiAgQTogKGRhdGVPYmo6IERhdGUsIGkxOG46IEkxOG5TZXR0aW5ncyk6IHN0cmluZyA9PlxuICAgIGRhdGVPYmouZ2V0SG91cnMoKSA8IDEyXG4gICAgICA/IGkxOG4uYW1QbVswXS50b1VwcGVyQ2FzZSgpXG4gICAgICA6IGkxOG4uYW1QbVsxXS50b1VwcGVyQ2FzZSgpLFxuICBaWihkYXRlT2JqOiBEYXRlKTogc3RyaW5nIHtcbiAgICBjb25zdCBvZmZzZXQgPSBkYXRlT2JqLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgcmV0dXJuIChcbiAgICAgIChvZmZzZXQgPiAwID8gXCItXCIgOiBcIitcIikgK1xuICAgICAgcGFkKE1hdGguZmxvb3IoTWF0aC5hYnMob2Zmc2V0KSAvIDYwKSAqIDEwMCArIChNYXRoLmFicyhvZmZzZXQpICUgNjApLCA0KVxuICAgICk7XG4gIH0sXG4gIFooZGF0ZU9iajogRGF0ZSk6IHN0cmluZyB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZGF0ZU9iai5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIHJldHVybiAoXG4gICAgICAob2Zmc2V0ID4gMCA/IFwiLVwiIDogXCIrXCIpICtcbiAgICAgIHBhZChNYXRoLmZsb29yKE1hdGguYWJzKG9mZnNldCkgLyA2MCksIDIpICtcbiAgICAgIFwiOlwiICtcbiAgICAgIHBhZChNYXRoLmFicyhvZmZzZXQpICUgNjAsIDIpXG4gICAgKTtcbiAgfVxufTtcblxudHlwZSBQYXJzZUluZm8gPSBbXG4gIGtleW9mIERhdGVJbmZvLFxuICBzdHJpbmcsXG4gICgodjogc3RyaW5nLCBpMThuOiBJMThuU2V0dGluZ3MpID0+IG51bWJlciB8IG51bGwpPyxcbiAgc3RyaW5nP1xuXTtcbmNvbnN0IG1vbnRoUGFyc2UgPSAodjogc3RyaW5nKTogbnVtYmVyID0+ICt2IC0gMTtcbmNvbnN0IGVtcHR5RGlnaXRzOiBQYXJzZUluZm8gPSBbbnVsbCwgdHdvRGlnaXRzT3B0aW9uYWxdO1xuY29uc3QgZW1wdHlXb3JkOiBQYXJzZUluZm8gPSBbbnVsbCwgd29yZF07XG5jb25zdCBhbVBtOiBQYXJzZUluZm8gPSBbXG4gIFwiaXNQbVwiLFxuICB3b3JkLFxuICAodjogc3RyaW5nLCBpMThuOiBJMThuU2V0dGluZ3MpOiBudW1iZXIgfCBudWxsID0+IHtcbiAgICBjb25zdCB2YWwgPSB2LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHZhbCA9PT0gaTE4bi5hbVBtWzBdKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKHZhbCA9PT0gaTE4bi5hbVBtWzFdKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbl07XG5jb25zdCB0aW1lem9uZU9mZnNldDogUGFyc2VJbmZvID0gW1xuICBcInRpbWV6b25lT2Zmc2V0XCIsXG4gIFwiW15cXFxcc10qP1tcXFxcK1xcXFwtXVxcXFxkXFxcXGQ6P1xcXFxkXFxcXGR8W15cXFxcc10qP1o/XCIsXG4gICh2OiBzdHJpbmcpOiBudW1iZXIgfCBudWxsID0+IHtcbiAgICBjb25zdCBwYXJ0cyA9ICh2ICsgXCJcIikubWF0Y2goLyhbKy1dfFxcZFxcZCkvZ2kpO1xuXG4gICAgaWYgKHBhcnRzKSB7XG4gICAgICBjb25zdCBtaW51dGVzID0gK3BhcnRzWzFdICogNjAgKyBwYXJzZUludChwYXJ0c1syXSwgMTApO1xuICAgICAgcmV0dXJuIHBhcnRzWzBdID09PSBcIitcIiA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXTtcbmNvbnN0IHBhcnNlRmxhZ3M6IFJlY29yZDxzdHJpbmcsIFBhcnNlSW5mbz4gPSB7XG4gIEQ6IFtcImRheVwiLCB0d29EaWdpdHNPcHRpb25hbF0sXG4gIEREOiBbXCJkYXlcIiwgdHdvRGlnaXRzXSxcbiAgRG86IFtcImRheVwiLCB0d29EaWdpdHNPcHRpb25hbCArIHdvcmQsICh2OiBzdHJpbmcpOiBudW1iZXIgPT4gcGFyc2VJbnQodiwgMTApXSxcbiAgTTogW1wibW9udGhcIiwgdHdvRGlnaXRzT3B0aW9uYWwsIG1vbnRoUGFyc2VdLFxuICBNTTogW1wibW9udGhcIiwgdHdvRGlnaXRzLCBtb250aFBhcnNlXSxcbiAgWVk6IFtcbiAgICBcInllYXJcIixcbiAgICB0d29EaWdpdHMsXG4gICAgKHY6IHN0cmluZyk6IG51bWJlciA9PiB7XG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgY2VudCA9ICsoXCJcIiArIG5vdy5nZXRGdWxsWWVhcigpKS5zdWJzdHIoMCwgMik7XG4gICAgICByZXR1cm4gKyhcIlwiICsgKCt2ID4gNjggPyBjZW50IC0gMSA6IGNlbnQpICsgdik7XG4gICAgfVxuICBdLFxuICBoOiBbXCJob3VyXCIsIHR3b0RpZ2l0c09wdGlvbmFsLCB1bmRlZmluZWQsIFwiaXNQbVwiXSxcbiAgaGg6IFtcImhvdXJcIiwgdHdvRGlnaXRzLCB1bmRlZmluZWQsIFwiaXNQbVwiXSxcbiAgSDogW1wiaG91clwiLCB0d29EaWdpdHNPcHRpb25hbF0sXG4gIEhIOiBbXCJob3VyXCIsIHR3b0RpZ2l0c10sXG4gIG06IFtcIm1pbnV0ZVwiLCB0d29EaWdpdHNPcHRpb25hbF0sXG4gIG1tOiBbXCJtaW51dGVcIiwgdHdvRGlnaXRzXSxcbiAgczogW1wic2Vjb25kXCIsIHR3b0RpZ2l0c09wdGlvbmFsXSxcbiAgc3M6IFtcInNlY29uZFwiLCB0d29EaWdpdHNdLFxuICBZWVlZOiBbXCJ5ZWFyXCIsIGZvdXJEaWdpdHNdLFxuICBTOiBbXCJtaWxsaXNlY29uZFwiLCBcIlxcXFxkXCIsICh2OiBzdHJpbmcpOiBudW1iZXIgPT4gK3YgKiAxMDBdLFxuICBTUzogW1wibWlsbGlzZWNvbmRcIiwgdHdvRGlnaXRzLCAodjogc3RyaW5nKTogbnVtYmVyID0+ICt2ICogMTBdLFxuICBTU1M6IFtcIm1pbGxpc2Vjb25kXCIsIHRocmVlRGlnaXRzXSxcbiAgZDogZW1wdHlEaWdpdHMsXG4gIGRkOiBlbXB0eURpZ2l0cyxcbiAgZGRkOiBlbXB0eVdvcmQsXG4gIGRkZGQ6IGVtcHR5V29yZCxcbiAgTU1NOiBbXCJtb250aFwiLCB3b3JkLCBtb250aFVwZGF0ZShcIm1vbnRoTmFtZXNTaG9ydFwiKV0sXG4gIE1NTU06IFtcIm1vbnRoXCIsIHdvcmQsIG1vbnRoVXBkYXRlKFwibW9udGhOYW1lc1wiKV0sXG4gIGE6IGFtUG0sXG4gIEE6IGFtUG0sXG4gIFpaOiB0aW1lem9uZU9mZnNldCxcbiAgWjogdGltZXpvbmVPZmZzZXRcbn07XG5cbi8vIFNvbWUgY29tbW9uIGZvcm1hdCBzdHJpbmdzXG5jb25zdCBnbG9iYWxNYXNrczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgZGVmYXVsdDogXCJkZGQgTU1NIEREIFlZWVkgSEg6bW06c3NcIixcbiAgc2hvcnREYXRlOiBcIk0vRC9ZWVwiLFxuICBtZWRpdW1EYXRlOiBcIk1NTSBELCBZWVlZXCIsXG4gIGxvbmdEYXRlOiBcIk1NTU0gRCwgWVlZWVwiLFxuICBmdWxsRGF0ZTogXCJkZGRkLCBNTU1NIEQsIFlZWVlcIixcbiAgaXNvRGF0ZTogXCJZWVlZLU1NLUREXCIsXG4gIGlzb0RhdGVUaW1lOiBcIllZWVktTU0tRERUSEg6bW06c3NaXCIsXG4gIHNob3J0VGltZTogXCJISDptbVwiLFxuICBtZWRpdW1UaW1lOiBcIkhIOm1tOnNzXCIsXG4gIGxvbmdUaW1lOiBcIkhIOm1tOnNzLlNTU1wiXG59O1xuY29uc3Qgc2V0R2xvYmFsRGF0ZU1hc2tzID0gKG1hc2tzOiB7XG4gIFtrZXk6IHN0cmluZ106IHN0cmluZztcbn0pOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0+IGFzc2lnbihnbG9iYWxNYXNrcywgbWFza3MpO1xuXG4vKioqXG4gKiBGb3JtYXQgYSBkYXRlXG4gKiBAbWV0aG9kIGZvcm1hdFxuICogQHBhcmFtIHtEYXRlfG51bWJlcn0gZGF0ZU9ialxuICogQHBhcmFtIHtzdHJpbmd9IG1hc2sgRm9ybWF0IG9mIHRoZSBkYXRlLCBpLmUuICdtbS1kZC15eScgb3IgJ3Nob3J0RGF0ZSdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCBkYXRlIHN0cmluZ1xuICovXG5jb25zdCBmb3JtYXQgPSAoXG4gIGRhdGVPYmo6IERhdGUsXG4gIG1hc2s6IHN0cmluZyA9IGdsb2JhbE1hc2tzW1wiZGVmYXVsdFwiXSxcbiAgaTE4bjogSTE4blNldHRpbmdzT3B0aW9uYWwgPSB7fVxuKTogc3RyaW5nID0+IHtcbiAgaWYgKHR5cGVvZiBkYXRlT2JqID09PSBcIm51bWJlclwiKSB7XG4gICAgZGF0ZU9iaiA9IG5ldyBEYXRlKGRhdGVPYmopO1xuICB9XG5cbiAgaWYgKFxuICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRlT2JqKSAhPT0gXCJbb2JqZWN0IERhdGVdXCIgfHxcbiAgICBpc05hTihkYXRlT2JqLmdldFRpbWUoKSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBEYXRlIHBhc3MgdG8gZm9ybWF0XCIpO1xuICB9XG5cbiAgbWFzayA9IGdsb2JhbE1hc2tzW21hc2tdIHx8IG1hc2s7XG5cbiAgY29uc3QgbGl0ZXJhbHM6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gTWFrZSBsaXRlcmFscyBpbmFjdGl2ZSBieSByZXBsYWNpbmcgdGhlbSB3aXRoIEBAQFxuICBtYXNrID0gbWFzay5yZXBsYWNlKGxpdGVyYWwsIGZ1bmN0aW9uKCQwLCAkMSkge1xuICAgIGxpdGVyYWxzLnB1c2goJDEpO1xuICAgIHJldHVybiBcIkBAQFwiO1xuICB9KTtcblxuICBjb25zdCBjb21iaW5lZEkxOG5TZXR0aW5nczogSTE4blNldHRpbmdzID0gYXNzaWduKFxuICAgIGFzc2lnbih7fSwgZ2xvYmFsSTE4biksXG4gICAgaTE4blxuICApO1xuICAvLyBBcHBseSBmb3JtYXR0aW5nIHJ1bGVzXG4gIG1hc2sgPSBtYXNrLnJlcGxhY2UodG9rZW4sICQwID0+XG4gICAgZm9ybWF0RmxhZ3NbJDBdKGRhdGVPYmosIGNvbWJpbmVkSTE4blNldHRpbmdzKVxuICApO1xuICAvLyBJbmxpbmUgbGl0ZXJhbCB2YWx1ZXMgYmFjayBpbnRvIHRoZSBmb3JtYXR0ZWQgdmFsdWVcbiAgcmV0dXJuIG1hc2sucmVwbGFjZSgvQEBAL2csICgpID0+IGxpdGVyYWxzLnNoaWZ0KCkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIGRhdGUgc3RyaW5nIGludG8gYSBKYXZhc2NyaXB0IERhdGUgb2JqZWN0IC9cbiAqIEBtZXRob2QgcGFyc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlU3RyIERhdGUgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IERhdGUgcGFyc2UgZm9ybWF0XG4gKiBAcGFyYW0ge2kxOG59IEkxOG5TZXR0aW5nc09wdGlvbmFsIEZ1bGwgb3Igc3Vic2V0IG9mIEkxOE4gc2V0dGluZ3NcbiAqIEByZXR1cm5zIHtEYXRlfG51bGx9IFJldHVybnMgRGF0ZSBvYmplY3QuIFJldHVybnMgbnVsbCB3aGF0IGRhdGUgc3RyaW5nIGlzIGludmFsaWQgb3IgZG9lc24ndCBtYXRjaCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gcGFyc2UoXG4gIGRhdGVTdHI6IHN0cmluZyxcbiAgZm9ybWF0OiBzdHJpbmcsXG4gIGkxOG46IEkxOG5TZXR0aW5nc09wdGlvbmFsID0ge31cbik6IERhdGUgfCBudWxsIHtcbiAgaWYgKHR5cGVvZiBmb3JtYXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZvcm1hdCBpbiBmZWNoYSBwYXJzZVwiKTtcbiAgfVxuXG4gIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgZm9ybWF0IGlzIGFjdHVhbGx5IGEgbWFza1xuICBmb3JtYXQgPSBnbG9iYWxNYXNrc1tmb3JtYXRdIHx8IGZvcm1hdDtcblxuICAvLyBBdm9pZCByZWd1bGFyIGV4cHJlc3Npb24gZGVuaWFsIG9mIHNlcnZpY2UsIGZhaWwgZWFybHkgZm9yIHJlYWxseSBsb25nIHN0cmluZ3NcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9SZWd1bGFyX2V4cHJlc3Npb25fRGVuaWFsX29mX1NlcnZpY2VfLV9SZURvU1xuICBpZiAoZGF0ZVN0ci5sZW5ndGggPiAxMDAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBEZWZhdWx0IHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHllYXIuXG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgY29uc3QgZGF0ZUluZm86IERhdGVJbmZvID0ge1xuICAgIHllYXI6IHRvZGF5LmdldEZ1bGxZZWFyKCksXG4gICAgbW9udGg6IDAsXG4gICAgZGF5OiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgICBpc1BtOiBudWxsLFxuICAgIHRpbWV6b25lT2Zmc2V0OiBudWxsXG4gIH07XG4gIGNvbnN0IHBhcnNlSW5mbzogUGFyc2VJbmZvW10gPSBbXTtcbiAgY29uc3QgbGl0ZXJhbHM6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gUmVwbGFjZSBhbGwgdGhlIGxpdGVyYWxzIHdpdGggQEBALiBIb3BlZnVsbHkgYSBzdHJpbmcgdGhhdCB3b24ndCBleGlzdCBpbiB0aGUgZm9ybWF0XG4gIGxldCBuZXdGb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsaXRlcmFsLCAoJDAsICQxKSA9PiB7XG4gICAgbGl0ZXJhbHMucHVzaChyZWdleEVzY2FwZSgkMSkpO1xuICAgIHJldHVybiBcIkBAQFwiO1xuICB9KTtcbiAgY29uc3Qgc3BlY2lmaWVkRmllbGRzOiB7IFtmaWVsZDogc3RyaW5nXTogYm9vbGVhbiB9ID0ge307XG4gIGNvbnN0IHJlcXVpcmVkRmllbGRzOiB7IFtmaWVsZDogc3RyaW5nXTogYm9vbGVhbiB9ID0ge307XG5cbiAgLy8gQ2hhbmdlIGV2ZXJ5IHRva2VuIHRoYXQgd2UgZmluZCBpbnRvIHRoZSBjb3JyZWN0IHJlZ2V4XG4gIG5ld0Zvcm1hdCA9IHJlZ2V4RXNjYXBlKG5ld0Zvcm1hdCkucmVwbGFjZSh0b2tlbiwgJDAgPT4ge1xuICAgIGNvbnN0IGluZm8gPSBwYXJzZUZsYWdzWyQwXTtcbiAgICBjb25zdCBbZmllbGQsIHJlZ2V4LCAsIHJlcXVpcmVkRmllbGRdID0gaW5mbztcblxuICAgIC8vIENoZWNrIGlmIHRoZSBwZXJzb24gaGFzIHNwZWNpZmllZCB0aGUgc2FtZSBmaWVsZCB0d2ljZS4gVGhpcyB3aWxsIGxlYWQgdG8gY29uZnVzaW5nIHJlc3VsdHMuXG4gICAgaWYgKHNwZWNpZmllZEZpZWxkc1tmaWVsZF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmb3JtYXQuICR7ZmllbGR9IHNwZWNpZmllZCB0d2ljZSBpbiBmb3JtYXRgKTtcbiAgICB9XG5cbiAgICBzcGVjaWZpZWRGaWVsZHNbZmllbGRdID0gdHJ1ZTtcblxuICAgIC8vIENoZWNrIGlmIHRoZXJlIGFyZSBhbnkgcmVxdWlyZWQgZmllbGRzLiBGb3IgaW5zdGFuY2UsIDEyIGhvdXIgdGltZSByZXF1aXJlcyBBTS9QTSBzcGVjaWZpZWRcbiAgICBpZiAocmVxdWlyZWRGaWVsZCkge1xuICAgICAgcmVxdWlyZWRGaWVsZHNbcmVxdWlyZWRGaWVsZF0gPSB0cnVlO1xuICAgIH1cblxuICAgIHBhcnNlSW5mby5wdXNoKGluZm8pO1xuICAgIHJldHVybiBcIihcIiArIHJlZ2V4ICsgXCIpXCI7XG4gIH0pO1xuXG4gIC8vIENoZWNrIGFsbCB0aGUgcmVxdWlyZWQgZmllbGRzIGFyZSBwcmVzZW50XG4gIE9iamVjdC5rZXlzKHJlcXVpcmVkRmllbGRzKS5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICBpZiAoIXNwZWNpZmllZEZpZWxkc1tmaWVsZF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgZm9ybWF0LiAke2ZpZWxkfSBpcyByZXF1aXJlZCBpbiBzcGVjaWZpZWQgZm9ybWF0YFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEFkZCBiYWNrIGFsbCB0aGUgbGl0ZXJhbHMgYWZ0ZXJcbiAgbmV3Rm9ybWF0ID0gbmV3Rm9ybWF0LnJlcGxhY2UoL0BAQC9nLCAoKSA9PiBsaXRlcmFscy5zaGlmdCgpKTtcblxuICAvLyBDaGVjayBpZiB0aGUgZGF0ZSBzdHJpbmcgbWF0Y2hlcyB0aGUgZm9ybWF0LiBJZiBpdCBkb2Vzbid0IHJldHVybiBudWxsXG4gIGNvbnN0IG1hdGNoZXMgPSBkYXRlU3RyLm1hdGNoKG5ldyBSZWdFeHAobmV3Rm9ybWF0LCBcImlcIikpO1xuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGNvbWJpbmVkSTE4blNldHRpbmdzOiBJMThuU2V0dGluZ3MgPSBhc3NpZ24oXG4gICAgYXNzaWduKHt9LCBnbG9iYWxJMThuKSxcbiAgICBpMThuXG4gICk7XG5cbiAgLy8gRm9yIGVhY2ggbWF0Y2gsIGNhbGwgdGhlIHBhcnNlciBmdW5jdGlvbiBmb3IgdGhhdCBkYXRlIHBhcnRcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgW2ZpZWxkLCAsIHBhcnNlcl0gPSBwYXJzZUluZm9baSAtIDFdO1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VyXG4gICAgICA/IHBhcnNlcihtYXRjaGVzW2ldLCBjb21iaW5lZEkxOG5TZXR0aW5ncylcbiAgICAgIDogK21hdGNoZXNbaV07XG5cbiAgICAvLyBJZiB0aGUgcGFyc2VyIGNhbid0IG1ha2Ugc2Vuc2Ugb2YgdGhlIHZhbHVlLCByZXR1cm4gbnVsbFxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBkYXRlSW5mb1tmaWVsZF0gPSB2YWx1ZTtcbiAgfVxuXG4gIGlmIChkYXRlSW5mby5pc1BtID09PSAxICYmIGRhdGVJbmZvLmhvdXIgIT0gbnVsbCAmJiArZGF0ZUluZm8uaG91ciAhPT0gMTIpIHtcbiAgICBkYXRlSW5mby5ob3VyID0gK2RhdGVJbmZvLmhvdXIgKyAxMjtcbiAgfSBlbHNlIGlmIChkYXRlSW5mby5pc1BtID09PSAwICYmICtkYXRlSW5mby5ob3VyID09PSAxMikge1xuICAgIGRhdGVJbmZvLmhvdXIgPSAwO1xuICB9XG5cbiAgbGV0IGRhdGVUWjogRGF0ZTtcbiAgaWYgKGRhdGVJbmZvLnRpbWV6b25lT2Zmc2V0ID09IG51bGwpIHtcbiAgICBkYXRlVFogPSBuZXcgRGF0ZShcbiAgICAgIGRhdGVJbmZvLnllYXIsXG4gICAgICBkYXRlSW5mby5tb250aCxcbiAgICAgIGRhdGVJbmZvLmRheSxcbiAgICAgIGRhdGVJbmZvLmhvdXIsXG4gICAgICBkYXRlSW5mby5taW51dGUsXG4gICAgICBkYXRlSW5mby5zZWNvbmQsXG4gICAgICBkYXRlSW5mby5taWxsaXNlY29uZFxuICAgICk7XG4gICAgY29uc3QgdmFsaWRhdGVGaWVsZHM6IFtcbiAgICAgIFwibW9udGhcIiB8IFwiZGF5XCIgfCBcImhvdXJcIiB8IFwibWludXRlXCIgfCBcInNlY29uZFwiLFxuICAgICAgXCJnZXRNb250aFwiIHwgXCJnZXREYXRlXCIgfCBcImdldEhvdXJzXCIgfCBcImdldE1pbnV0ZXNcIiB8IFwiZ2V0U2Vjb25kc1wiXG4gICAgXVtdID0gW1xuICAgICAgW1wibW9udGhcIiwgXCJnZXRNb250aFwiXSxcbiAgICAgIFtcImRheVwiLCBcImdldERhdGVcIl0sXG4gICAgICBbXCJob3VyXCIsIFwiZ2V0SG91cnNcIl0sXG4gICAgICBbXCJtaW51dGVcIiwgXCJnZXRNaW51dGVzXCJdLFxuICAgICAgW1wic2Vjb25kXCIsIFwiZ2V0U2Vjb25kc1wiXVxuICAgIF07XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbGlkYXRlRmllbGRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvLyBDaGVjayB0byBtYWtlIHN1cmUgdGhlIGRhdGUgZmllbGQgaXMgd2l0aGluIHRoZSBhbGxvd2VkIHJhbmdlLiBKYXZhc2NyaXB0IGRhdGVzIGFsbG93cyB2YWx1ZXNcbiAgICAgIC8vIG91dHNpZGUgdGhlIGFsbG93ZWQgcmFuZ2UuIElmIHRoZSB2YWx1ZXMgZG9uJ3QgbWF0Y2ggdGhlIHZhbHVlIHdhcyBpbnZhbGlkXG4gICAgICBpZiAoXG4gICAgICAgIHNwZWNpZmllZEZpZWxkc1t2YWxpZGF0ZUZpZWxkc1tpXVswXV0gJiZcbiAgICAgICAgZGF0ZUluZm9bdmFsaWRhdGVGaWVsZHNbaV1bMF1dICE9PSBkYXRlVFpbdmFsaWRhdGVGaWVsZHNbaV1bMV1dKClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGF0ZVRaID0gbmV3IERhdGUoXG4gICAgICBEYXRlLlVUQyhcbiAgICAgICAgZGF0ZUluZm8ueWVhcixcbiAgICAgICAgZGF0ZUluZm8ubW9udGgsXG4gICAgICAgIGRhdGVJbmZvLmRheSxcbiAgICAgICAgZGF0ZUluZm8uaG91cixcbiAgICAgICAgZGF0ZUluZm8ubWludXRlIC0gZGF0ZUluZm8udGltZXpvbmVPZmZzZXQsXG4gICAgICAgIGRhdGVJbmZvLnNlY29uZCxcbiAgICAgICAgZGF0ZUluZm8ubWlsbGlzZWNvbmRcbiAgICAgIClcbiAgICApO1xuXG4gICAgLy8gV2UgY2FuJ3QgdmFsaWRhdGUgZGF0ZXMgaW4gYW5vdGhlciB0aW1lem9uZSB1bmZvcnR1bmF0ZWx5LiBEbyBhIGJhc2ljIGNoZWNrIGluc3RlYWRcbiAgICBpZiAoXG4gICAgICBkYXRlSW5mby5tb250aCA+IDExIHx8XG4gICAgICBkYXRlSW5mby5tb250aCA8IDAgfHxcbiAgICAgIGRhdGVJbmZvLmRheSA+IDMxIHx8XG4gICAgICBkYXRlSW5mby5kYXkgPCAxIHx8XG4gICAgICBkYXRlSW5mby5ob3VyID4gMjMgfHxcbiAgICAgIGRhdGVJbmZvLmhvdXIgPCAwIHx8XG4gICAgICBkYXRlSW5mby5taW51dGUgPiA1OSB8fFxuICAgICAgZGF0ZUluZm8ubWludXRlIDwgMCB8fFxuICAgICAgZGF0ZUluZm8uc2Vjb25kID4gNTkgfHxcbiAgICAgIGRhdGVJbmZvLnNlY29uZCA8IDBcbiAgICApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIERvbid0IGFsbG93IGludmFsaWQgZGF0ZXNcblxuICByZXR1cm4gZGF0ZVRaO1xufVxuZXhwb3J0IGRlZmF1bHQge1xuICBmb3JtYXQsXG4gIHBhcnNlLFxuICBkZWZhdWx0STE4bixcbiAgc2V0R2xvYmFsRGF0ZUkxOG4sXG4gIHNldEdsb2JhbERhdGVNYXNrc1xufTtcbmV4cG9ydCB7IGZvcm1hdCwgcGFyc2UsIGRlZmF1bHRJMThuLCBzZXRHbG9iYWxEYXRlSTE4biwgc2V0R2xvYmFsRGF0ZU1hc2tzIH07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBmZWNoYSA9IHJlcXVpcmUoJ2ZlY2hhJyk7XG5jb25zdCBmb3JtYXQgPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xuXG4vKlxuICogZnVuY3Rpb24gdGltZXN0YW1wIChpbmZvKVxuICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgdGltZXN0YW1wIEZvcm1hdCB3aGljaCBhZGRzIGEgdGltZXN0YW1wXG4gKiB0byB0aGUgaW5mby4gSXQgd2FzIHByZXZpb3VzbHkgYXZhaWxhYmxlIGluIHdpbnN0b24gPCAzLjAuMCBhczpcbiAqXG4gKiAtIHsgdGltZXN0YW1wOiB0cnVlIH0gICAgICAgICAgICAgLy8gYG5ldyBEYXRlLnRvSVNPU3RyaW5nKClgXG4gKiAtIHsgdGltZXN0YW1wOiBmdW5jdGlvbjpTdHJpbmcgfSAgLy8gVmFsdWUgcmV0dXJuZWQgYnkgYHRpbWVzdGFtcCgpYFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcm1hdCgoaW5mbywgb3B0cyA9IHt9KSA9PiB7XG4gIGlmIChvcHRzLmZvcm1hdCkge1xuICAgIGluZm8udGltZXN0YW1wID0gdHlwZW9mIG9wdHMuZm9ybWF0ID09PSAnZnVuY3Rpb24nXG4gICAgICA/IG9wdHMuZm9ybWF0KClcbiAgICAgIDogZmVjaGEuZm9ybWF0KG5ldyBEYXRlKCksIG9wdHMuZm9ybWF0KTtcbiAgfVxuXG4gIGlmICghaW5mby50aW1lc3RhbXApIHtcbiAgICBpbmZvLnRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgfVxuXG4gIGlmIChvcHRzLmFsaWFzKSB7XG4gICAgaW5mb1tvcHRzLmFsaWFzXSA9IGluZm8udGltZXN0YW1wO1xuICB9XG5cbiAgcmV0dXJuIGluZm87XG59KTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNvbG9ycyA9IHJlcXVpcmUoJ0Bjb2xvcnMvY29sb3JzL3NhZmUnKTtcbmNvbnN0IGZvcm1hdCA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG5jb25zdCB7IE1FU1NBR0UgfSA9IHJlcXVpcmUoJ3RyaXBsZS1iZWFtJyk7XG5cbi8qXG4gKiBmdW5jdGlvbiB1bmNvbG9yaXplIChpbmZvKVxuICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgdW5jb2xvcml6ZSBGb3JtYXQgdGhhdCBzdHJpcHMgY29sb3JzXG4gKiBmcm9tIGBpbmZvYCBvYmplY3RzLiBUaGlzIHdhcyBwcmV2aW91c2x5IGV4cG9zZWQgYXMgeyBzdHJpcENvbG9yczogdHJ1ZSB9XG4gKiB0byB0cmFuc3BvcnRzIGluIGB3aW5zdG9uIDwgMy4wLjBgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcm1hdCgoaW5mbywgb3B0cykgPT4ge1xuICBpZiAob3B0cy5sZXZlbCAhPT0gZmFsc2UpIHtcbiAgICBpbmZvLmxldmVsID0gY29sb3JzLnN0cmlwKGluZm8ubGV2ZWwpO1xuICB9XG5cbiAgaWYgKG9wdHMubWVzc2FnZVx1MDBBMCE9PSBmYWxzZSkge1xuICAgIGluZm8ubWVzc2FnZSA9IGNvbG9ycy5zdHJpcChTdHJpbmcoaW5mby5tZXNzYWdlKSk7XG4gIH1cblxuICBpZiAob3B0cy5yYXcgIT09IGZhbHNlICYmIGluZm9bTUVTU0FHRV0pIHtcbiAgICBpbmZvW01FU1NBR0VdID0gY29sb3JzLnN0cmlwKFN0cmluZyhpbmZvW01FU1NBR0VdKSk7XG4gIH1cblxuICByZXR1cm4gaW5mbztcbn0pO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuLypcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBmb3JtYXRcbiAqIEJvdGggdGhlIGNvbnN0cnVjdGlvbiBtZXRob2QgYW5kIHNldCBvZiBleHBvc2VkXG4gKiBmb3JtYXRzLlxuICovXG5jb25zdCBmb3JtYXQgPSBleHBvcnRzLmZvcm1hdCA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG5cbi8qXG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCB7ZnVuY3Rpb259IGxldmVsc1xuICogUmVnaXN0ZXJzIHRoZSBzcGVjaWZpZWQgbGV2ZWxzIHdpdGggbG9nZm9ybS5cbiAqL1xuZXhwb3J0cy5sZXZlbHMgPSByZXF1aXJlKCcuL2xldmVscycpO1xuXG4vKlxuICogQGFwaSBwcml2YXRlXG4gKiBtZXRob2Qge2Z1bmN0aW9ufSBleHBvc2VGb3JtYXRcbiAqIEV4cG9zZXMgYSBzdWItZm9ybWF0IG9uIHRoZSBtYWluIGZvcm1hdCBvYmplY3RcbiAqIGFzIGEgbGF6eS1sb2FkZWQgZ2V0dGVyLlxuICovXG5mdW5jdGlvbiBleHBvc2VGb3JtYXQobmFtZSwgcmVxdWlyZUZvcm1hdCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm9ybWF0LCBuYW1lLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHJlcXVpcmVGb3JtYXQoKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy9cbi8vIFNldHVwIGFsbCB0cmFuc3BvcnRzIGFzIGxhenktbG9hZGVkIGdldHRlcnMuXG4vL1xuZXhwb3NlRm9ybWF0KCdhbGlnbicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJy4vYWxpZ24nKTsgfSk7XG5leHBvc2VGb3JtYXQoJ2Vycm9ycycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJy4vZXJyb3JzJyk7IH0pO1xuZXhwb3NlRm9ybWF0KCdjbGknLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCcuL2NsaScpOyB9KTtcbmV4cG9zZUZvcm1hdCgnY29tYmluZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJy4vY29tYmluZScpOyB9KTtcbmV4cG9zZUZvcm1hdCgnY29sb3JpemUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCcuL2NvbG9yaXplJyk7IH0pO1xuZXhwb3NlRm9ybWF0KCdqc29uJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZSgnLi9qc29uJyk7IH0pO1xuZXhwb3NlRm9ybWF0KCdsYWJlbCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJy4vbGFiZWwnKTsgfSk7XG5leHBvc2VGb3JtYXQoJ2xvZ3N0YXNoJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZSgnLi9sb2dzdGFzaCcpOyB9KTtcbmV4cG9zZUZvcm1hdCgnbWV0YWRhdGEnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCcuL21ldGFkYXRhJyk7IH0pO1xuZXhwb3NlRm9ybWF0KCdtcycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJy4vbXMnKTsgfSk7XG5leHBvc2VGb3JtYXQoJ3BhZExldmVscycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJy4vcGFkLWxldmVscycpOyB9KTtcbmV4cG9zZUZvcm1hdCgncHJldHR5UHJpbnQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCcuL3ByZXR0eS1wcmludCcpOyB9KTtcbmV4cG9zZUZvcm1hdCgncHJpbnRmJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZSgnLi9wcmludGYnKTsgfSk7XG5leHBvc2VGb3JtYXQoJ3NpbXBsZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJy4vc2ltcGxlJyk7IH0pO1xuZXhwb3NlRm9ybWF0KCdzcGxhdCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJy4vc3BsYXQnKTsgfSk7XG5leHBvc2VGb3JtYXQoJ3RpbWVzdGFtcCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJy4vdGltZXN0YW1wJyk7IH0pO1xuZXhwb3NlRm9ybWF0KCd1bmNvbG9yaXplJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWlyZSgnLi91bmNvbG9yaXplJyk7IH0pO1xuIiwgIi8qKlxuICogY29tbW9uLmpzOiBJbnRlcm5hbCBoZWxwZXIgYW5kIHV0aWxpdHkgZnVuY3Rpb25zIGZvciB3aW5zdG9uLlxuICpcbiAqIChDKSAyMDEwIENoYXJsaWUgUm9iYmluc1xuICogTUlUIExJQ0VOQ0VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgZm9ybWF0IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogU2V0IG9mIHNpbXBsZSBkZXByZWNhdGlvbiBub3RpY2VzIGFuZCBhIHdheSB0byBleHBvc2UgdGhlbSBmb3IgYSBzZXQgb2ZcbiAqIHByb3BlcnRpZXMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy53YXJuID0ge1xuICBkZXByZWNhdGVkKHByb3ApIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgneyAlcyB9IHdhcyByZW1vdmVkIGluIHdpbnN0b25AMy4wLjAuJywgcHJvcCkpO1xuICAgIH07XG4gIH0sXG4gIHVzZUZvcm1hdChwcm9wKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgIGZvcm1hdCgneyAlcyB9IHdhcyByZW1vdmVkIGluIHdpbnN0b25AMy4wLjAuJywgcHJvcCksXG4gICAgICAgICdVc2UgYSBjdXN0b20gd2luc3Rvbi5mb3JtYXQgPSB3aW5zdG9uLmZvcm1hdChmdW5jdGlvbikgaW5zdGVhZC4nXG4gICAgICBdLmpvaW4oJ1xcbicpKTtcbiAgICB9O1xuICB9LFxuICBmb3JGdW5jdGlvbnMob2JqLCB0eXBlLCBwcm9wcykge1xuICAgIHByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBvYmpbcHJvcF0gPSBleHBvcnRzLndhcm5bdHlwZV0ocHJvcCk7XG4gICAgfSk7XG4gIH0sXG4gIGZvclByb3BlcnRpZXMob2JqLCB0eXBlLCBwcm9wcykge1xuICAgIHByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBjb25zdCBub3RpY2UgPSBleHBvcnRzLndhcm5bdHlwZV0ocHJvcCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgICAgIGdldDogbm90aWNlLFxuICAgICAgICBzZXQ6IG5vdGljZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG4iLCAie1xuICBcIm5hbWVcIjogXCJ3aW5zdG9uXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIGxvZ2dlciBmb3IganVzdCBhYm91dCBldmVyeXRoaW5nLlwiLFxuICBcInZlcnNpb25cIjogXCIzLjExLjBcIixcbiAgXCJhdXRob3JcIjogXCJDaGFybGllIFJvYmJpbnMgPGNoYXJsaWUucm9iYmluc0BnbWFpbC5jb20+XCIsXG4gIFwibWFpbnRhaW5lcnNcIjogW1xuICAgIFwiRGF2aWQgSHlkZSA8ZGFiaEBhbHVtbmkuc3RhbmZvcmQuZWR1PlwiXG4gIF0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vd2luc3RvbmpzL3dpbnN0b24uZ2l0XCJcbiAgfSxcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJ3aW5zdG9uXCIsXG4gICAgXCJsb2dnZXJcIixcbiAgICBcImxvZ2dpbmdcIixcbiAgICBcImxvZ3NcIixcbiAgICBcInN5c2FkbWluXCIsXG4gICAgXCJidW55YW5cIixcbiAgICBcInBpbm9cIixcbiAgICBcImxvZ2xldmVsXCIsXG4gICAgXCJ0b29sc1wiLFxuICAgIFwianNvblwiLFxuICAgIFwic3RyZWFtXCJcbiAgXSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQGRhYmgvZGlhZ25vc3RpY3NcIjogXCJeMi4wLjJcIixcbiAgICBcIkBjb2xvcnMvY29sb3JzXCI6IFwiXjEuNi4wXCIsXG4gICAgXCJhc3luY1wiOiBcIl4zLjIuM1wiLFxuICAgIFwiaXMtc3RyZWFtXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJsb2dmb3JtXCI6IFwiXjIuNC4wXCIsXG4gICAgXCJvbmUtdGltZVwiOiBcIl4xLjAuMFwiLFxuICAgIFwicmVhZGFibGUtc3RyZWFtXCI6IFwiXjMuNC4wXCIsXG4gICAgXCJzYWZlLXN0YWJsZS1zdHJpbmdpZnlcIjogXCJeMi4zLjFcIixcbiAgICBcInN0YWNrLXRyYWNlXCI6IFwiMC4wLnhcIixcbiAgICBcInRyaXBsZS1iZWFtXCI6IFwiXjEuMy4wXCIsXG4gICAgXCJ3aW5zdG9uLXRyYW5zcG9ydFwiOiBcIl40LjUuMFwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBiYWJlbC9jbGlcIjogXCJeNy4xNy4wXCIsXG4gICAgXCJAYmFiZWwvY29yZVwiOiBcIl43LjE3LjJcIixcbiAgICBcIkBiYWJlbC9wcmVzZXQtZW52XCI6IFwiXjcuMTYuN1wiLFxuICAgIFwiQGRhYmgvZXNsaW50LWNvbmZpZy1wb3B1bGlzdFwiOiBcIl41LjAuMFwiLFxuICAgIFwiQHR5cGVzL25vZGVcIjogXCJeMjAuMy4xXCIsXG4gICAgXCJhYnN0cmFjdC13aW5zdG9uLXRyYW5zcG9ydFwiOiBcIl4wLjUuMVwiLFxuICAgIFwiYXNzdW1lXCI6IFwiXjIuMi4wXCIsXG4gICAgXCJjcm9zcy1zcGF3bi1hc3luY1wiOiBcIl4yLjIuNVwiLFxuICAgIFwiZXNsaW50XCI6IFwiXjguOS4wXCIsXG4gICAgXCJob2NrXCI6IFwiXjEuNC4xXCIsXG4gICAgXCJtb2NoYVwiOiBcIjguMS4zXCIsXG4gICAgXCJueWNcIjogXCJeMTUuMS4wXCIsXG4gICAgXCJyaW1yYWZcIjogXCJeNS4wLjVcIixcbiAgICBcInNwbGl0MlwiOiBcIl40LjEuMFwiLFxuICAgIFwic3RkLW1vY2tzXCI6IFwiXjEuMC4xXCIsXG4gICAgXCJ0aHJvdWdoMlwiOiBcIl40LjAuMlwiLFxuICAgIFwid2luc3Rvbi1jb21wYXRcIjogXCJeMC4xLjVcIlxuICB9LFxuICBcIm1haW5cIjogXCIuL2xpYi93aW5zdG9uLmpzXCIsXG4gIFwiYnJvd3NlclwiOiBcIi4vZGlzdC93aW5zdG9uXCIsXG4gIFwidHlwZXNcIjogXCIuL2luZGV4LmQudHNcIixcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImxpbnRcIjogXCJlc2xpbnQgbGliLyouanMgbGliL3dpbnN0b24vKi5qcyBsaWIvd2luc3Rvbi8qKi8qLmpzIC0tcmVzb2x2ZS1wbHVnaW5zLXJlbGF0aXZlLXRvIC4vbm9kZV9tb2R1bGVzL0BkYWJoL2VzbGludC1jb25maWctcG9wdWxpc3RcIixcbiAgICBcInRlc3RcIjogXCJtb2NoYVwiLFxuICAgIFwidGVzdDpjb3ZlcmFnZVwiOiBcIm55YyBucG0gcnVuIHRlc3Q6dW5pdFwiLFxuICAgIFwidGVzdDp1bml0XCI6IFwibW9jaGEgdGVzdC91bml0XCIsXG4gICAgXCJ0ZXN0OmludGVncmF0aW9uXCI6IFwibW9jaGEgdGVzdC9pbnRlZ3JhdGlvblwiLFxuICAgIFwiYnVpbGRcIjogXCJyaW1yYWYgZGlzdCAmJiBiYWJlbCBsaWIgLWQgZGlzdFwiLFxuICAgIFwicHJlcHVibGlzaE9ubHlcIjogXCJucG0gcnVuIGJ1aWxkXCJcbiAgfSxcbiAgXCJlbmdpbmVzXCI6IHtcbiAgICBcIm5vZGVcIjogXCI+PSAxMi4wLjBcIlxuICB9LFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIlxufVxuIiwgIlxuLyoqXG4gKiBGb3IgTm9kZS5qcywgc2ltcGx5IHJlLWV4cG9ydCB0aGUgY29yZSBgdXRpbC5kZXByZWNhdGVgIGZ1bmN0aW9uLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgndXRpbCcpLmRlcHJlY2F0ZTtcbiIsICJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlTlQoc2VsZiwgZXJyKSB7XG4gIGVtaXRFcnJvck5UKHNlbGYsIGVycik7XG4gIGVtaXRDbG9zZU5UKHNlbGYpO1xufVxuZnVuY3Rpb24gZW1pdENsb3NlTlQoc2VsZikge1xuICBpZiAoc2VsZi5fd3JpdGFibGVTdGF0ZSAmJiAhc2VsZi5fd3JpdGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgaWYgKHNlbGYuX3JlYWRhYmxlU3RhdGUgJiYgIXNlbGYuX3JlYWRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIHNlbGYuZW1pdCgnY2xvc2UnKTtcbn1cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5hbENhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpIHtcbiAgLy8gV2UgaGF2ZSB0ZXN0cyB0aGF0IHJlbHkgb24gZXJyb3JzIGJlaW5nIGVtaXR0ZWRcbiAgLy8gaW4gdGhlIHNhbWUgdGljaywgc28gY2hhbmdpbmcgdGhpcyBpcyBzZW12ZXIgbWFqb3IuXG4gIC8vIEZvciBub3cgd2hlbiB5b3Ugb3B0LWluIHRvIGF1dG9EZXN0cm95IHdlIGFsbG93XG4gIC8vIHRoZSBlcnJvciB0byBiZSBlbWl0dGVkIG5leHRUaWNrLiBJbiBhIGZ1dHVyZVxuICAvLyBzZW12ZXIgbWFqb3IgdXBkYXRlIHdlIHNob3VsZCBjaGFuZ2UgdGhlIGRlZmF1bHQgdG8gdGhpcy5cblxuICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICBpZiAoclN0YXRlICYmIHJTdGF0ZS5hdXRvRGVzdHJveSB8fCB3U3RhdGUgJiYgd1N0YXRlLmF1dG9EZXN0cm95KSBzdHJlYW0uZGVzdHJveShlcnIpO2Vsc2Ugc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveSxcbiAgZXJyb3JPckRlc3Ryb3k6IGVycm9yT3JEZXN0cm95XG59OyIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNvZGVzID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gIGlmICghQmFzZSkge1xuICAgIEJhc2UgPSBFcnJvclxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZSAoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpXG4gICAgfVxuICB9XG5cbiAgY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IgKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIHN1cGVyKGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykpO1xuICAgIH1cbiAgfVxuXG4gIE5vZGVFcnJvci5wcm90b3R5cGUubmFtZSA9IEJhc2UubmFtZTtcbiAgTm9kZUVycm9yLnByb3RvdHlwZS5jb2RlID0gY29kZTtcblxuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgY29uc3QgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKChpKSA9PiBTdHJpbmcoaSkpO1xuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gYG9uZSBvZiAke3RoaW5nfSAke2V4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyl9LCBvciBgICtcbiAgICAgICAgICAgICBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIGBvbmUgb2YgJHt0aGluZ30gJHtleHBlY3RlZFswXX0gb3IgJHtleHBlY3RlZFsxXX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYG9mICR7dGhpbmd9ICR7ZXhwZWN0ZWRbMF19YDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGBvZiAke3RoaW5nfSAke1N0cmluZyhleHBlY3RlZCl9YDtcbiAgfVxufVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aFxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XG5cdHJldHVybiBzdHIuc3Vic3RyKCFwb3MgfHwgcG9zIDwgMCA/IDAgOiArcG9zLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuXHRpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcblx0XHR0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG5cdH1cblx0cmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn1cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luY2x1ZGVzXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiAnVGhlIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiJ1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuICBsZXQgZGV0ZXJtaW5lcjtcbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIGxldCBtc2c7XG4gIGlmIChlbmRzV2l0aChuYW1lLCAnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gYFRoZSAke25hbWV9ICR7ZGV0ZXJtaW5lcn0gJHtvbmVPZihleHBlY3RlZCwgJ3R5cGUnKX1gO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHR5cGUgPSBpbmNsdWRlcyhuYW1lLCAnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG4gICAgbXNnID0gYFRoZSBcIiR7bmFtZX1cIiAke3R5cGV9ICR7ZGV0ZXJtaW5lcn0gJHtvbmVPZihleHBlY3RlZCwgJ3R5cGUnKX1gO1xuICB9XG5cbiAgbXNnICs9IGAuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWA7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GJywgJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdUaGUgJyArIG5hbWUgKyAnIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQnXG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnLCAnUHJlbWF0dXJlIGNsb3NlJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fREVTVFJPWUVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdDYW5ub3QgY2FsbCAnICsgbmFtZSArICcgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZCc7XG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01VTFRJUExFX0NBTExCQUNLJywgJ0NhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX0NBTk5PVF9QSVBFJywgJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQnLCAnd3JpdGUgYWZ0ZXIgZW5kJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fTlVMTF9WQUxVRVMnLCAnTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfVU5LTk9XTl9FTkNPRElORycsIGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuICdVbmtub3duIGVuY29kaW5nOiAnICsgYXJnXG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UJywgJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX0lOVkFMSURfT1BUX1ZBTFVFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX0lOVkFMSURfT1BUX1ZBTFVFO1xuZnVuY3Rpb24gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSkge1xuICByZXR1cm4gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrICE9IG51bGwgPyBvcHRpb25zLmhpZ2hXYXRlck1hcmsgOiBpc0R1cGxleCA/IG9wdGlvbnNbZHVwbGV4S2V5XSA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRIaWdoV2F0ZXJNYXJrKHN0YXRlLCBvcHRpb25zLCBkdXBsZXhLZXksIGlzRHVwbGV4KSB7XG4gIHZhciBod20gPSBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KTtcbiAgaWYgKGh3bSAhPSBudWxsKSB7XG4gICAgaWYgKCEoaXNGaW5pdGUoaHdtKSAmJiBNYXRoLmZsb29yKGh3bSkgPT09IGh3bSkgfHwgaHdtIDwgMCkge1xuICAgICAgdmFyIG5hbWUgPSBpc0R1cGxleCA/IGR1cGxleEtleSA6ICdoaWdoV2F0ZXJNYXJrJztcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9PUFRfVkFMVUUobmFtZSwgaHdtKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoaHdtKTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgdmFsdWVcbiAgcmV0dXJuIHN0YXRlLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRIaWdoV2F0ZXJNYXJrOiBnZXRIaWdoV2F0ZXJNYXJrXG59OyIsICJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCAidHJ5IHtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0eXBlb2YgdXRpbC5pbmhlcml0cyAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgJyc7XG4gIG1vZHVsZS5leHBvcnRzID0gdXRpbC5pbmhlcml0cztcbn0gY2F0Y2ggKGUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2luaGVyaXRzX2Jyb3dzZXIuanMnKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnYnVmZmVyJyksXG4gIEJ1ZmZlciA9IF9yZXF1aXJlLkJ1ZmZlcjtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsJyksXG4gIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDtcbnZhciBjdXN0b20gPSBpbnNwZWN0ICYmIGluc3BlY3QuY3VzdG9tIHx8ICdpbnNwZWN0JztcbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBCdWZmZXIucHJvdG90eXBlLmNvcHkuY2FsbChzcmMsIHRhcmdldCwgb2Zmc2V0KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoQnVmZmVyTGlzdCwgW3tcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5zaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogdGhpcy5oZWFkXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgLS10aGlzLmxlbmd0aDtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiam9pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25jYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBvciBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uc3VtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdW1lKG4sIGhhc1N0cmluZ3MpIHtcbiAgICAgIHZhciByZXQ7XG4gICAgICBpZiAobiA8IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBgc2xpY2VgIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgICByZXQgPSB0aGlzLmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICAgICAgdGhpcy5oZWFkLmRhdGEgPSB0aGlzLmhlYWQuZGF0YS5zbGljZShuKTtcbiAgICAgIH0gZWxzZSBpZiAobiA9PT0gdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIEZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaC5cbiAgICAgICAgcmV0ID0gdGhpcy5zaGlmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyLlxuICAgICAgICByZXQgPSBoYXNTdHJpbmdzID8gdGhpcy5fZ2V0U3RyaW5nKG4pIDogdGhpcy5fZ2V0QnVmZmVyKG4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlyc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgfVxuXG4gICAgLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0U3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTdHJpbmcobikge1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgYyA9IDE7XG4gICAgICB2YXIgcmV0ID0gcC5kYXRhO1xuICAgICAgbiAtPSByZXQubGVuZ3RoO1xuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICAgICAgbiAtPSBuYjtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XG4gICAgICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICArK2M7XG4gICAgICB9XG4gICAgICB0aGlzLmxlbmd0aCAtPSBjO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRCdWZmZXIobikge1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgcC5kYXRhLmNvcHkocmV0KTtcbiAgICAgIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICAgICAgbiAtPSBuYjtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XG4gICAgICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICArK2M7XG4gICAgICB9XG4gICAgICB0aGlzLmxlbmd0aCAtPSBjO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGxpbmtlZCBsaXN0IG9ubHkgc2hvd3MgdGhlIG1pbmltYWwgbmVjZXNzYXJ5IGluZm9ybWF0aW9uLlxuICB9LCB7XG4gICAga2V5OiBjdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKF8sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgIC8vIE9ubHkgaW5zcGVjdCBvbmUgbGV2ZWwuXG4gICAgICAgIGRlcHRoOiAwLFxuICAgICAgICAvLyBJdCBzaG91bGQgbm90IHJlY3Vyc2UuXG4gICAgICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpOyIsICIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2VuZC1vZi1zdHJlYW0gd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0U7XG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufVxuZnVuY3Rpb24gbm9vcCgpIHt9XG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBlb3Moc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBlb3Moc3RyZWFtLCBudWxsLCBvcHRzKTtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgdmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCBvcHRzLnJlYWRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ucmVhZGFibGU7XG4gIHZhciB3cml0YWJsZSA9IG9wdHMud3JpdGFibGUgfHwgb3B0cy53cml0YWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLndyaXRhYmxlO1xuICB2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbiBvbmxlZ2FjeWZpbmlzaCgpIHtcbiAgICBpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcbiAgfTtcbiAgdmFyIHdyaXRhYmxlRW5kZWQgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgc3RyZWFtLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkO1xuICB2YXIgb25maW5pc2ggPSBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICB3cml0YWJsZSA9IGZhbHNlO1xuICAgIHdyaXRhYmxlRW5kZWQgPSB0cnVlO1xuICAgIGlmICghcmVhZGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcbiAgfTtcbiAgdmFyIHJlYWRhYmxlRW5kZWQgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGUgJiYgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQ7XG4gIHZhciBvbmVuZCA9IGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgcmVhZGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCF3cml0YWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gIH07XG4gIHZhciBvbmNsb3NlID0gZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICB2YXIgZXJyO1xuICAgIGlmIChyZWFkYWJsZSAmJiAhcmVhZGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3JlYWRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuICAgIGlmICh3cml0YWJsZSAmJiAhd3JpdGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3dyaXRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuICB9O1xuICB2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24gb25yZXF1ZXN0KCkge1xuICAgIHN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgfTtcbiAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG4gICAgc3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO2Vsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgfSBlbHNlIGlmICh3cml0YWJsZSAmJiAhc3RyZWFtLl93cml0YWJsZVN0YXRlKSB7XG4gICAgLy8gbGVnYWN5IHN0cmVhbXNcbiAgICBzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICB9XG4gIHN0cmVhbS5vbignZW5kJywgb25lbmQpO1xuICBzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgaWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKSBzdHJlYW0ub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICAgIGlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBlb3M7IiwgIid1c2Ugc3RyaWN0JztcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlTztcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbnZhciBmaW5pc2hlZCA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xudmFyIGtMYXN0UmVzb2x2ZSA9IFN5bWJvbCgnbGFzdFJlc29sdmUnKTtcbnZhciBrTGFzdFJlamVjdCA9IFN5bWJvbCgnbGFzdFJlamVjdCcpO1xudmFyIGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcbnZhciBrRW5kZWQgPSBTeW1ib2woJ2VuZGVkJyk7XG52YXIga0xhc3RQcm9taXNlID0gU3ltYm9sKCdsYXN0UHJvbWlzZScpO1xudmFyIGtIYW5kbGVQcm9taXNlID0gU3ltYm9sKCdoYW5kbGVQcm9taXNlJyk7XG52YXIga1N0cmVhbSA9IFN5bWJvbCgnc3RyZWFtJyk7XG5mdW5jdGlvbiBjcmVhdGVJdGVyUmVzdWx0KHZhbHVlLCBkb25lKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRvbmU6IGRvbmVcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlYWRBbmRSZXNvbHZlKGl0ZXIpIHtcbiAgdmFyIHJlc29sdmUgPSBpdGVyW2tMYXN0UmVzb2x2ZV07XG4gIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgdmFyIGRhdGEgPSBpdGVyW2tTdHJlYW1dLnJlYWQoKTtcbiAgICAvLyB3ZSBkZWZlciBpZiBkYXRhIGlzIG51bGxcbiAgICAvLyB3ZSBjYW4gYmUgZXhwZWN0aW5nIGVpdGhlciAnZW5kJyBvclxuICAgIC8vICdlcnJvcidcbiAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgaXRlcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG9uUmVhZGFibGUoaXRlcikge1xuICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCB0aWNrLCBiZWNhdXNlIGl0IG1pZ2h0XG4gIC8vIGVtaXQgYW4gZXJyb3Igd2l0aCBwcm9jZXNzLm5leHRUaWNrXG4gIHByb2Nlc3MubmV4dFRpY2socmVhZEFuZFJlc29sdmUsIGl0ZXIpO1xufVxuZnVuY3Rpb24gd3JhcEZvck5leHQobGFzdFByb21pc2UsIGl0ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsYXN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpdGVyW2tFbmRlZF0pIHtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpdGVyW2tIYW5kbGVQcm9taXNlXShyZXNvbHZlLCByZWplY3QpO1xuICAgIH0sIHJlamVjdCk7XG4gIH07XG59XG52YXIgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbiAoKSB7fSk7XG52YXIgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKChfT2JqZWN0JHNldFByb3RvdHlwZU8gPSB7XG4gIGdldCBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXNba1N0cmVhbV07XG4gIH0sXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAvLyBpZiB3ZSBoYXZlIGRldGVjdGVkIGFuIGVycm9yIGluIHRoZSBtZWFud2hpbGVcbiAgICAvLyByZWplY3Qgc3RyYWlnaHQgYXdheVxuICAgIHZhciBlcnJvciA9IHRoaXNba0Vycm9yXTtcbiAgICBpZiAoZXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIGlmICh0aGlzW2tFbmRlZF0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG4gICAgaWYgKHRoaXNba1N0cmVhbV0uZGVzdHJveWVkKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGRlZmVyIHZpYSBuZXh0VGljayBiZWNhdXNlIGlmIC5kZXN0cm95KGVycikgaXNcbiAgICAgIC8vIGNhbGxlZCwgdGhlIGVycm9yIHdpbGwgYmUgZW1pdHRlZCB2aWEgbmV4dFRpY2ssIGFuZFxuICAgICAgLy8gd2UgY2Fubm90IGd1YXJhbnRlZSB0aGF0IHRoZXJlIGlzIG5vIGVycm9yIGxpbmdlcmluZyBhcm91bmRcbiAgICAgIC8vIHdhaXRpbmcgdG8gYmUgZW1pdHRlZC5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpc1trRXJyb3JdKSB7XG4gICAgICAgICAgICByZWplY3QoX3RoaXNba0Vycm9yXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBtdWx0aXBsZSBuZXh0KCkgY2FsbHNcbiAgICAvLyB3ZSB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBQcm9taXNlIHRvIGZpbmlzaFxuICAgIC8vIHRoaXMgbG9naWMgaXMgb3B0aW1pemVkIHRvIHN1cHBvcnQgZm9yIGF3YWl0IGxvb3BzLFxuICAgIC8vIHdoZXJlIG5leHQoKSBpcyBvbmx5IGNhbGxlZCBvbmNlIGF0IGEgdGltZVxuICAgIHZhciBsYXN0UHJvbWlzZSA9IHRoaXNba0xhc3RQcm9taXNlXTtcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBpZiAobGFzdFByb21pc2UpIHtcbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmYXN0IHBhdGggbmVlZGVkIHRvIHN1cHBvcnQgbXVsdGlwbGUgdGhpcy5wdXNoKClcbiAgICAgIC8vIHdpdGhvdXQgdHJpZ2dlcmluZyB0aGUgbmV4dCgpIHF1ZXVlXG4gICAgICB2YXIgZGF0YSA9IHRoaXNba1N0cmVhbV0ucmVhZCgpO1xuICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9XG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2UodGhpc1trSGFuZGxlUHJvbWlzZV0pO1xuICAgIH1cbiAgICB0aGlzW2tMYXN0UHJvbWlzZV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBcInJldHVyblwiLCBmdW5jdGlvbiBfcmV0dXJuKCkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcbiAgLy8gZGVzdHJveShlcnIsIGNiKSBpcyBhIHByaXZhdGUgQVBJXG4gIC8vIHdlIGNhbiBndWFyYW50ZWUgd2UgaGF2ZSB0aGF0IGhlcmUsIGJlY2F1c2Ugd2UgY29udHJvbCB0aGVcbiAgLy8gUmVhZGFibGUgY2xhc3MgdGhpcyBpcyBhdHRhY2hlZCB0b1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIF90aGlzMltrU3RyZWFtXS5kZXN0cm95KG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9KTtcbiAgfSk7XG59KSwgX09iamVjdCRzZXRQcm90b3R5cGVPKSwgQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gZnVuY3Rpb24gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHN0cmVhbSkge1xuICB2YXIgX09iamVjdCRjcmVhdGU7XG4gIHZhciBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCAoX09iamVjdCRjcmVhdGUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrU3RyZWFtLCB7XG4gICAgdmFsdWU6IHN0cmVhbSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlc29sdmUsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlamVjdCwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFcnJvciwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFbmRlZCwge1xuICAgIHZhbHVlOiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrSGFuZGxlUHJvbWlzZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBkYXRhID0gaXRlcmF0b3Jba1N0cmVhbV0ucmVhZCgpO1xuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSByZXNvbHZlO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSByZWplY3Q7XG4gICAgICB9XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX09iamVjdCRjcmVhdGUpKTtcbiAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gIGZpbmlzaGVkKHN0cmVhbSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScpIHtcbiAgICAgIHZhciByZWplY3QgPSBpdGVyYXRvcltrTGFzdFJlamVjdF07XG4gICAgICAvLyByZWplY3QgaWYgd2UgYXJlIHdhaXRpbmcgZm9yIGRhdGEgaW4gdGhlIFByb21pc2VcbiAgICAgIC8vIHJldHVybmVkIGJ5IG5leHQoKSBhbmQgc3RvcmUgdGhlIGVycm9yXG4gICAgICBpZiAocmVqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICBpdGVyYXRvcltrRXJyb3JdID0gZXJyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmVzb2x2ZSA9IGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV07XG4gICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cbiAgICBpdGVyYXRvcltrRW5kZWRdID0gdHJ1ZTtcbiAgfSk7XG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBvblJlYWRhYmxlLmJpbmQobnVsbCwgaXRlcmF0b3IpKTtcbiAgcmV0dXJuIGl0ZXJhdG9yO1xufTtcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yOyIsICIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG52YXIgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRTtcbmZ1bmN0aW9uIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKSB7XG4gIHZhciBpdGVyYXRvcjtcbiAgaWYgKGl0ZXJhYmxlICYmIHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiAgfSBlbHNlIGlmIChpdGVyYWJsZSAmJiBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIGl0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7ZWxzZSBpZiAoaXRlcmFibGUgJiYgaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSkgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKCk7ZWxzZSB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2l0ZXJhYmxlJywgWydJdGVyYWJsZSddLCBpdGVyYWJsZSk7XG4gIHZhciByZWFkYWJsZSA9IG5ldyBSZWFkYWJsZShfb2JqZWN0U3ByZWFkKHtcbiAgICBvYmplY3RNb2RlOiB0cnVlXG4gIH0sIG9wdHMpKTtcbiAgLy8gUmVhZGluZyBib29sZWFuIHRvIHByb3RlY3QgYWdhaW5zdCBfcmVhZFxuICAvLyBiZWluZyBjYWxsZWQgYmVmb3JlIGxhc3QgaXRlcmF0aW9uIGNvbXBsZXRpb24uXG4gIHZhciByZWFkaW5nID0gZmFsc2U7XG4gIHJlYWRhYmxlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcmVhZGluZykge1xuICAgICAgcmVhZGluZyA9IHRydWU7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHJldHVybiBfbmV4dDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBmdW5jdGlvbiBfbmV4dDIoKSB7XG4gICAgX25leHQyID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfeWllbGQkaXRlcmF0b3IkbmV4dCA9IHlpZWxkIGl0ZXJhdG9yLm5leHQoKSxcbiAgICAgICAgICB2YWx1ZSA9IF95aWVsZCRpdGVyYXRvciRuZXh0LnZhbHVlLFxuICAgICAgICAgIGRvbmUgPSBfeWllbGQkaXRlcmF0b3IkbmV4dC5kb25lO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIHJlYWRhYmxlLnB1c2gobnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVhZGFibGUucHVzaCh5aWVsZCB2YWx1ZSkpIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVhZGFibGUuZGVzdHJveShlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfbmV4dDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICByZXR1cm4gcmVhZGFibGU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZyb207XG4iLCAiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gRUVsaXN0ZW5lckNvdW50KGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWc7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRiA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YsXG4gIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gIEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UO1xuXG4vLyBMYXp5IGxvYWRlZCB0byBpbXByb3ZlIHRoZSBzdGFydHVwIHBlcmZvcm1hbmNlLlxudmFyIFN0cmluZ0RlY29kZXI7XG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yO1xudmFyIGZyb207XG5yZXF1aXJlKCdpbmhlcml0cycpKFJlYWRhYmxlLCBTdHJlYW0pO1xudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHRoaXMucGF1c2VkID0gdHJ1ZTtcblxuICAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTtcblxuICAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2VuZCcgKGFuZCBwb3RlbnRpYWxseSAnZmluaXNoJylcbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgUmVhZGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICBkZWJ1ZygncmVhZGFibGVBZGRDaHVuaycsIGNodW5rKTtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCgpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRigpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdlIGNhbiBwdXNoIG1vcmUgZGF0YSBpZiB3ZSBhcmUgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmsuXG4gIC8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lIG1vcmUgYnl0ZXMuXG4gIC8vIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsIHN1Y2ggYXMgdGhlIHJlcGwuXG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlcicsICdVaW50OEFycmF5J10sIGNodW5rKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHZhciBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gZGVjb2RlcjtcbiAgLy8gSWYgc2V0RW5jb2RpbmcobnVsbCksIGRlY29kZXIuZW5jb2RpbmcgZXF1YWxzIHV0ZjhcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2Rlci5lbmNvZGluZztcblxuICAvLyBJdGVyYXRlIG92ZXIgY3VycmVudCBidWZmZXIgdG8gY29udmVydCBhbHJlYWR5IHN0b3JlZCBCdWZmZXJzOlxuICB2YXIgcCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmhlYWQ7XG4gIHZhciBjb250ZW50ID0gJyc7XG4gIHdoaWxlIChwICE9PSBudWxsKSB7XG4gICAgY29udGVudCArPSBkZWNvZGVyLndyaXRlKHAuZGF0YSk7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICBpZiAoY29udGVudCAhPT0gJycpIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLnB1c2goY29udGVudCk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDFHQlxudmFyIE1BWF9IV00gPSAweDQwMDAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgLy8gVE9ETyhyb25hZyk6IFRocm93IEVSUl9WQUxVRV9PVVRfT0ZfUkFOR0UuXG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoKHN0YXRlLmhpZ2hXYXRlck1hcmsgIT09IDAgPyBzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayA6IHN0YXRlLmxlbmd0aCA+IDApIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgfVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuICByZXR1cm4gcmV0O1xufTtcbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1Zygnb25Fb2ZDaHVuaycpO1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBpZiAoc3RhdGUuc3luYykge1xuICAgIC8vIGlmIHdlIGFyZSBzeW5jLCB3YWl0IHVudGlsIG5leHQgdGljayB0byBlbWl0IHRoZSBkYXRhLlxuICAgIC8vIE90aGVyd2lzZSB3ZSByaXNrIGVtaXR0aW5nIGRhdGEgaW4gdGhlIGZsb3coKVxuICAgIC8vIHRoZSByZWFkYWJsZSBjb2RlIHRyaWdnZXJzIGR1cmluZyBhIHJlYWQoKSBjYWxsXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgfVxuICB9XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLm5lZWRSZWFkYWJsZSwgc3RhdGUuZW1pdHRlZFJlYWRhYmxlKTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGVfJywgc3RhdGUuZGVzdHJveWVkLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgaWYgKCFzdGF0ZS5kZXN0cm95ZWQgJiYgKHN0YXRlLmxlbmd0aCB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIFRoZSBzdHJlYW0gbmVlZHMgYW5vdGhlciByZWFkYWJsZSBldmVudCBpZlxuICAvLyAxLiBJdCBpcyBub3QgZmxvd2luZywgYXMgdGhlIGZsb3cgbWVjaGFuaXNtIHdpbGwgdGFrZVxuICAvLyAgICBjYXJlIG9mIGl0LlxuICAvLyAyLiBJdCBpcyBub3QgZW5kZWQuXG4gIC8vIDMuIEl0IGlzIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLCBzbyB3ZSBjYW4gc2NoZWR1bGVcbiAgLy8gICAgYW5vdGhlciByZWFkYWJsZSBsYXRlci5cbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gQXR0ZW1wdCB0byByZWFkIG1vcmUgZGF0YSBpZiB3ZSBzaG91bGQuXG4gIC8vXG4gIC8vIFRoZSBjb25kaXRpb25zIGZvciByZWFkaW5nIG1vcmUgZGF0YSBhcmUgKG9uZSBvZik6XG4gIC8vIC0gTm90IGVub3VnaCBkYXRhIGJ1ZmZlcmVkIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKS4gVGhlIGxvb3BcbiAgLy8gICBpcyByZXNwb25zaWJsZSBmb3IgZmlsbGluZyB0aGUgYnVmZmVyIHdpdGggZW5vdWdoIGRhdGEgaWYgc3VjaCBkYXRhXG4gIC8vICAgaXMgYXZhaWxhYmxlLiBJZiBoaWdoV2F0ZXJNYXJrIGlzIDAgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGZsb3dpbmcgbW9kZVxuICAvLyAgIHdlIHNob3VsZCBfbm90XyBhdHRlbXB0IHRvIGJ1ZmZlciBhbnkgZXh0cmEgZGF0YS4gV2UnbGwgZ2V0IG1vcmUgZGF0YVxuICAvLyAgIHdoZW4gdGhlIHN0cmVhbSBjb25zdW1lciBjYWxscyByZWFkKCkgaW5zdGVhZC5cbiAgLy8gLSBObyBkYXRhIGluIHRoZSBidWZmZXIsIGFuZCB0aGUgc3RyZWFtIGlzIGluIGZsb3dpbmcgbW9kZS4gSW4gdGhpcyBtb2RlXG4gIC8vICAgdGhlIGxvb3AgYmVsb3cgaXMgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHJlYWQoKSBpcyBjYWxsZWQuIEZhaWxpbmcgdG9cbiAgLy8gICBjYWxsIHJlYWQgaGVyZSB3b3VsZCBhYm9ydCB0aGUgZmxvdyBhbmQgdGhlcmUncyBubyBvdGhlciBtZWNoYW5pc20gZm9yXG4gIC8vICAgY29udGludWluZyB0aGUgZmxvdyBpZiB0aGUgc3RyZWFtIGNvbnN1bWVyIGhhcyBqdXN0IHN1YnNjcmliZWQgdG8gdGhlXG4gIC8vICAgJ2RhdGEnIGV2ZW50LlxuICAvL1xuICAvLyBJbiBhZGRpdGlvbiB0byB0aGUgYWJvdmUgY29uZGl0aW9ucyB0byBrZWVwIHJlYWRpbmcgZGF0YSwgdGhlIGZvbGxvd2luZ1xuICAvLyBjb25kaXRpb25zIHByZXZlbnQgdGhlIGRhdGEgZnJvbSBiZWluZyByZWFkOlxuICAvLyAtIFRoZSBzdHJlYW0gaGFzIGVuZGVkIChzdGF0ZS5lbmRlZCkuXG4gIC8vIC0gVGhlcmUgaXMgYWxyZWFkeSBhIHBlbmRpbmcgJ3JlYWQnIG9wZXJhdGlvbiAoc3RhdGUucmVhZGluZykuIFRoaXMgaXMgYVxuICAvLyAgIGNhc2Ugd2hlcmUgdGhlIHRoZSBzdHJlYW0gaGFzIGNhbGxlZCB0aGUgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBfcmVhZCgpXG4gIC8vICAgbWV0aG9kLCBidXQgdGhleSBhcmUgcHJvY2Vzc2luZyB0aGUgY2FsbCBhc3luY2hyb25vdXNseSBhbmQgaGF2ZSBfbm90X1xuICAvLyAgIGNhbGxlZCBwdXNoKCkgd2l0aCBuZXcgZGF0YS4gSW4gdGhpcyBjYXNlIHdlIHNraXAgcGVyZm9ybWluZyBtb3JlXG4gIC8vICAgcmVhZCgpcy4gVGhlIGV4ZWN1dGlvbiBlbmRzIGluIHRoaXMgbWV0aG9kIGFnYWluIGFmdGVyIHRoZSBfcmVhZCgpIGVuZHNcbiAgLy8gICB1cCBjYWxsaW5nIHB1c2goKSB3aXRoIG1vcmUgZGF0YS5cbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkpIHtcbiAgICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3JlYWQoKScpKTtcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBkZWJ1ZygnZGVzdC53cml0ZScsIHJldCk7XG4gICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBlcnJvck9yRGVzdHJveShkZXN0LCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59O1xuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHtcbiAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywge1xuICAgICAgaGFzVW5waXBlZDogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gdXBkYXRlIHJlYWRhYmxlTGlzdGVuaW5nIHNvIHRoYXQgcmVzdW1lKCkgbWF5IGJlIGEgbm8tb3BcbiAgICAvLyBhIGZldyBsaW5lcyBkb3duLiBUaGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJykuXG4gICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0aGlzLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwO1xuXG4gICAgLy8gVHJ5IHN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmIChzdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgZGVidWcoJ29uIHJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5yZWFkaW5nKTtcbiAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIuY2FsbCh0aGlzLCBldiwgZm4pO1xuICBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2KSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgfHwgZXYgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmZ1bmN0aW9uIHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nKHNlbGYpIHtcbiAgdmFyIHN0YXRlID0gc2VsZi5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzZWxmLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwO1xuICBpZiAoc3RhdGUucmVzdW1lU2NoZWR1bGVkICYmICFzdGF0ZS5wYXVzZWQpIHtcbiAgICAvLyBmbG93aW5nIG5lZWRzIHRvIGJlIHNldCB0byB0cnVlIG5vdywgb3RoZXJ3aXNlXG4gICAgLy8gdGhlIHVwY29taW5nIHJlc3VtZSB3aWxsIG5vdCBmbG93LlxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuXG4gICAgLy8gY3J1ZGUgd2F5IHRvIGNoZWNrIGlmIHdlIHNob3VsZCByZXN1bWVcbiAgfSBlbHNlIGlmIChzZWxmLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApIHtcbiAgICBzZWxmLnJlc3VtZSgpO1xuICB9XG59XG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICAvLyB3ZSBmbG93IG9ubHkgaWYgdGhlcmUgaXMgbm8gb25lIGxpc3RlbmluZ1xuICAgIC8vIGZvciByZWFkYWJsZSwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gY2FsbFxuICAgIC8vIHJlc3VtZSgpXG4gICAgc3RhdGUuZmxvd2luZyA9ICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZztcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdyZXN1bWUnLCBzdGF0ZS5yZWFkaW5nKTtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnBhdXNlZCA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCk7XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiBtZXRob2RXcmFwKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWV0aG9kV3JhcFJldHVybkZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdGhpcztcbn07XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yJyk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcyk7XG4gIH07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlRmxvd2luZycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gc3RhdGU7XG4gICAgfVxuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmZpcnN0KCk7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBzdGF0ZS5idWZmZXIuY29uc3VtZShuLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlJywgc3RhdGUuZW5kRW1pdHRlZCk7XG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlTlQnLCBzdGF0ZS5lbmRFbWl0dGVkLCBzdGF0ZS5sZW5ndGgpO1xuXG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgLy8gaWYgdGhlIHdyaXRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gICAgICBpZiAoIXdTdGF0ZSB8fCB3U3RhdGUuYXV0b0Rlc3Ryb3kgJiYgd1N0YXRlLmZpbmlzaGVkKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5mcm9tID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBvcHRzKSB7XG4gICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJvbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9mcm9tJyk7XG4gICAgfVxuICAgIHJldHVybiBmcm9tKFJlYWRhYmxlLCBpdGVyYWJsZSwgb3B0cyk7XG4gIH07XG59XG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwgIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5yZXF1aXJlKCdpbmhlcml0cycpKER1cGxleCwgUmVhZGFibGUpO1xue1xuICAvLyBBbGxvdyB0aGUga2V5cyBhcnJheSB0byBiZSBHQydlZC5cbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgIH1cbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gSWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzcy5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTsiLCAiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxcbiAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsXG4gIEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQsXG4gIEVSUl9VTktOT1dOX0VOQ09ESU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1VOS05PV05fRU5DT0RJTkc7XG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnJlcXVpcmUoJ2luaGVyaXRzJykoV3JpdGFibGUsIFN0cmVhbSk7XG5mdW5jdGlvbiBub3AoKSB7fVxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLFxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlO1xuXG4gIC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZmluaXNoJyAoYW5kIHBvdGVudGlhbGx5ICdlbmQnKVxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95O1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgV3JpdGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgaWYgKCFpc0R1cGxleCAmJiAhcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpKSByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTtcbn07XG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKCk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciBlcjtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInXSwgY2h1bmspO1xuICB9XG4gIGlmIChlcikge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG4gIGlmIChzdGF0ZS5lbmRpbmcpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrKztcbn07XG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgRVJSX1VOS05PV05fRU5DT0RJTkcoZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHN0YXRlLm9ud3JpdGUobmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCd3cml0ZScpKTtlbHNlIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpO1xuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDtcbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfd3JpdGUoKScpKTtcbn07XG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xuICByZXR1cm4gdGhpcztcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7XG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgICAgLy8gaWYgdGhlIHJlYWRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgICAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgICAgICAgaWYgKCFyU3RhdGUgfHwgclN0YXRlLmF1dG9EZXN0cm95ICYmIHJTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3MubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cblxuICAvLyByZXVzZSB0aGUgZnJlZSBjb3JrUmVxLlxuICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsiLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmNvbnN0IHsgTEVWRUwgfSA9IHJlcXVpcmUoJ3RyaXBsZS1iZWFtJyk7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBUcmFuc3BvcnRTdHJlYW0uIFRoaXMgaXMgdGhlIGJhc2UgcHJvdG90eXBlXG4gKiB0aGF0IGFsbCBgd2luc3RvbiA+PSAzYCB0cmFuc3BvcnRzIHNob3VsZCBpbmhlcml0IGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoaXMgVHJhbnNwb3J0U3RyZWFtIGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5sZXZlbCAtIEhpZ2hlc3QgbGV2ZWwgYWNjb3JkaW5nIHRvIFJGQzU0MjQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuaGFuZGxlRXhjZXB0aW9ucyAtIElmIHRydWUsIGluZm8gd2l0aFxuICogeyBleGNlcHRpb246IHRydWUgfSB3aWxsIGJlIHdyaXR0ZW4uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmxvZyAtIEN1c3RvbSBsb2cgZnVuY3Rpb24gZm9yIHNpbXBsZSBUcmFuc3BvcnRcbiAqIGNyZWF0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLmNsb3NlIC0gQ2FsbGVkIG9uIFwidW5waXBlXCIgZnJvbSBwYXJlbnQuXG4gKi9cbmNvbnN0IFRyYW5zcG9ydFN0cmVhbSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gVHJhbnNwb3J0U3RyZWFtKG9wdGlvbnMgPSB7fSkge1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIHsgb2JqZWN0TW9kZTogdHJ1ZSwgaGlnaFdhdGVyTWFyazogb3B0aW9ucy5oaWdoV2F0ZXJNYXJrIH0pO1xuXG4gIHRoaXMuZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQ7XG4gIHRoaXMubGV2ZWwgPSBvcHRpb25zLmxldmVsO1xuICB0aGlzLmhhbmRsZUV4Y2VwdGlvbnMgPSBvcHRpb25zLmhhbmRsZUV4Y2VwdGlvbnM7XG4gIHRoaXMuaGFuZGxlUmVqZWN0aW9ucyA9IG9wdGlvbnMuaGFuZGxlUmVqZWN0aW9ucztcbiAgdGhpcy5zaWxlbnQgPSBvcHRpb25zLnNpbGVudDtcblxuICBpZiAob3B0aW9ucy5sb2cpIHRoaXMubG9nID0gb3B0aW9ucy5sb2c7XG4gIGlmIChvcHRpb25zLmxvZ3YpIHRoaXMubG9ndiA9IG9wdGlvbnMubG9ndjtcbiAgaWYgKG9wdGlvbnMuY2xvc2UpIHRoaXMuY2xvc2UgPSBvcHRpb25zLmNsb3NlO1xuXG4gIC8vIEdldCB0aGUgbGV2ZWxzIGZyb20gdGhlIHNvdXJjZSB3ZSBhcmUgcGlwZWQgZnJvbS5cbiAgdGhpcy5vbmNlKCdwaXBlJywgbG9nZ2VyID0+IHtcbiAgICAvLyBSZW1hcmsgKGluZGV4emVybyk6IHRoaXMgYm9va2tlZXBpbmcgY2FuIG9ubHkgc3VwcG9ydCBtdWx0aXBsZVxuICAgIC8vIExvZ2dlciBwYXJlbnRzIHdpdGggdGhlIHNhbWUgYGxldmVsc2AuIFRoaXMgY29tZXMgaW50byBwbGF5IGluXG4gICAgLy8gdGhlIGB3aW5zdG9uLkNvbnRhaW5lcmAgY29kZSBpbiB3aGljaCBgY29udGFpbmVyLmFkZGAgdGFrZXNcbiAgICAvLyBhIGZ1bGx5IHJlYWxpemVkIHNldCBvZiBvcHRpb25zIHdpdGggcHJlLWNvbnN0cnVjdGVkIFRyYW5zcG9ydFN0cmVhbXMuXG4gICAgdGhpcy5sZXZlbHMgPSBsb2dnZXIubGV2ZWxzO1xuICAgIHRoaXMucGFyZW50ID0gbG9nZ2VyO1xuICB9KTtcblxuICAvLyBJZiBhbmQvb3Igd2hlbiB0aGUgdHJhbnNwb3J0IGlzIHJlbW92ZWQgZnJvbSB0aGlzIGluc3RhbmNlXG4gIHRoaXMub25jZSgndW5waXBlJywgc3JjID0+IHtcbiAgICAvLyBSZW1hcmsgKGluZGV4emVybyk6IHRoaXMgYm9va2tlZXBpbmcgY2FuIG9ubHkgc3VwcG9ydCBtdWx0aXBsZVxuICAgIC8vIExvZ2dlciBwYXJlbnRzIHdpdGggdGhlIHNhbWUgYGxldmVsc2AuIFRoaXMgY29tZXMgaW50byBwbGF5IGluXG4gICAgLy8gdGhlIGB3aW5zdG9uLkNvbnRhaW5lcmAgY29kZSBpbiB3aGljaCBgY29udGFpbmVyLmFkZGAgdGFrZXNcbiAgICAvLyBhIGZ1bGx5IHJlYWxpemVkIHNldCBvZiBvcHRpb25zIHdpdGggcHJlLWNvbnN0cnVjdGVkIFRyYW5zcG9ydFN0cmVhbXMuXG4gICAgaWYgKHNyYyA9PT0gdGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmNsb3NlKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLypcbiAqIEluaGVyaXQgZnJvbSBXcml0ZWFibGUgdXNpbmcgTm9kZS5qcyBidWlsdC1pbnNcbiAqL1xudXRpbC5pbmhlcml0cyhUcmFuc3BvcnRTdHJlYW0sIFdyaXRhYmxlKTtcblxuLyoqXG4gKiBXcml0ZXMgdGhlIGluZm8gb2JqZWN0IHRvIG91ciB0cmFuc3BvcnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge21peGVkfSBpbmZvIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICogQHBhcmFtIHttaXhlZH0gZW5jIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHByaXZhdGVcbiAqL1xuVHJhbnNwb3J0U3RyZWFtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiBfd3JpdGUoaW5mbywgZW5jLCBjYWxsYmFjaykge1xuICBpZiAodGhpcy5zaWxlbnQgfHwgKGluZm8uZXhjZXB0aW9uID09PSB0cnVlICYmICF0aGlzLmhhbmRsZUV4Y2VwdGlvbnMpKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICB9XG5cbiAgLy8gUmVtYXJrOiBUaGlzIGhhcyB0byBiZSBoYW5kbGVkIGluIHRoZSBiYXNlIHRyYW5zcG9ydCBub3cgYmVjYXVzZSB3ZVxuICAvLyBjYW5ub3QgY29uZGl0aW9uYWxseSB3cml0ZSB0byBvdXIgcGlwZSB0YXJnZXRzIGFzIHN0cmVhbS4gV2UgYWx3YXlzXG4gIC8vIHByZWZlciBhbnkgZXhwbGljaXQgbGV2ZWwgc2V0IG9uIHRoZSBUcmFuc3BvcnQgaXRzZWxmIGZhbGxpbmcgYmFjayB0b1xuICAvLyBhbnkgbGV2ZWwgc2V0IG9uIHRoZSBwYXJlbnQuXG4gIGNvbnN0IGxldmVsID0gdGhpcy5sZXZlbCB8fCAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQubGV2ZWwpO1xuXG4gIGlmICghbGV2ZWwgfHwgdGhpcy5sZXZlbHNbbGV2ZWxdID49IHRoaXMubGV2ZWxzW2luZm9bTEVWRUxdXSkge1xuICAgIGlmIChpbmZvICYmICF0aGlzLmZvcm1hdCkge1xuICAgICAgcmV0dXJuIHRoaXMubG9nKGluZm8sIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBsZXQgZXJyU3RhdGU7XG4gICAgbGV0IHRyYW5zZm9ybWVkO1xuXG4gICAgLy8gV2UgdHJhcChhbmQgcmUtdGhyb3cpIGFueSBlcnJvcnMgZ2VuZXJhdGVkIGJ5IHRoZSB1c2VyLXByb3ZpZGVkIGZvcm1hdCwgYnV0IGFsc29cbiAgICAvLyBndWFyYW50ZWUgdGhhdCB0aGUgc3RyZWFtcyBjYWxsYmFjayBpcyBpbnZva2VkIHNvIHRoYXQgd2UgY2FuIGNvbnRpbnVlIGZsb3dpbmcuXG4gICAgdHJ5IHtcbiAgICAgIHRyYW5zZm9ybWVkID0gdGhpcy5mb3JtYXQudHJhbnNmb3JtKE9iamVjdC5hc3NpZ24oe30sIGluZm8pLCB0aGlzLmZvcm1hdC5vcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVyclN0YXRlID0gZXJyO1xuICAgIH1cblxuICAgIGlmIChlcnJTdGF0ZSB8fCAhdHJhbnNmb3JtZWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYWxsYmFjay1yZXR1cm5cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICBpZiAoZXJyU3RhdGUpIHRocm93IGVyclN0YXRlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxvZyh0cmFuc2Zvcm1lZCwgY2FsbGJhY2spO1xuICB9XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyB0aGUgYmF0Y2ggb2YgaW5mbyBvYmplY3RzIChpLmUuIFwib2JqZWN0IGNodW5rc1wiKSB0byBvdXIgdHJhbnNwb3J0XG4gKiBpbnN0YW5jZSBhZnRlciBwZXJmb3JtaW5nIGFueSBuZWNlc3NhcnkgZmlsdGVyaW5nLlxuICogQHBhcmFtIHttaXhlZH0gY2h1bmtzIC0gVE9ETzogYWRkIHBhcmFtcyBkZXNjcmlwdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVE9ETzogYWRkIHBhcmFtcyBkZXNjcmlwdGlvbi5cbiAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJucyBkZXNjcmlwdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cblRyYW5zcG9ydFN0cmVhbS5wcm90b3R5cGUuX3dyaXRldiA9IGZ1bmN0aW9uIF93cml0ZXYoY2h1bmtzLCBjYWxsYmFjaykge1xuICBpZiAodGhpcy5sb2d2KSB7XG4gICAgY29uc3QgaW5mb3MgPSBjaHVua3MuZmlsdGVyKHRoaXMuX2FjY2VwdCwgdGhpcyk7XG4gICAgaWYgKCFpbmZvcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG5cbiAgICAvLyBSZW1hcmsgKGluZGV4emVybyk6IGZyb20gYSBwZXJmb3JtYW5jZSBwZXJzcGVjdGl2ZSBpZiBUcmFuc3BvcnRcbiAgICAvLyBpbXBsZW1lbnRlcnMgZG8gY2hvb3NlIHRvIGltcGxlbWVudCBsb2d2IHNob3VsZCB3ZSBtYWtlIGl0IHRoZWlyXG4gICAgLy8gcmVzcG9uc2liaWxpdHkgdG8gaW52b2tlIHRoZWlyIGZvcm1hdD9cbiAgICByZXR1cm4gdGhpcy5sb2d2KGluZm9zLCBjYWxsYmFjayk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghdGhpcy5fYWNjZXB0KGNodW5rc1tpXSkpIGNvbnRpbnVlO1xuXG4gICAgaWYgKGNodW5rc1tpXS5jaHVuayAmJiAhdGhpcy5mb3JtYXQpIHtcbiAgICAgIHRoaXMubG9nKGNodW5rc1tpXS5jaHVuaywgY2h1bmtzW2ldLmNhbGxiYWNrKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBlcnJTdGF0ZTtcbiAgICBsZXQgdHJhbnNmb3JtZWQ7XG5cbiAgICAvLyBXZSB0cmFwKGFuZCByZS10aHJvdykgYW55IGVycm9ycyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXItcHJvdmlkZWQgZm9ybWF0LCBidXQgYWxzb1xuICAgIC8vIGd1YXJhbnRlZSB0aGF0IHRoZSBzdHJlYW1zIGNhbGxiYWNrIGlzIGludm9rZWQgc28gdGhhdCB3ZSBjYW4gY29udGludWUgZmxvd2luZy5cbiAgICB0cnkge1xuICAgICAgdHJhbnNmb3JtZWQgPSB0aGlzLmZvcm1hdC50cmFuc2Zvcm0oXG4gICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGNodW5rc1tpXS5jaHVuayksXG4gICAgICAgIHRoaXMuZm9ybWF0Lm9wdGlvbnNcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnJTdGF0ZSA9IGVycjtcbiAgICB9XG5cbiAgICBpZiAoZXJyU3RhdGUgfHwgIXRyYW5zZm9ybWVkKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgICBjaHVua3NbaV0uY2FsbGJhY2soKTtcbiAgICAgIGlmIChlcnJTdGF0ZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB0aHJvdyBlcnJTdGF0ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2codHJhbnNmb3JtZWQsIGNodW5rc1tpXS5jYWxsYmFjayk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xufTtcblxuLyoqXG4gKiBQcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNmaWVkIGBpbmZvYCBvbiB0aGVcbiAqIFdyaXRlUmVxLCBgd3JpdGVgLCBzaG91bGQgYmUgcGFzc2VkIGRvd24gaW50byB0aGUgZGVyaXZlZFxuICogVHJhbnNwb3J0U3RyZWFtJ3MgSS9PIHZpYSBgLmxvZyhpbmZvLCBjYWxsYmFjaylgLlxuICogQHBhcmFtIHtXcml0ZVJlcX0gd3JpdGUgLSB3aW5zdG9uQDMgTm9kZS5qcyBXcml0ZVJlcSBmb3IgdGhlIGBpbmZvYCBvYmplY3RcbiAqIHJlcHJlc2VudGluZyB0aGUgbG9nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBWYWx1ZSBpbmRpY2F0aW5nIGlmIHRoZSBgd3JpdGVgIHNob3VsZCBiZSBhY2NlcHRlZCAmXG4gKiBsb2dnZWQuXG4gKi9cblRyYW5zcG9ydFN0cmVhbS5wcm90b3R5cGUuX2FjY2VwdCA9IGZ1bmN0aW9uIF9hY2NlcHQod3JpdGUpIHtcbiAgY29uc3QgaW5mbyA9IHdyaXRlLmNodW5rO1xuICBpZiAodGhpcy5zaWxlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBXZSBhbHdheXMgcHJlZmVyIGFueSBleHBsaWNpdCBsZXZlbCBzZXQgb24gdGhlIFRyYW5zcG9ydCBpdHNlbGZcbiAgLy8gZmFsbGluZyBiYWNrIHRvIGFueSBsZXZlbCBzZXQgb24gdGhlIHBhcmVudC5cbiAgY29uc3QgbGV2ZWwgPSB0aGlzLmxldmVsIHx8ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5sZXZlbCk7XG5cbiAgLy8gSW1tZWRpYXRlbHkgY2hlY2sgdGhlIGF2ZXJhZ2UgY2FzZTogbG9nIGxldmVsIGZpbHRlcmluZy5cbiAgaWYgKFxuICAgIGluZm8uZXhjZXB0aW9uID09PSB0cnVlIHx8XG4gICAgIWxldmVsIHx8XG4gICAgdGhpcy5sZXZlbHNbbGV2ZWxdID49IHRoaXMubGV2ZWxzW2luZm9bTEVWRUxdXVxuICApIHtcbiAgICAvLyBFbnN1cmUgdGhlIGluZm8gb2JqZWN0IGlzIHZhbGlkIGJhc2VkIG9uIGB7IGV4Y2VwdGlvbiB9YDpcbiAgICAvLyAxLiB7IGhhbmRsZUV4Y2VwdGlvbnM6IHRydWUgfTogYWxsIGBpbmZvYCBvYmplY3RzIGFyZSB2YWxpZFxuICAgIC8vIDIuIHsgZXhjZXB0aW9uOiBmYWxzZSB9OiBhY2NlcHRlZCBieSBhbGwgdHJhbnNwb3J0cy5cbiAgICBpZiAodGhpcy5oYW5kbGVFeGNlcHRpb25zIHx8IGluZm8uZXhjZXB0aW9uICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIF9ub3AgaXMgc2hvcnQgZm9yIFwiTm8gb3BlcmF0aW9uXCJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBJbnRlbnRpb25hbGx5IGZhbHNlLlxuICovXG5UcmFuc3BvcnRTdHJlYW0ucHJvdG90eXBlLl9ub3AgPSBmdW5jdGlvbiBfbm9wKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gIHJldHVybiB2b2lkIHVuZGVmaW5lZDtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgeyBMRVZFTCB9ID0gcmVxdWlyZSgndHJpcGxlLWJlYW0nKTtcbmNvbnN0IFRyYW5zcG9ydFN0cmVhbSA9IHJlcXVpcmUoJy4vbW9kZXJuJyk7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBMZWdhY3lUcmFuc3BvcnRTdHJlYW0uIFRoaXMgaXMgYW4gaW50ZXJuYWxcbiAqIHdyYXBwZXIgYHdpbnN0b24gPj0gM2AgdXNlcyB0byB3cmFwIG9sZGVyIHRyYW5zcG9ydHMgaW1wbGVtZW50aW5nXG4gKiBsb2cobGV2ZWwsIG1lc3NhZ2UsIG1ldGEpLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGlzIFRyYW5zcG9ydFN0cmVhbSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7VHJhbnNwb3R9IG9wdGlvbnMudHJhbnNwb3J0IC0gd2luc3RvbkAyIG9yIG9sZGVyIFRyYW5zcG9ydCB0byB3cmFwLlxuICovXG5cbmNvbnN0IExlZ2FjeVRyYW5zcG9ydFN0cmVhbSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gTGVnYWN5VHJhbnNwb3J0U3RyZWFtKG9wdGlvbnMgPSB7fSkge1xuICBUcmFuc3BvcnRTdHJlYW0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgaWYgKCFvcHRpb25zLnRyYW5zcG9ydCB8fCB0eXBlb2Ygb3B0aW9ucy50cmFuc3BvcnQubG9nICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zcG9ydCwgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCBhIGxvZyBtZXRob2QuJyk7XG4gIH1cblxuICB0aGlzLnRyYW5zcG9ydCA9IG9wdGlvbnMudHJhbnNwb3J0O1xuICB0aGlzLmxldmVsID0gdGhpcy5sZXZlbCB8fCBvcHRpb25zLnRyYW5zcG9ydC5sZXZlbDtcbiAgdGhpcy5oYW5kbGVFeGNlcHRpb25zID0gdGhpcy5oYW5kbGVFeGNlcHRpb25zIHx8IG9wdGlvbnMudHJhbnNwb3J0LmhhbmRsZUV4Y2VwdGlvbnM7XG5cbiAgLy8gRGlzcGxheSBvdXIgZGVwcmVjYXRpb24gbm90aWNlLlxuICB0aGlzLl9kZXByZWNhdGVkKCk7XG5cbiAgLy8gUHJvcGVybHkgYnViYmxlIHVwIGVycm9ycyBmcm9tIHRoZSB0cmFuc3BvcnQgdG8gdGhlXG4gIC8vIExlZ2FjeVRyYW5zcG9ydFN0cmVhbSBpbnN0YW5jZSwgYnV0IG9ubHkgb25jZSBubyBtYXR0ZXIgaG93IG1hbnkgdGltZXNcbiAgLy8gdGhpcyB0cmFuc3BvcnQgaXMgc2hhcmVkLlxuICBmdW5jdGlvbiB0cmFuc3BvcnRFcnJvcihlcnIpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyLCB0aGlzLnRyYW5zcG9ydCk7XG4gIH1cblxuICBpZiAoIXRoaXMudHJhbnNwb3J0Ll9fd2luc3RvbkVycm9yKSB7XG4gICAgdGhpcy50cmFuc3BvcnQuX193aW5zdG9uRXJyb3IgPSB0cmFuc3BvcnRFcnJvci5iaW5kKHRoaXMpO1xuICAgIHRoaXMudHJhbnNwb3J0Lm9uKCdlcnJvcicsIHRoaXMudHJhbnNwb3J0Ll9fd2luc3RvbkVycm9yKTtcbiAgfVxufTtcblxuLypcbiAqIEluaGVyaXQgZnJvbSBUcmFuc3BvcnRTdHJlYW0gdXNpbmcgTm9kZS5qcyBidWlsdC1pbnNcbiAqL1xudXRpbC5pbmhlcml0cyhMZWdhY3lUcmFuc3BvcnRTdHJlYW0sIFRyYW5zcG9ydFN0cmVhbSk7XG5cbi8qKlxuICogV3JpdGVzIHRoZSBpbmZvIG9iamVjdCB0byBvdXIgdHJhbnNwb3J0IGluc3RhbmNlLlxuICogQHBhcmFtIHttaXhlZH0gaW5mbyAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAqIEBwYXJhbSB7bWl4ZWR9IGVuYyAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBwcml2YXRlXG4gKi9cbkxlZ2FjeVRyYW5zcG9ydFN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gX3dyaXRlKGluZm8sIGVuYywgY2FsbGJhY2spIHtcbiAgaWYgKHRoaXMuc2lsZW50IHx8IChpbmZvLmV4Y2VwdGlvbiA9PT0gdHJ1ZSAmJiAhdGhpcy5oYW5kbGVFeGNlcHRpb25zKSkge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgfVxuXG4gIC8vIFJlbWFyazogVGhpcyBoYXMgdG8gYmUgaGFuZGxlZCBpbiB0aGUgYmFzZSB0cmFuc3BvcnQgbm93IGJlY2F1c2Ugd2VcbiAgLy8gY2Fubm90IGNvbmRpdGlvbmFsbHkgd3JpdGUgdG8gb3VyIHBpcGUgdGFyZ2V0cyBhcyBzdHJlYW0uXG4gIGlmICghdGhpcy5sZXZlbCB8fCB0aGlzLmxldmVsc1t0aGlzLmxldmVsXSA+PSB0aGlzLmxldmVsc1tpbmZvW0xFVkVMXV0pIHtcbiAgICB0aGlzLnRyYW5zcG9ydC5sb2coaW5mb1tMRVZFTF0sIGluZm8ubWVzc2FnZSwgaW5mbywgdGhpcy5fbm9wKTtcbiAgfVxuXG4gIGNhbGxiYWNrKG51bGwpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgdGhlIGJhdGNoIG9mIGluZm8gb2JqZWN0cyAoaS5lLiBcIm9iamVjdCBjaHVua3NcIikgdG8gb3VyIHRyYW5zcG9ydFxuICogaW5zdGFuY2UgYWZ0ZXIgcGVyZm9ybWluZyBhbnkgbmVjZXNzYXJ5IGZpbHRlcmluZy5cbiAqIEBwYXJhbSB7bWl4ZWR9IGNodW5rcyAtIFRPRE86IGFkZCBwYXJhbXMgZGVzY3JpcHRpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRPRE86IGFkZCBwYXJhbXMgZGVzY3JpcHRpb24uXG4gKiBAcmV0dXJucyB7bWl4ZWR9IC0gVE9ETzogYWRkIHJldHVybnMgZGVzY3JpcHRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5MZWdhY3lUcmFuc3BvcnRTdHJlYW0ucHJvdG90eXBlLl93cml0ZXYgPSBmdW5jdGlvbiBfd3JpdGV2KGNodW5rcywgY2FsbGJhY2spIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5fYWNjZXB0KGNodW5rc1tpXSkpIHtcbiAgICAgIHRoaXMudHJhbnNwb3J0LmxvZyhcbiAgICAgICAgY2h1bmtzW2ldLmNodW5rW0xFVkVMXSxcbiAgICAgICAgY2h1bmtzW2ldLmNodW5rLm1lc3NhZ2UsXG4gICAgICAgIGNodW5rc1tpXS5jaHVuayxcbiAgICAgICAgdGhpcy5fbm9wXG4gICAgICApO1xuICAgICAgY2h1bmtzW2ldLmNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xufTtcblxuLyoqXG4gKiBEaXNwbGF5cyBhIGRlcHJlY2F0aW9uIG5vdGljZS4gRGVmaW5lZCBhcyBhIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZVxuICogb3ZlcnJpZGVuIGluIHRlc3RzLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuTGVnYWN5VHJhbnNwb3J0U3RyZWFtLnByb3RvdHlwZS5fZGVwcmVjYXRlZCA9IGZ1bmN0aW9uIF9kZXByZWNhdGVkKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLmVycm9yKFtcbiAgICBgJHt0aGlzLnRyYW5zcG9ydC5uYW1lfSBpcyBhIGxlZ2FjeSB3aW5zdG9uIHRyYW5zcG9ydC4gQ29uc2lkZXIgdXBncmFkaW5nOiBgLFxuICAgICctIFVwZ3JhZGUgZG9jczogaHR0cHM6Ly9naXRodWIuY29tL3dpbnN0b25qcy93aW5zdG9uL2Jsb2IvbWFzdGVyL1VQR1JBREUtMy4wLm1kJ1xuICBdLmpvaW4oJ1xcbicpKTtcbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZXJyb3IgaGFuZGxpbmcgc3RhdGUgb24gdGhlIGxlZ2FjeSB0cmFuc3BvcnQgYXNzb2NpYXRlZFxuICogd2l0aCB0aGlzIGluc3RhbmNlLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuTGVnYWN5VHJhbnNwb3J0U3RyZWFtLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICBpZiAodGhpcy50cmFuc3BvcnQuY2xvc2UpIHtcbiAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMudHJhbnNwb3J0Ll9fd2luc3RvbkVycm9yKSB7XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgdGhpcy50cmFuc3BvcnQuX193aW5zdG9uRXJyb3IpO1xuICAgIHRoaXMudHJhbnNwb3J0Ll9fd2luc3RvbkVycm9yID0gbnVsbDtcbiAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbi8vIEV4cG9zZSBtb2Rlcm4gdHJhbnNwb3J0IGRpcmVjdGx5IGFzIHRoZSBleHBvcnRcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tb2Rlcm4nKTtcblxuLy8gRXhwb3NlIGxlZ2FjeSBzdHJlYW1cbm1vZHVsZS5leHBvcnRzLkxlZ2FjeVRyYW5zcG9ydFN0cmVhbSA9IHJlcXVpcmUoJy4vbGVnYWN5Jyk7XG4iLCAiLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuLypcbiAqIGNvbnNvbGUuanM6IFRyYW5zcG9ydCBmb3Igb3V0cHV0dGluZyB0byB0aGUgY29uc29sZS5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCB7IExFVkVMLCBNRVNTQUdFIH0gPSByZXF1aXJlKCd0cmlwbGUtYmVhbScpO1xuY29uc3QgVHJhbnNwb3J0U3RyZWFtID0gcmVxdWlyZSgnd2luc3Rvbi10cmFuc3BvcnQnKTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgZm9yIG91dHB1dHRpbmcgdG8gdGhlIGNvbnNvbGUuXG4gKiBAdHlwZSB7Q29uc29sZX1cbiAqIEBleHRlbmRzIHtUcmFuc3BvcnRTdHJlYW19XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ29uc29sZSBleHRlbmRzIFRyYW5zcG9ydFN0cmVhbSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIENvbnNvbGUgdHJhbnNwb3J0IG9iamVjdCByZXNwb25zaWJsZSBmb3JcbiAgICogcGVyc2lzdGluZyBsb2cgbWVzc2FnZXMgYW5kIG1ldGFkYXRhIHRvIGEgdGVybWluYWwgb3IgVFRZLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IFtvcHRpb25zPXt9XSAtIE9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIC8vIEV4cG9zZSB0aGUgbmFtZSBvZiB0aGlzIFRyYW5zcG9ydCBvbiB0aGUgcHJvdG90eXBlXG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8ICdjb25zb2xlJztcbiAgICB0aGlzLnN0ZGVyckxldmVscyA9IHRoaXMuX3N0cmluZ0FycmF5VG9TZXQob3B0aW9ucy5zdGRlcnJMZXZlbHMpO1xuICAgIHRoaXMuY29uc29sZVdhcm5MZXZlbHMgPSB0aGlzLl9zdHJpbmdBcnJheVRvU2V0KG9wdGlvbnMuY29uc29sZVdhcm5MZXZlbHMpO1xuICAgIHRoaXMuZW9sID0gKHR5cGVvZiBvcHRpb25zLmVvbCA9PT0gJ3N0cmluZycpID8gb3B0aW9ucy5lb2wgOiBvcy5FT0w7XG5cbiAgICB0aGlzLnNldE1heExpc3RlbmVycygzMCk7XG4gIH1cblxuICAvKipcbiAgICogQ29yZSBsb2dnaW5nIG1ldGhvZCBleHBvc2VkIHRvIFdpbnN0b24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGxvZyhpbmZvLCBjYWxsYmFjaykge1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLmVtaXQoJ2xvZ2dlZCcsIGluZm8pKTtcblxuICAgIC8vIFJlbWFyazogd2hhdCBpZiB0aGVyZSBpcyBubyByYXcuLi4/XG4gICAgaWYgKHRoaXMuc3RkZXJyTGV2ZWxzW2luZm9bTEVWRUxdXSkge1xuICAgICAgaWYgKGNvbnNvbGUuX3N0ZGVycikge1xuICAgICAgICAvLyBOb2RlLmpzIG1hcHMgYHByb2Nlc3Muc3RkZXJyYCB0byBgY29uc29sZS5fc3RkZXJyYC5cbiAgICAgICAgY29uc29sZS5fc3RkZXJyLndyaXRlKGAke2luZm9bTUVTU0FHRV19JHt0aGlzLmVvbH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IgYWRkcyBhIG5ld2xpbmVcbiAgICAgICAgY29uc29sZS5lcnJvcihpbmZvW01FU1NBR0VdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbnNvbGVXYXJuTGV2ZWxzW2luZm9bTEVWRUxdXSkge1xuICAgICAgaWYgKGNvbnNvbGUuX3N0ZGVycikge1xuICAgICAgICAvLyBOb2RlLmpzIG1hcHMgYHByb2Nlc3Muc3RkZXJyYCB0byBgY29uc29sZS5fc3RkZXJyYC5cbiAgICAgICAgLy8gaW4gTm9kZS5qcyBjb25zb2xlLndhcm4gaXMgYW4gYWxpYXMgZm9yIGNvbnNvbGUuZXJyb3JcbiAgICAgICAgY29uc29sZS5fc3RkZXJyLndyaXRlKGAke2luZm9bTUVTU0FHRV19JHt0aGlzLmVvbH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybiBhZGRzIGEgbmV3bGluZVxuICAgICAgICBjb25zb2xlLndhcm4oaW5mb1tNRVNTQUdFXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbGxiYWNrLXJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjb25zb2xlLl9zdGRvdXQpIHtcbiAgICAgIC8vIE5vZGUuanMgbWFwcyBgcHJvY2Vzcy5zdGRvdXRgIHRvIGBjb25zb2xlLl9zdGRvdXRgLlxuICAgICAgY29uc29sZS5fc3Rkb3V0LndyaXRlKGAke2luZm9bTUVTU0FHRV19JHt0aGlzLmVvbH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29uc29sZS5sb2cgYWRkcyBhIG5ld2xpbmUuXG4gICAgICBjb25zb2xlLmxvZyhpbmZvW01FU1NBR0VdKTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBTZXQtbGlrZSBvYmplY3Qgd2l0aCBzdHJBcnJheSdzIGVsZW1lbnRzIGFzIGtleXMgKGVhY2ggd2l0aCB0aGVcbiAgICogdmFsdWUgdHJ1ZSkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0ckFycmF5IC0gQXJyYXkgb2YgU2V0LWVsZW1lbnRzIGFzIHN0cmluZ3MuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gW2Vyck1zZ10gLSBDdXN0b20gZXJyb3IgbWVzc2FnZSB0aHJvd24gb24gaW52YWxpZCBpbnB1dC5cbiAgICogQHJldHVybnMge09iamVjdH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N0cmluZ0FycmF5VG9TZXQoc3RyQXJyYXksIGVyck1zZykge1xuICAgIGlmICghc3RyQXJyYXkpXG4gICAgICByZXR1cm4ge307XG5cbiAgICBlcnJNc2cgPSBlcnJNc2cgfHwgJ0Nhbm5vdCBtYWtlIHNldCBmcm9tIHR5cGUgb3RoZXIgdGhhbiBBcnJheSBvZiBzdHJpbmcgZWxlbWVudHMnO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHN0ckFycmF5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ckFycmF5LnJlZHVjZSgoc2V0LCBlbCkgPT4gIHtcbiAgICAgIGlmICh0eXBlb2YgZWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgfVxuICAgICAgc2V0W2VsXSA9IHRydWU7XG5cbiAgICAgIHJldHVybiBzZXQ7XG4gICAgfSwge30pO1xuICB9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNBcnJheUxpa2U7XG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJiB2YWx1ZS5sZW5ndGggPj0gMCAmJiB2YWx1ZS5sZW5ndGggJSAxID09PSAwO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwgIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncyAvKiwgY2FsbGJhY2sqLykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhcmdzLCBjYWxsYmFjayk7XG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZmFsbGJhY2sgPSBmYWxsYmFjaztcbmV4cG9ydHMud3JhcCA9IHdyYXA7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuXG52YXIgaGFzUXVldWVNaWNyb3Rhc2sgPSBleHBvcnRzLmhhc1F1ZXVlTWljcm90YXNrID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09PSAnZnVuY3Rpb24nICYmIHF1ZXVlTWljcm90YXNrO1xudmFyIGhhc1NldEltbWVkaWF0ZSA9IGV4cG9ydHMuaGFzU2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXRJbW1lZGlhdGU7XG52YXIgaGFzTmV4dFRpY2sgPSBleHBvcnRzLmhhc05leHRUaWNrID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBmYWxsYmFjayhmbikge1xuICAgIHNldFRpbWVvdXQoZm4sIDApO1xufVxuXG5mdW5jdGlvbiB3cmFwKGRlZmVyKSB7XG4gICAgcmV0dXJuIChmbiwgLi4uYXJncykgPT4gZGVmZXIoKCkgPT4gZm4oLi4uYXJncykpO1xufVxuXG52YXIgX2RlZmVyO1xuXG5pZiAoaGFzUXVldWVNaWNyb3Rhc2spIHtcbiAgICBfZGVmZXIgPSBxdWV1ZU1pY3JvdGFzaztcbn0gZWxzZSBpZiAoaGFzU2V0SW1tZWRpYXRlKSB7XG4gICAgX2RlZmVyID0gc2V0SW1tZWRpYXRlO1xufSBlbHNlIGlmIChoYXNOZXh0VGljaykge1xuICAgIF9kZWZlciA9IHByb2Nlc3MubmV4dFRpY2s7XG59IGVsc2Uge1xuICAgIF9kZWZlciA9IGZhbGxiYWNrO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB3cmFwKF9kZWZlcik7IiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYXN5bmNpZnk7XG5cbnZhciBfaW5pdGlhbFBhcmFtcyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvaW5pdGlhbFBhcmFtcy5qcycpO1xuXG52YXIgX2luaXRpYWxQYXJhbXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5pdGlhbFBhcmFtcyk7XG5cbnZhciBfc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zZXRJbW1lZGlhdGUuanMnKTtcblxudmFyIF9zZXRJbW1lZGlhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0SW1tZWRpYXRlKTtcblxudmFyIF93cmFwQXN5bmMgPSByZXF1aXJlKCcuL2ludGVybmFsL3dyYXBBc3luYy5qcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFRha2UgYSBzeW5jIGZ1bmN0aW9uIGFuZCBtYWtlIGl0IGFzeW5jLCBwYXNzaW5nIGl0cyByZXR1cm4gdmFsdWUgdG8gYVxuICogY2FsbGJhY2suIFRoaXMgaXMgdXNlZnVsIGZvciBwbHVnZ2luZyBzeW5jIGZ1bmN0aW9ucyBpbnRvIGEgd2F0ZXJmYWxsLFxuICogc2VyaWVzLCBvciBvdGhlciBhc3luYyBmdW5jdGlvbnMuIEFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIChleGNlcHQgZm9yIHRoZSBmaW5hbFxuICogY2FsbGJhY2sgYXJndW1lbnQpLiBFcnJvcnMgdGhyb3duIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBJZiB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGBhc3luY2lmeWAgcmV0dXJucyBhIFByb21pc2UsIHRoYXQgcHJvbWlzZXMnc1xuICogcmVzb2x2ZWQvcmVqZWN0ZWQgc3RhdGUgd2lsbCBiZSB1c2VkIHRvIGNhbGwgdGhlIGNhbGxiYWNrLCByYXRoZXIgdGhhbiBzaW1wbHlcbiAqIHRoZSBzeW5jaHJvbm91cyByZXR1cm4gdmFsdWUuXG4gKlxuICogVGhpcyBhbHNvIG1lYW5zIHlvdSBjYW4gYXN5bmNpZnkgRVMyMDE3IGBhc3luY2AgZnVuY3Rpb25zLlxuICpcbiAqIEBuYW1lIGFzeW5jaWZ5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgd3JhcFN5bmNcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gVGhlIHN5bmNocm9ub3VzIGZ1bmN0aW9uLCBvciBQcm9taXNlLXJldHVybmluZ1xuICogZnVuY3Rpb24gdG8gY29udmVydCB0byBhbiB7QGxpbmsgQXN5bmNGdW5jdGlvbn0uXG4gKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gQW4gYXN5bmNocm9ub3VzIHdyYXBwZXIgb2YgdGhlIGBmdW5jYC4gVG8gYmVcbiAqIGludm9rZWQgd2l0aCBgKGFyZ3MuLi4sIGNhbGxiYWNrKWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIHBhc3NpbmcgYSByZWd1bGFyIHN5bmNocm9ub3VzIGZ1bmN0aW9uXG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIGFzeW5jLmFwcGx5KGZzLnJlYWRGaWxlLCBmaWxlbmFtZSwgXCJ1dGY4XCIpLFxuICogICAgIGFzeW5jLmFzeW5jaWZ5KEpTT04ucGFyc2UpLFxuICogICAgIGZ1bmN0aW9uIChkYXRhLCBuZXh0KSB7XG4gKiAgICAgICAgIC8vIGRhdGEgaXMgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHRoZSB0ZXh0LlxuICogICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwYXJzaW5nIGVycm9yLCBpdCB3b3VsZCBoYXZlIGJlZW4gY2F1Z2h0LlxuICogICAgIH1cbiAqIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiAvLyBwYXNzaW5nIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgcHJvbWlzZVxuICogYXN5bmMud2F0ZXJmYWxsKFtcbiAqICAgICBhc3luYy5hcHBseShmcy5yZWFkRmlsZSwgZmlsZW5hbWUsIFwidXRmOFwiKSxcbiAqICAgICBhc3luYy5hc3luY2lmeShmdW5jdGlvbiAoY29udGVudHMpIHtcbiAqICAgICAgICAgcmV0dXJuIGRiLm1vZGVsLmNyZWF0ZShjb250ZW50cyk7XG4gKiAgICAgfSksXG4gKiAgICAgZnVuY3Rpb24gKG1vZGVsLCBuZXh0KSB7XG4gKiAgICAgICAgIC8vIGBtb2RlbGAgaXMgdGhlIGluc3RhbnRpYXRlZCBtb2RlbCBvYmplY3QuXG4gKiAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciwgdGhpcyBmdW5jdGlvbiB3b3VsZCBiZSBza2lwcGVkLlxuICogICAgIH1cbiAqIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiAvLyBlczIwMTcgZXhhbXBsZSwgdGhvdWdoIGBhc3luY2lmeWAgaXMgbm90IG5lZWRlZCBpZiB5b3VyIEpTIGVudmlyb25tZW50XG4gKiAvLyBzdXBwb3J0cyBhc3luYyBmdW5jdGlvbnMgb3V0IG9mIHRoZSBib3hcbiAqIHZhciBxID0gYXN5bmMucXVldWUoYXN5bmMuYXN5bmNpZnkoYXN5bmMgZnVuY3Rpb24oZmlsZSkge1xuICogICAgIHZhciBpbnRlcm1lZGlhdGVTdGVwID0gYXdhaXQgcHJvY2Vzc0ZpbGUoZmlsZSk7XG4gKiAgICAgcmV0dXJuIGF3YWl0IHNvbWVQcm9taXNlKGludGVybWVkaWF0ZVN0ZXApXG4gKiB9KSk7XG4gKlxuICogcS5wdXNoKGZpbGVzKTtcbiAqL1xuZnVuY3Rpb24gYXN5bmNpZnkoZnVuYykge1xuICAgIGlmICgoMCwgX3dyYXBBc3luYy5pc0FzeW5jKShmdW5jKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MgLyosIGNhbGxiYWNrKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVByb21pc2UocHJvbWlzZSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiAoMCwgX2luaXRpYWxQYXJhbXMyLmRlZmF1bHQpKGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHJlc3VsdCBpcyBQcm9taXNlIG9iamVjdFxuICAgICAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVByb21pc2UocmVzdWx0LCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVByb21pc2UocHJvbWlzZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIG51bGwsIHZhbHVlKTtcbiAgICB9LCBlcnIgPT4ge1xuICAgICAgICBpbnZva2VDYWxsYmFjayhjYWxsYmFjaywgZXJyICYmIChlcnIgaW5zdGFuY2VvZiBFcnJvciB8fCBlcnIubWVzc2FnZSkgPyBlcnIgOiBuZXcgRXJyb3IoZXJyKSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBlcnJvciwgdmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBjYWxsYmFjayhlcnJvciwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAoMCwgX3NldEltbWVkaWF0ZTIuZGVmYXVsdCkoZSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LCBlcnIpO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNBc3luY0l0ZXJhYmxlID0gZXhwb3J0cy5pc0FzeW5jR2VuZXJhdG9yID0gZXhwb3J0cy5pc0FzeW5jID0gdW5kZWZpbmVkO1xuXG52YXIgX2FzeW5jaWZ5ID0gcmVxdWlyZSgnLi4vYXN5bmNpZnkuanMnKTtcblxudmFyIF9hc3luY2lmeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3luY2lmeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzQXN5bmMoZm4pIHtcbiAgICByZXR1cm4gZm5bU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0FzeW5jRnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc0FzeW5jR2VuZXJhdG9yKGZuKSB7XG4gICAgcmV0dXJuIGZuW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdBc3luY0dlbmVyYXRvcic7XG59XG5cbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZShvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9ialtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIHdyYXBBc3luYyhhc3luY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBhc3luY0ZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGEgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4gaXNBc3luYyhhc3luY0ZuKSA/ICgwLCBfYXN5bmNpZnkyLmRlZmF1bHQpKGFzeW5jRm4pIDogYXN5bmNGbjtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gd3JhcEFzeW5jO1xuZXhwb3J0cy5pc0FzeW5jID0gaXNBc3luYztcbmV4cG9ydHMuaXNBc3luY0dlbmVyYXRvciA9IGlzQXN5bmNHZW5lcmF0b3I7XG5leHBvcnRzLmlzQXN5bmNJdGVyYWJsZSA9IGlzQXN5bmNJdGVyYWJsZTsiLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhd2FpdGlmeTtcbi8vIGNvbmRpdGlvbmFsbHkgcHJvbWlzaWZ5IGEgZnVuY3Rpb24uXG4vLyBvbmx5IHJldHVybiBhIHByb21pc2UgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG5mdW5jdGlvbiBhd2FpdGlmeShhc3luY0ZuLCBhcml0eSkge1xuICAgIGlmICghYXJpdHkpIGFyaXR5ID0gYXN5bmNGbi5sZW5ndGg7XG4gICAgaWYgKCFhcml0eSkgdGhyb3cgbmV3IEVycm9yKCdhcml0eSBpcyB1bmRlZmluZWQnKTtcbiAgICBmdW5jdGlvbiBhd2FpdGFibGUoLi4uYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbYXJpdHkgLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jRm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgYXJnc1thcml0eSAtIDFdID0gKGVyciwgLi4uY2JBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoY2JBcmdzLmxlbmd0aCA+IDEgPyBjYkFyZ3MgOiBjYkFyZ3NbMF0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzeW5jRm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdGFibGU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlLmpzJyk7XG5cbnZhciBfaXNBcnJheUxpa2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNBcnJheUxpa2UpO1xuXG52YXIgX3dyYXBBc3luYyA9IHJlcXVpcmUoJy4vd3JhcEFzeW5jLmpzJyk7XG5cbnZhciBfd3JhcEFzeW5jMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dyYXBBc3luYyk7XG5cbnZhciBfYXdhaXRpZnkgPSByZXF1aXJlKCcuL2F3YWl0aWZ5LmpzJyk7XG5cbnZhciBfYXdhaXRpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXdhaXRpZnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgX2F3YWl0aWZ5Mi5kZWZhdWx0KSgoZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spID0+IHtcbiAgICB2YXIgcmVzdWx0cyA9ICgwLCBfaXNBcnJheUxpa2UyLmRlZmF1bHQpKHRhc2tzKSA/IFtdIDoge307XG5cbiAgICBlYWNoZm4odGFza3MsICh0YXNrLCBrZXksIHRhc2tDYikgPT4ge1xuICAgICAgICAoMCwgX3dyYXBBc3luYzIuZGVmYXVsdCkodGFzaykoKGVyciwgLi4ucmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBbcmVzdWx0XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIHRhc2tDYihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBlcnIgPT4gY2FsbGJhY2soZXJyLCByZXN1bHRzKSk7XG59LCAzKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsICJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gb25jZTtcbmZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgICBmdW5jdGlvbiB3cmFwcGVyKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGZuID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIHZhciBjYWxsRm4gPSBmbjtcbiAgICAgICAgZm4gPSBudWxsO1xuICAgICAgICBjYWxsRm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24od3JhcHBlciwgZm4pO1xuICAgIHJldHVybiB3cmFwcGVyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwgIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjb2xsKSB7XG4gICAgcmV0dXJuIGNvbGxbU3ltYm9sLml0ZXJhdG9yXSAmJiBjb2xsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUl0ZXJhdG9yO1xuXG52YXIgX2lzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZS5qcycpO1xuXG52YXIgX2lzQXJyYXlMaWtlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQXJyYXlMaWtlKTtcblxudmFyIF9nZXRJdGVyYXRvciA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3IuanMnKTtcblxudmFyIF9nZXRJdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRJdGVyYXRvcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5SXRlcmF0b3IoY29sbCkge1xuICAgIHZhciBpID0gLTE7XG4gICAgdmFyIGxlbiA9IGNvbGwubGVuZ3RoO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICByZXR1cm4gKytpIDwgbGVuID8geyB2YWx1ZTogY29sbFtpXSwga2V5OiBpIH0gOiBudWxsO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVTMjAxNUl0ZXJhdG9yKGl0ZXJhdG9yKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVtLmRvbmUpIHJldHVybiBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtLnZhbHVlLCBrZXk6IGkgfTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RJdGVyYXRvcihvYmopIHtcbiAgICB2YXIgb2tleXMgPSBvYmogPyBPYmplY3Qua2V5cyhvYmopIDogW107XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gb2tleXMubGVuZ3RoO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIga2V5ID0gb2tleXNbKytpXTtcbiAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyB7IHZhbHVlOiBvYmpba2V5XSwga2V5IH0gOiBudWxsO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9yKGNvbGwpIHtcbiAgICBpZiAoKDAsIF9pc0FycmF5TGlrZTIuZGVmYXVsdCkoY29sbCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFycmF5SXRlcmF0b3IoY29sbCk7XG4gICAgfVxuXG4gICAgdmFyIGl0ZXJhdG9yID0gKDAsIF9nZXRJdGVyYXRvcjIuZGVmYXVsdCkoY29sbCk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yID8gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIDogY3JlYXRlT2JqZWN0SXRlcmF0b3IoY29sbCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG9ubHlPbmNlO1xuZnVuY3Rpb24gb25seU9uY2UoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGZuID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuXCIpO1xuICAgICAgICB2YXIgY2FsbEZuID0gZm47XG4gICAgICAgIGZuID0gbnVsbDtcbiAgICAgICAgY2FsbEZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbi8vIEEgdGVtcG9yYXJ5IHZhbHVlIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGxvb3Agc2hvdWxkIGJlIGJyb2tlbi5cbi8vIFNlZSAjMTA2NCwgIzEyOTNcbmNvbnN0IGJyZWFrTG9vcCA9IHt9O1xuZXhwb3J0cy5kZWZhdWx0ID0gYnJlYWtMb29wO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYXN5bmNFYWNoT2ZMaW1pdDtcblxudmFyIF9icmVha0xvb3AgPSByZXF1aXJlKCcuL2JyZWFrTG9vcC5qcycpO1xuXG52YXIgX2JyZWFrTG9vcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9icmVha0xvb3ApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBmb3IgYXN5bmMgZ2VuZXJhdG9yc1xuZnVuY3Rpb24gYXN5bmNFYWNoT2ZMaW1pdChnZW5lcmF0b3IsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGxldCBhd2FpdGluZyA9IGZhbHNlO1xuICAgIGxldCBydW5uaW5nID0gMDtcbiAgICBsZXQgaWR4ID0gMDtcblxuICAgIGZ1bmN0aW9uIHJlcGxlbmlzaCgpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygncmVwbGVuaXNoJylcbiAgICAgICAgaWYgKHJ1bm5pbmcgPj0gbGltaXQgfHwgYXdhaXRpbmcgfHwgZG9uZSkgcmV0dXJuO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdyZXBsZW5pc2ggYXdhaXRpbmcnKVxuICAgICAgICBhd2FpdGluZyA9IHRydWU7XG4gICAgICAgIGdlbmVyYXRvci5uZXh0KCkudGhlbigoeyB2YWx1ZSwgZG9uZTogaXRlckRvbmUgfSkgPT4ge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZ290IHZhbHVlJywgdmFsdWUpXG4gICAgICAgICAgICBpZiAoY2FuY2VsZWQgfHwgZG9uZSkgcmV0dXJuO1xuICAgICAgICAgICAgYXdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpdGVyRG9uZSkge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZG9uZSBuZXh0Q2InKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVubmluZysrO1xuICAgICAgICAgICAgaXRlcmF0ZWUodmFsdWUsIGlkeCwgaXRlcmF0ZWVDYWxsYmFjayk7XG4gICAgICAgICAgICBpZHgrKztcbiAgICAgICAgICAgIHJlcGxlbmlzaCgpO1xuICAgICAgICB9KS5jYXRjaChoYW5kbGVFcnJvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZWVDYWxsYmFjayhlcnIsIHJlc3VsdCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdpdGVyYXRlZUNhbGxiYWNrJylcbiAgICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgICBpZiAoY2FuY2VsZWQpIHJldHVybjtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGhhbmRsZUVycm9yKGVycik7XG5cbiAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gX2JyZWFrTG9vcDIuZGVmYXVsdCB8fCBkb25lICYmIHJ1bm5pbmcgPD0gMCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkb25lIGl0ZXJDYicpXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyKSB7XG4gICAgICAgIGlmIChjYW5jZWxlZCkgcmV0dXJuO1xuICAgICAgICBhd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICByZXBsZW5pc2goKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9vbmNlID0gcmVxdWlyZSgnLi9vbmNlLmpzJyk7XG5cbnZhciBfb25jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vbmNlKTtcblxudmFyIF9pdGVyYXRvciA9IHJlcXVpcmUoJy4vaXRlcmF0b3IuanMnKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfb25seU9uY2UgPSByZXF1aXJlKCcuL29ubHlPbmNlLmpzJyk7XG5cbnZhciBfb25seU9uY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb25seU9uY2UpO1xuXG52YXIgX3dyYXBBc3luYyA9IHJlcXVpcmUoJy4vd3JhcEFzeW5jLmpzJyk7XG5cbnZhciBfYXN5bmNFYWNoT2ZMaW1pdCA9IHJlcXVpcmUoJy4vYXN5bmNFYWNoT2ZMaW1pdC5qcycpO1xuXG52YXIgX2FzeW5jRWFjaE9mTGltaXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXN5bmNFYWNoT2ZMaW1pdCk7XG5cbnZhciBfYnJlYWtMb29wID0gcmVxdWlyZSgnLi9icmVha0xvb3AuanMnKTtcblxudmFyIF9icmVha0xvb3AyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJlYWtMb29wKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbGltaXQgPT4ge1xuICAgIHJldHVybiAob2JqLCBpdGVyYXRlZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgY2FsbGJhY2sgPSAoMCwgX29uY2UyLmRlZmF1bHQpKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdjb25jdXJyZW5jeSBsaW1pdCBjYW5ub3QgYmUgbGVzcyB0aGFuIDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgX3dyYXBBc3luYy5pc0FzeW5jR2VuZXJhdG9yKShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hc3luY0VhY2hPZkxpbWl0Mi5kZWZhdWx0KShvYmosIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgX3dyYXBBc3luYy5pc0FzeW5jSXRlcmFibGUpKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2FzeW5jRWFjaE9mTGltaXQyLmRlZmF1bHQpKG9ialtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHRFbGVtID0gKDAsIF9pdGVyYXRvcjIuZGVmYXVsdCkob2JqKTtcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNhbmNlbGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBydW5uaW5nID0gMDtcbiAgICAgICAgdmFyIGxvb3BpbmcgPSBmYWxzZTtcblxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlZUNhbGxiYWNrKGVyciwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVyciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBfYnJlYWtMb29wMi5kZWZhdWx0IHx8IGRvbmUgJiYgcnVubmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbG9vcGluZykge1xuICAgICAgICAgICAgICAgIHJlcGxlbmlzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGVuaXNoKCkge1xuICAgICAgICAgICAgbG9vcGluZyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAocnVubmluZyA8IGxpbWl0ICYmICFkb25lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBuZXh0RWxlbSgpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTtcbiAgICAgICAgICAgICAgICBpdGVyYXRlZShlbGVtLnZhbHVlLCBlbGVtLmtleSwgKDAsIF9vbmx5T25jZTIuZGVmYXVsdCkoaXRlcmF0ZWVDYWxsYmFjaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9vcGluZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9lYWNoT2ZMaW1pdDIgPSByZXF1aXJlKCcuL2ludGVybmFsL2VhY2hPZkxpbWl0LmpzJyk7XG5cbnZhciBfZWFjaE9mTGltaXQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFjaE9mTGltaXQyKTtcblxudmFyIF93cmFwQXN5bmMgPSByZXF1aXJlKCcuL2ludGVybmFsL3dyYXBBc3luYy5qcycpO1xuXG52YXIgX3dyYXBBc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93cmFwQXN5bmMpO1xuXG52YXIgX2F3YWl0aWZ5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9hd2FpdGlmeS5qcycpO1xuXG52YXIgX2F3YWl0aWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F3YWl0aWZ5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGVhY2hPZmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYVxuICogdGltZS5cbiAqXG4gKiBAbmFtZSBlYWNoT2ZMaW1pdFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9uc1xuICogQG1ldGhvZFxuICogQHNlZSBbYXN5bmMuZWFjaE9mXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfVxuICogQGFsaWFzIGZvckVhY2hPZkxpbWl0XG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaFxuICogaXRlbSBpbiBgY29sbGAuIFRoZSBga2V5YCBpcyB0aGUgaXRlbSdzIGtleSwgb3IgaW5kZXggaW4gdGhlIGNhc2Ugb2YgYW5cbiAqIGFycmF5LlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAqL1xuZnVuY3Rpb24gZWFjaE9mTGltaXQoY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiAoMCwgX2VhY2hPZkxpbWl0My5kZWZhdWx0KShsaW1pdCkoY29sbCwgKDAsIF93cmFwQXN5bmMyLmRlZmF1bHQpKGl0ZXJhdGVlKSwgY2FsbGJhY2spO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgX2F3YWl0aWZ5Mi5kZWZhdWx0KShlYWNoT2ZMaW1pdCwgNCk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZWFjaE9mTGltaXQgPSByZXF1aXJlKCcuL2VhY2hPZkxpbWl0LmpzJyk7XG5cbnZhciBfZWFjaE9mTGltaXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFjaE9mTGltaXQpO1xuXG52YXIgX2F3YWl0aWZ5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9hd2FpdGlmeS5qcycpO1xuXG52YXIgX2F3YWl0aWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F3YWl0aWZ5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGVhY2hPZmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS5cbiAqXG4gKiBAbmFtZSBlYWNoT2ZTZXJpZXNcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmVhY2hPZl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn1cbiAqIEBhbGlhcyBmb3JFYWNoT2ZTZXJpZXNcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYFxuICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKi9cbmZ1bmN0aW9uIGVhY2hPZlNlcmllcyhjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gKDAsIF9lYWNoT2ZMaW1pdDIuZGVmYXVsdCkoY29sbCwgMSwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfYXdhaXRpZnkyLmRlZmF1bHQpKGVhY2hPZlNlcmllcywgMyk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCAiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBzZXJpZXM7XG5cbnZhciBfcGFyYWxsZWwyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9wYXJhbGxlbC5qcycpO1xuXG52YXIgX3BhcmFsbGVsMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcmFsbGVsMik7XG5cbnZhciBfZWFjaE9mU2VyaWVzID0gcmVxdWlyZSgnLi9lYWNoT2ZTZXJpZXMuanMnKTtcblxudmFyIF9lYWNoT2ZTZXJpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFjaE9mU2VyaWVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBSdW4gdGhlIGZ1bmN0aW9ucyBpbiB0aGUgYHRhc2tzYCBjb2xsZWN0aW9uIGluIHNlcmllcywgZWFjaCBvbmUgcnVubmluZyBvbmNlXG4gKiB0aGUgcHJldmlvdXMgZnVuY3Rpb24gaGFzIGNvbXBsZXRlZC4gSWYgYW55IGZ1bmN0aW9ucyBpbiB0aGUgc2VyaWVzIHBhc3MgYW5cbiAqIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgbm8gbW9yZSBmdW5jdGlvbnMgYXJlIHJ1biwgYW5kIGBjYWxsYmFja2AgaXNcbiAqIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgZXJyb3IuIE90aGVyd2lzZSwgYGNhbGxiYWNrYFxuICogcmVjZWl2ZXMgYW4gYXJyYXkgb2YgcmVzdWx0cyB3aGVuIGB0YXNrc2AgaGF2ZSBjb21wbGV0ZWQuXG4gKlxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byB1c2UgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIEVhY2ggcHJvcGVydHkgd2lsbFxuICogYmUgcnVuIGFzIGEgZnVuY3Rpb24sIGFuZCB0aGUgcmVzdWx0cyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZmluYWwgYGNhbGxiYWNrYFxuICogYXMgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIFRoaXMgY2FuIGJlIGEgbW9yZSByZWFkYWJsZSB3YXkgb2YgaGFuZGxpbmdcbiAqICByZXN1bHRzIGZyb20ge0BsaW5rIGFzeW5jLnNlcmllc30uXG4gKlxuICogKipOb3RlKiogdGhhdCB3aGlsZSBtYW55IGltcGxlbWVudGF0aW9ucyBwcmVzZXJ2ZSB0aGUgb3JkZXIgb2Ygb2JqZWN0XG4gKiBwcm9wZXJ0aWVzLCB0aGUgW0VDTUFTY3JpcHQgTGFuZ3VhZ2UgU3BlY2lmaWNhdGlvbl0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTguNilcbiAqIGV4cGxpY2l0bHkgc3RhdGVzIHRoYXRcbiAqXG4gKiA+IFRoZSBtZWNoYW5pY3MgYW5kIG9yZGVyIG9mIGVudW1lcmF0aW5nIHRoZSBwcm9wZXJ0aWVzIGlzIG5vdCBzcGVjaWZpZWQuXG4gKlxuICogU28gaWYgeW91IHJlbHkgb24gdGhlIG9yZGVyIGluIHdoaWNoIHlvdXIgc2VyaWVzIG9mIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWQsXG4gKiBhbmQgd2FudCB0aGlzIHRvIHdvcmsgb24gYWxsIHBsYXRmb3JtcywgY29uc2lkZXIgdXNpbmcgYW4gYXJyYXkuXG4gKlxuICogQG5hbWUgc2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSB0YXNrcyAtIEEgY29sbGVjdGlvbiBjb250YWluaW5nXG4gKiBbYXN5bmMgZnVuY3Rpb25zXXtAbGluayBBc3luY0Z1bmN0aW9ufSB0byBydW4gaW4gc2VyaWVzLlxuICogRWFjaCBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlXG4gKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQuIFRoaXMgZnVuY3Rpb24gZ2V0cyBhIHJlc3VsdHMgYXJyYXkgKG9yIG9iamVjdClcbiAqIGNvbnRhaW5pbmcgYWxsIHRoZSByZXN1bHQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgYHRhc2tgIGNhbGxiYWNrcy4gSW52b2tlZFxuICogd2l0aCAoZXJyLCByZXN1bHQpLlxuICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy9Vc2luZyBDYWxsYmFja3NcbiAqIGFzeW5jLnNlcmllcyhbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIC8vIGRvIHNvbWUgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpO1xuICogICAgICAgICB9LCAyMDApO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIC8vIHRoZW4gZG8gYW5vdGhlciBhc3luYyB0YXNrXG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogXSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XG4gKiAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0byBbJ29uZScsJ3R3byddXG4gKiB9KTtcbiAqXG4gKiAvLyBhbiBleGFtcGxlIHVzaW5nIG9iamVjdHMgaW5zdGVhZCBvZiBhcnJheXNcbiAqIGFzeW5jLnNlcmllcyh7XG4gKiAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgLy8gZG8gc29tZSBhc3luYyB0YXNrXG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIC8vIHRoZW4gZG8gYW5vdGhlciBhc3luYyB0YXNrXG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAyKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvOiB7IG9uZTogMSwgdHdvOiAyIH1cbiAqIH0pO1xuICpcbiAqIC8vVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLnNlcmllcyhbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogXSkudGhlbihyZXN1bHRzID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvIFsnb25lJywndHdvJ11cbiAqIH0pLmNhdGNoKGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqIGFzeW5jLnNlcmllcyh7XG4gKiAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgICAgICAgLy8gZG8gc29tZSBhc3luYyB0YXNrXG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIC8vIHRoZW4gZG8gYW5vdGhlciBhc3luYyB0YXNrXG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAyKTtcbiAqICAgICAgICAgfSwgMTAwKTtcbiAqICAgICB9XG4gKiB9KS50aGVuKHJlc3VsdHMgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgIC8vIHJlc3VsdHMgaXMgZXF1YWwgdG86IHsgb25lOiAxLCB0d286IDIgfVxuICogfSkuY2F0Y2goZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogLy9Vc2luZyBhc3luYy9hd2FpdFxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgYXN5bmMuc2VyaWVzKFtcbiAqICAgICAgICAgICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgLy8gZG8gc29tZSBhc3luYyB0YXNrXG4gKiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgICAgICAgICB9LCAyMDApO1xuICogICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBkbyBhbm90aGVyIGFzeW5jIHRhc2tcbiAqICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpO1xuICogICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgICAgICAgICB9XG4gKiAgICAgICAgIF0pO1xuICogICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcbiAqICAgICAgICAgLy8gcmVzdWx0cyBpcyBlcXVhbCB0byBbJ29uZScsJ3R3byddXG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICogLy8gYW4gZXhhbXBsZSB1c2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheVxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgYXN5bmMucGFyYWxsZWwoe1xuICogICAgICAgICAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgIC8vIGRvIHNvbWUgYXN5bmMgdGFza1xuICogICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTtcbiAqICAgICAgICAgICAgICAgICB9LCAyMDApO1xuICogICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgdHdvOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICogICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gZG8gYW5vdGhlciBhc3luYyB0YXNrXG4gKiAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDIpO1xuICogICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgICAgICAgIH1cbiAqICAgICAgICAgfSk7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICogICAgICAgICAvLyByZXN1bHRzIGlzIGVxdWFsIHRvOiB7IG9uZTogMSwgdHdvOiAyIH1cbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKi9cbmZ1bmN0aW9uIHNlcmllcyh0YXNrcywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gKDAsIF9wYXJhbGxlbDMuZGVmYXVsdCkoX2VhY2hPZlNlcmllczIuZGVmYXVsdCwgdGFza3MsIGNhbGxiYWNrKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsICIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcsXG4gIEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMDtcbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5yZXF1aXJlKCdpbmhlcml0cycpKFRyYW5zZm9ybSwgRHVwbGV4KTtcbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcbiAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCkpO1xuICB9XG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcbiAgaWYgKGRhdGEgIT0gbnVsbClcbiAgICAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG4gIGNiKGVyKTtcbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCkge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ190cmFuc2Zvcm0oKScpKTtcbn07XG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgaWYgKGRhdGEgIT0gbnVsbClcbiAgICAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBUT0RPKEJyaWRnZUFSKTogV3JpdGUgYSB0ZXN0IGZvciB0aGVzZSB0d28gZXJyb3IgY2FzZXNcbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAoKTtcbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORygpO1xuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwgIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcbnJlcXVpcmUoJ2luaGVyaXRzJykoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsICIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL3B1bXAgd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVvcztcbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLFxuICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUyxcbiAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRDtcbmZ1bmN0aW9uIG5vb3AoZXJyKSB7XG4gIC8vIFJldGhyb3cgdGhlIGVycm9yIGlmIGl0IGV4aXN0cyB0byBhdm9pZCBzd2FsbG93aW5nIGl0XG4gIGlmIChlcnIpIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayk7XG4gIHZhciBjbG9zZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICB9KTtcbiAgaWYgKGVvcyA9PT0gdW5kZWZpbmVkKSBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcbiAgZW9zKHN0cmVhbSwge1xuICAgIHJlYWRhYmxlOiByZWFkaW5nLFxuICAgIHdyaXRhYmxlOiB3cml0aW5nXG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xuICB2YXIgZGVzdHJveWVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBkZXN0cm95ZWQgPSB0cnVlO1xuXG4gICAgLy8gcmVxdWVzdC5kZXN0cm95IGp1c3QgZG8gLmVuZCAtIC5hYm9ydCBpcyB3aGF0IHdlIHdhbnRcbiAgICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHJldHVybiBzdHJlYW0uYWJvcnQoKTtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gc3RyZWFtLmRlc3Ryb3koKTtcbiAgICBjYWxsYmFjayhlcnIgfHwgbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCdwaXBlJykpO1xuICB9O1xufVxuZnVuY3Rpb24gY2FsbChmbikge1xuICBmbigpO1xufVxuZnVuY3Rpb24gcGlwZShmcm9tLCB0bykge1xuICByZXR1cm4gZnJvbS5waXBlKHRvKTtcbn1cbmZ1bmN0aW9uIHBvcENhbGxiYWNrKHN0cmVhbXMpIHtcbiAgaWYgKCFzdHJlYW1zLmxlbmd0aCkgcmV0dXJuIG5vb3A7XG4gIGlmICh0eXBlb2Ygc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbm9vcDtcbiAgcmV0dXJuIHN0cmVhbXMucG9wKCk7XG59XG5mdW5jdGlvbiBwaXBlbGluZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0cmVhbXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3RyZWFtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICB2YXIgY2FsbGJhY2sgPSBwb3BDYWxsYmFjayhzdHJlYW1zKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyZWFtc1swXSkpIHN0cmVhbXMgPSBzdHJlYW1zWzBdO1xuICBpZiAoc3RyZWFtcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ3N0cmVhbXMnKTtcbiAgfVxuICB2YXIgZXJyb3I7XG4gIHZhciBkZXN0cm95cyA9IHN0cmVhbXMubWFwKGZ1bmN0aW9uIChzdHJlYW0sIGkpIHtcbiAgICB2YXIgcmVhZGluZyA9IGkgPCBzdHJlYW1zLmxlbmd0aCAtIDE7XG4gICAgdmFyIHdyaXRpbmcgPSBpID4gMDtcbiAgICByZXR1cm4gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gICAgICBpZiAoZXJyKSBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgaWYgKHJlYWRpbmcpIHJldHVybjtcbiAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gc3RyZWFtcy5yZWR1Y2UocGlwZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHBpcGVsaW5lOyIsICJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5pZiAocHJvY2Vzcy5lbnYuUkVBREFCTEVfU1RSRUFNID09PSAnZGlzYWJsZScgJiYgU3RyZWFtKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gU3RyZWFtLlJlYWRhYmxlO1xuICBPYmplY3QuYXNzaWduKG1vZHVsZS5leHBvcnRzLCBTdHJlYW0pO1xuICBtb2R1bGUuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW07XG59IGVsc2Uge1xuICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG4gIGV4cG9ydHMuU3RyZWFtID0gU3RyZWFtIHx8IGV4cG9ydHM7XG4gIGV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuICBleHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuICBleHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4gIGV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbiAgZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiAgZXhwb3J0cy5maW5pc2hlZCA9IHJlcXVpcmUoJy4vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcycpO1xuICBleHBvcnRzLnBpcGVsaW5lID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcycpO1xufVxuIiwgIi8qKlxuICogQ29udGFpbnMgYWxsIGNvbmZpZ3VyZWQgYWRhcHRlcnMgZm9yIHRoZSBnaXZlbiBlbnZpcm9ubWVudC5cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbnZhciBhZGFwdGVycyA9IFtdO1xuXG4vKipcbiAqIENvbnRhaW5zIGFsbCBtb2RpZmllciBmdW5jdGlvbnMuXG4gKlxuICogQHR5cHMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG52YXIgbW9kaWZpZXJzID0gW107XG5cbi8qKlxuICogT3VyIGRlZmF1bHQgbG9nZ2VyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIGxvZ2dlciA9IGZ1bmN0aW9uIGRldm51bGwoKSB7fTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIG5ldyBhZGFwdGVyIHRoYXQgd2lsbCB1c2VkIHRvIGZpbmQgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFkYXB0ZXIgQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIHRoZSBwb3NzaWJsZSBlbnYuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSW5kaWNhdGlvbiBvZiBhIHN1Y2Nlc3NmdWwgYWRkLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2UoYWRhcHRlcikge1xuICBpZiAofmFkYXB0ZXJzLmluZGV4T2YoYWRhcHRlcikpIHJldHVybiBmYWxzZTtcblxuICBhZGFwdGVycy5wdXNoKGFkYXB0ZXIpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBBc3NpZ24gYSBuZXcgbG9nIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b20gVGhlIGxvZyBtZXRob2QuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNldChjdXN0b20pIHtcbiAgbG9nZ2VyID0gY3VzdG9tO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBuYW1lc3BhY2UgaXMgYWxsb3dlZCBieSBhbnkgb2Ygb3VyIGFkYXB0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSB0aGF0IG5lZWRzIHRvIGJlIGVuYWJsZWRcbiAqIEByZXR1cm5zIHtCb29sZWFufFByb21pc2V9IEluZGljYXRpb24gaWYgdGhlIG5hbWVzcGFjZSBpcyBlbmFibGVkIGJ5IG91ciBhZGFwdGVycy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW5hYmxlZChuYW1lc3BhY2UpIHtcbiAgdmFyIGFzeW5jID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGFwdGVycy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhZGFwdGVyc1tpXS5hc3luYykge1xuICAgICAgYXN5bmMucHVzaChhZGFwdGVyc1tpXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoYWRhcHRlcnNbaV0obmFtZXNwYWNlKSkgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWFzeW5jLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vXG4gIC8vIE5vdyB0aGF0IHdlIGtub3cgdGhhdCB3ZSBBc3luYyBmdW5jdGlvbnMsIHdlIGtub3cgd2UgcnVuIGluIGFuIEVTNlxuICAvLyBlbnZpcm9ubWVudCBhbmQgY2FuIHVzZSBhbGwgdGhlIEFQSSdzIHRoYXQgdGhleSBvZmZlciwgaW4gdGhpcyBjYXNlXG4gIC8vIHdlIHdhbnQgdG8gcmV0dXJuIGEgUHJvbWlzZSBzbyB0aGF0IHdlIGNhbiBgYXdhaXRgIGluIFJlYWN0LU5hdGl2ZVxuICAvLyBmb3IgYW4gYXN5bmMgYWRhcHRlci5cbiAgLy9cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIHBpbmt5KHJlc29sdmUpIHtcbiAgICBQcm9taXNlLmFsbChcbiAgICAgIGFzeW5jLm1hcChmdW5jdGlvbiBwcmViaW5kKGZuKSB7XG4gICAgICAgIHJldHVybiBmbihuYW1lc3BhY2UpO1xuICAgICAgfSlcbiAgICApLnRoZW4oZnVuY3Rpb24gcmVzb2x2ZWQodmFsdWVzKSB7XG4gICAgICByZXNvbHZlKHZhbHVlcy5zb21lKEJvb2xlYW4pKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IG1lc3NhZ2UgbW9kaWZpZXIgdG8gdGhlIGRlYnVnZ2VyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE1vZGlmaWNhdGlvbiBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJbmRpY2F0aW9uIG9mIGEgc3VjY2Vzc2Z1bCBhZGQuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIG1vZGlmeShmbikge1xuICBpZiAofm1vZGlmaWVycy5pbmRleE9mKGZuKSkgcmV0dXJuIGZhbHNlO1xuXG4gIG1vZGlmaWVycy5wdXNoKGZuKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogV3JpdGUgZGF0YSB0byB0aGUgc3VwcGxpZWQgbG9nZ2VyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhIE1ldGEgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxvZy5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQXJndW1lbnRzIGZvciBjb25zb2xlLmxvZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gd3JpdGUoKSB7XG4gIGxvZ2dlci5hcHBseShsb2dnZXIsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogUHJvY2VzcyB0aGUgbWVzc2FnZSB3aXRoIHRoZSBtb2RpZmllcnMuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBiZSB0cmFuc2Zvcm1lZCBieSBtb2RpZmVycy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRyYW5zZm9ybWVkIG1lc3NhZ2UuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3MobWVzc2FnZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgIG1lc3NhZ2UgPSBtb2RpZmllcnNbaV0uYXBwbHkobW9kaWZpZXJzW2ldLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5cbi8qKlxuICogSW50cm9kdWNlIG9wdGlvbnMgdG8gdGhlIGxvZ2dlciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUHJvcGVydGllcyB0byBpbnRyb2R1Y2Ugb24gZm4uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSBwYXNzZWQgZnVuY3Rpb25cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaW50cm9kdWNlKGZuLCBvcHRpb25zKSB7XG4gIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9wdGlvbnMsIGtleSkpIHtcbiAgICAgIGZuW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIE5vcGUsIHdlJ3JlIG5vdCBhbGxvd2VkIHRvIHdyaXRlIG1lc3NhZ2VzLlxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufSBmYWxzZVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBub3BlKG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5lbmFibGVkID0gZmFsc2U7XG4gIG9wdGlvbnMubW9kaWZ5ID0gbW9kaWZ5O1xuICBvcHRpb25zLnNldCA9IHNldDtcbiAgb3B0aW9ucy51c2UgPSB1c2U7XG5cbiAgcmV0dXJuIGludHJvZHVjZShmdW5jdGlvbiBkaWFnbm9wZXMoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBZZXAsIHdlJ3JlIGFsbG93ZWQgdG8gd3JpdGUgZGVidWcgbWVzc2FnZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBwcm9jZXNzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgZnVuY3Rpb24gdGhhdCBkb2VzIHRoZSBsb2dnaW5nLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB5ZXAob3B0aW9ucykge1xuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGFjdHVhbCBkZWJ1ZyBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGluZGljYXRpb24gdGhhdCB3ZSdyZSBsb2dnaW5nLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBmdW5jdGlvbiBkaWFnbm9zdGljcygpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICB3cml0ZS5jYWxsKHdyaXRlLCBvcHRpb25zLCBwcm9jZXNzKGFyZ3MsIG9wdGlvbnMpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIG9wdGlvbnMuZW5hYmxlZCA9IHRydWU7XG4gIG9wdGlvbnMubW9kaWZ5ID0gbW9kaWZ5O1xuICBvcHRpb25zLnNldCA9IHNldDtcbiAgb3B0aW9ucy51c2UgPSB1c2U7XG5cbiAgcmV0dXJuIGludHJvZHVjZShkaWFnbm9zdGljcywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogU2ltcGxlIGhlbHBlciBmdW5jdGlvbiB0byBpbnRyb2R1Y2UgdmFyaW91cyBvZiBoZWxwZXIgbWV0aG9kcyB0byBvdXIgZ2l2ZW5cbiAqIGRpYWdub3N0aWNzIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpYWdub3N0aWNzIFRoZSBkaWFnbm9zdGljcyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gZGlhZ25vc3RpY3NcbiAqIEBwdWJsaWNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoZGlhZ25vc3RpY3MpIHtcbiAgZGlhZ25vc3RpY3MuaW50cm9kdWNlID0gaW50cm9kdWNlO1xuICBkaWFnbm9zdGljcy5lbmFibGVkID0gZW5hYmxlZDtcbiAgZGlhZ25vc3RpY3MucHJvY2VzcyA9IHByb2Nlc3M7XG4gIGRpYWdub3N0aWNzLm1vZGlmeSA9IG1vZGlmeTtcbiAgZGlhZ25vc3RpY3Mud3JpdGUgPSB3cml0ZTtcbiAgZGlhZ25vc3RpY3Mubm9wZSA9IG5vcGU7XG4gIGRpYWdub3N0aWNzLnllcCA9IHllcDtcbiAgZGlhZ25vc3RpY3Muc2V0ID0gc2V0O1xuICBkaWFnbm9zdGljcy51c2UgPSB1c2U7XG5cbiAgcmV0dXJuIGRpYWdub3N0aWNzO1xufVxuIiwgInZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9kaWFnbm9zdGljcycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBkaWFnbm9zdGljcyBsb2dnZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIGl0IHNob3VsZCBlbmFibGUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSBsb2dnZXIuXG4gKiBAcHVibGljXG4gKi9cbnZhciBkaWFnbm9zdGljcyA9IGNyZWF0ZShmdW5jdGlvbiBwcm9kKG5hbWVzcGFjZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIG9wdGlvbnMucHJvZCA9IHRydWU7XG4gIG9wdGlvbnMuZGV2ID0gZmFsc2U7XG5cbiAgaWYgKCEob3B0aW9ucy5mb3JjZSB8fCBwcm9kLmZvcmNlKSkgcmV0dXJuIHByb2Qubm9wZShvcHRpb25zKTtcbiAgcmV0dXJuIHByb2QueWVwKG9wdGlvbnMpO1xufSk7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIGRpYWdub3N0aWNzIGxvZ2dlci5cbi8vXG5tb2R1bGUuZXhwb3J0cyA9IGRpYWdub3N0aWNzO1xuIiwgIid1c2Ugc3RyaWN0J1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxyXG5cdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcclxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxyXG5cdFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxyXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxyXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcclxuXHRcImJsYWNrXCI6IFswLCAwLCAwXSxcclxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcclxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXHJcblx0XCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxyXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcclxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXHJcblx0XCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXHJcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXHJcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXHJcblx0XCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcclxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcclxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcclxuXHRcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcclxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxyXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcclxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXHJcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXHJcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxyXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcclxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXHJcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXHJcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxyXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcclxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxyXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcclxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcclxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXHJcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXHJcblx0XCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcclxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXHJcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcclxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxyXG5cdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxyXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcclxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXHJcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcclxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcclxuXHRcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcclxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXHJcblx0XCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcclxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxyXG5cdFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXHJcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcclxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXHJcblx0XCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXHJcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXHJcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXHJcblx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcclxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxyXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcclxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXHJcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcclxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXHJcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXHJcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXHJcblx0XCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcclxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcclxuXHRcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXHJcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxyXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxyXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxyXG5cdFwibGltZVwiOiBbMCwgMjU1LCAwXSxcclxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxyXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxyXG5cdFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxyXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXHJcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxyXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxyXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcclxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxyXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcclxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXHJcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXHJcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXHJcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcclxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXHJcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxyXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxyXG5cdFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxyXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcclxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxyXG5cdFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcclxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcclxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxyXG5cdFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcclxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXHJcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcclxuXHRcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXHJcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcclxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxyXG5cdFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXHJcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxyXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcclxuXHRcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxyXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXHJcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcclxuXHRcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxyXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcclxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcclxuXHRcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXHJcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXHJcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxyXG5cdFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcclxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXHJcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxyXG5cdFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxyXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXHJcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxyXG5cdFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXHJcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXHJcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxyXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcclxuXHRcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcclxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXHJcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXHJcblx0XCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcclxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxyXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxyXG5cdFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcclxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcclxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcclxuXHRcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxyXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXHJcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxyXG59O1xyXG4iLCAibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FycmF5aXNoKG9iaikge1xuXHRpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiBvYmogaW5zdGFuY2VvZiBBcnJheSB8fCBBcnJheS5pc0FycmF5KG9iaikgfHxcblx0XHQob2JqLmxlbmd0aCA+PSAwICYmIChvYmouc3BsaWNlIGluc3RhbmNlb2YgRnVuY3Rpb24gfHxcblx0XHRcdChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgKG9iai5sZW5ndGggLSAxKSkgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdTdHJpbmcnKSkpO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBpc0FycmF5aXNoID0gcmVxdWlyZSgnaXMtYXJyYXlpc2gnKTtcblxudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbnZhciBzd2l6emxlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzd2l6emxlKGFyZ3MpIHtcblx0dmFyIHJlc3VsdHMgPSBbXTtcblxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHZhciBhcmcgPSBhcmdzW2ldO1xuXG5cdFx0aWYgKGlzQXJyYXlpc2goYXJnKSkge1xuXHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vamF2YXNjcmlwdC1hcnJheS1jb25jYXQtdnMtcHVzaC85OFxuXHRcdFx0cmVzdWx0cyA9IGNvbmNhdC5jYWxsKHJlc3VsdHMsIHNsaWNlLmNhbGwoYXJnKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdHMucHVzaChhcmcpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuc3dpenpsZS53cmFwID0gZnVuY3Rpb24gKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGZuKHN3aXp6bGUoYXJndW1lbnRzKSk7XG5cdH07XG59O1xuIiwgIi8qIE1JVCBsaWNlbnNlICovXG52YXIgY29sb3JOYW1lcyA9IHJlcXVpcmUoJ2NvbG9yLW5hbWUnKTtcbnZhciBzd2l6emxlID0gcmVxdWlyZSgnc2ltcGxlLXN3aXp6bGUnKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIHJldmVyc2VOYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbi8vIGNyZWF0ZSBhIGxpc3Qgb2YgcmV2ZXJzZSBjb2xvciBuYW1lc1xuZm9yICh2YXIgbmFtZSBpbiBjb2xvck5hbWVzKSB7XG5cdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbG9yTmFtZXMsIG5hbWUpKSB7XG5cdFx0cmV2ZXJzZU5hbWVzW2NvbG9yTmFtZXNbbmFtZV1dID0gbmFtZTtcblx0fVxufVxuXG52YXIgY3MgPSBtb2R1bGUuZXhwb3J0cyA9IHtcblx0dG86IHt9LFxuXHRnZXQ6IHt9XG59O1xuXG5jcy5nZXQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdHZhciBwcmVmaXggPSBzdHJpbmcuc3Vic3RyaW5nKDAsIDMpLnRvTG93ZXJDYXNlKCk7XG5cdHZhciB2YWw7XG5cdHZhciBtb2RlbDtcblx0c3dpdGNoIChwcmVmaXgpIHtcblx0XHRjYXNlICdoc2wnOlxuXHRcdFx0dmFsID0gY3MuZ2V0LmhzbChzdHJpbmcpO1xuXHRcdFx0bW9kZWwgPSAnaHNsJztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2h3Yic6XG5cdFx0XHR2YWwgPSBjcy5nZXQuaHdiKHN0cmluZyk7XG5cdFx0XHRtb2RlbCA9ICdod2InO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHZhbCA9IGNzLmdldC5yZ2Ioc3RyaW5nKTtcblx0XHRcdG1vZGVsID0gJ3JnYic7XG5cdFx0XHRicmVhaztcblx0fVxuXG5cdGlmICghdmFsKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4ge21vZGVsOiBtb2RlbCwgdmFsdWU6IHZhbH07XG59O1xuXG5jcy5nZXQucmdiID0gZnVuY3Rpb24gKHN0cmluZykge1xuXHRpZiAoIXN0cmluZykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGFiYnIgPSAvXiMoW2EtZjAtOV17Myw0fSkkL2k7XG5cdHZhciBoZXggPSAvXiMoW2EtZjAtOV17Nn0pKFthLWYwLTldezJ9KT8kL2k7XG5cdHZhciByZ2JhID0gL15yZ2JhP1xcKFxccyooWystXT9cXGQrKSg/PVtcXHMsXSlcXHMqKD86LFxccyopPyhbKy1dP1xcZCspKD89W1xccyxdKVxccyooPzosXFxzKik/KFsrLV0/XFxkKylcXHMqKD86Wyx8XFwvXVxccyooWystXT9bXFxkXFwuXSspKCU/KVxccyopP1xcKSQvO1xuXHR2YXIgcGVyID0gL15yZ2JhP1xcKFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKiw/XFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqLD9cXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyooPzpbLHxcXC9dXFxzKihbKy1dP1tcXGRcXC5dKykoJT8pXFxzKik/XFwpJC87XG5cdHZhciBrZXl3b3JkID0gL14oXFx3KykkLztcblxuXHR2YXIgcmdiID0gWzAsIDAsIDAsIDFdO1xuXHR2YXIgbWF0Y2g7XG5cdHZhciBpO1xuXHR2YXIgaGV4QWxwaGE7XG5cblx0aWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGhleCkpIHtcblx0XHRoZXhBbHBoYSA9IG1hdGNoWzJdO1xuXHRcdG1hdGNoID0gbWF0Y2hbMV07XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHQvLyBodHRwczovL2pzcGVyZi5jb20vc2xpY2UtdnMtc3Vic3RyLXZzLXN1YnN0cmluZy1tZXRob2RzLWxvbmctc3RyaW5nLzE5XG5cdFx0XHR2YXIgaTIgPSBpICogMjtcblx0XHRcdHJnYltpXSA9IHBhcnNlSW50KG1hdGNoLnNsaWNlKGkyLCBpMiArIDIpLCAxNik7XG5cdFx0fVxuXG5cdFx0aWYgKGhleEFscGhhKSB7XG5cdFx0XHRyZ2JbM10gPSBwYXJzZUludChoZXhBbHBoYSwgMTYpIC8gMjU1O1xuXHRcdH1cblx0fSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChhYmJyKSkge1xuXHRcdG1hdGNoID0gbWF0Y2hbMV07XG5cdFx0aGV4QWxwaGEgPSBtYXRjaFszXTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdHJnYltpXSA9IHBhcnNlSW50KG1hdGNoW2ldICsgbWF0Y2hbaV0sIDE2KTtcblx0XHR9XG5cblx0XHRpZiAoaGV4QWxwaGEpIHtcblx0XHRcdHJnYlszXSA9IHBhcnNlSW50KGhleEFscGhhICsgaGV4QWxwaGEsIDE2KSAvIDI1NTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocmdiYSkpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpICsgMV0sIDApO1xuXHRcdH1cblxuXHRcdGlmIChtYXRjaFs0XSkge1xuXHRcdFx0aWYgKG1hdGNoWzVdKSB7XG5cdFx0XHRcdHJnYlszXSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pICogMC4wMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJnYlszXSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChwZXIpKSB7XG5cdFx0Zm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0cmdiW2ldID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KG1hdGNoW2kgKyAxXSkgKiAyLjU1KTtcblx0XHR9XG5cblx0XHRpZiAobWF0Y2hbNF0pIHtcblx0XHRcdGlmIChtYXRjaFs1XSkge1xuXHRcdFx0XHRyZ2JbM10gPSBwYXJzZUZsb2F0KG1hdGNoWzRdKSAqIDAuMDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZ2JbM10gPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goa2V5d29yZCkpIHtcblx0XHRpZiAobWF0Y2hbMV0gPT09ICd0cmFuc3BhcmVudCcpIHtcblx0XHRcdHJldHVybiBbMCwgMCwgMCwgMF07XG5cdFx0fVxuXG5cdFx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbG9yTmFtZXMsIG1hdGNoWzFdKSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmdiID0gY29sb3JOYW1lc1ttYXRjaFsxXV07XG5cdFx0cmdiWzNdID0gMTtcblxuXHRcdHJldHVybiByZ2I7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0cmdiW2ldID0gY2xhbXAocmdiW2ldLCAwLCAyNTUpO1xuXHR9XG5cdHJnYlszXSA9IGNsYW1wKHJnYlszXSwgMCwgMSk7XG5cblx0cmV0dXJuIHJnYjtcbn07XG5cbmNzLmdldC5oc2wgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdGlmICghc3RyaW5nKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgaHNsID0gL15oc2xhP1xcKFxccyooWystXT8oPzpcXGR7MCwzfVxcLik/XFxkKykoPzpkZWcpP1xccyosP1xccyooWystXT9bXFxkXFwuXSspJVxccyosP1xccyooWystXT9bXFxkXFwuXSspJVxccyooPzpbLHxcXC9dXFxzKihbKy1dPyg/PVxcLlxcZHxcXGQpKD86MHxbMS05XVxcZCopPyg/OlxcLlxcZCopPyg/OltlRV1bKy1dP1xcZCspPylcXHMqKT9cXCkkLztcblx0dmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKGhzbCk7XG5cblx0aWYgKG1hdGNoKSB7XG5cdFx0dmFyIGFscGhhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG5cdFx0dmFyIGggPSAoKHBhcnNlRmxvYXQobWF0Y2hbMV0pICUgMzYwKSArIDM2MCkgJSAzNjA7XG5cdFx0dmFyIHMgPSBjbGFtcChwYXJzZUZsb2F0KG1hdGNoWzJdKSwgMCwgMTAwKTtcblx0XHR2YXIgbCA9IGNsYW1wKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApO1xuXHRcdHZhciBhID0gY2xhbXAoaXNOYU4oYWxwaGEpID8gMSA6IGFscGhhLCAwLCAxKTtcblxuXHRcdHJldHVybiBbaCwgcywgbCwgYV07XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn07XG5cbmNzLmdldC5od2IgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdGlmICghc3RyaW5nKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgaHdiID0gL15od2JcXChcXHMqKFsrLV0/XFxkezAsM30oPzpcXC5cXGQrKT8pKD86ZGVnKT9cXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKig/OixcXHMqKFsrLV0/KD89XFwuXFxkfFxcZCkoPzowfFsxLTldXFxkKik/KD86XFwuXFxkKik/KD86W2VFXVsrLV0/XFxkKyk/KVxccyopP1xcKSQvO1xuXHR2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHdiKTtcblxuXHRpZiAobWF0Y2gpIHtcblx0XHR2YXIgYWxwaGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcblx0XHR2YXIgaCA9ICgocGFyc2VGbG9hdChtYXRjaFsxXSkgJSAzNjApICsgMzYwKSAlIDM2MDtcblx0XHR2YXIgdyA9IGNsYW1wKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApO1xuXHRcdHZhciBiID0gY2xhbXAocGFyc2VGbG9hdChtYXRjaFszXSksIDAsIDEwMCk7XG5cdFx0dmFyIGEgPSBjbGFtcChpc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xuXHRcdHJldHVybiBbaCwgdywgYiwgYV07XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn07XG5cbmNzLnRvLmhleCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHJnYmEgPSBzd2l6emxlKGFyZ3VtZW50cyk7XG5cblx0cmV0dXJuIChcblx0XHQnIycgK1xuXHRcdGhleERvdWJsZShyZ2JhWzBdKSArXG5cdFx0aGV4RG91YmxlKHJnYmFbMV0pICtcblx0XHRoZXhEb3VibGUocmdiYVsyXSkgK1xuXHRcdChyZ2JhWzNdIDwgMVxuXHRcdFx0PyAoaGV4RG91YmxlKE1hdGgucm91bmQocmdiYVszXSAqIDI1NSkpKVxuXHRcdFx0OiAnJylcblx0KTtcbn07XG5cbmNzLnRvLnJnYiA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHJnYmEgPSBzd2l6emxlKGFyZ3VtZW50cyk7XG5cblx0cmV0dXJuIHJnYmEubGVuZ3RoIDwgNCB8fCByZ2JhWzNdID09PSAxXG5cdFx0PyAncmdiKCcgKyBNYXRoLnJvdW5kKHJnYmFbMF0pICsgJywgJyArIE1hdGgucm91bmQocmdiYVsxXSkgKyAnLCAnICsgTWF0aC5yb3VuZChyZ2JhWzJdKSArICcpJ1xuXHRcdDogJ3JnYmEoJyArIE1hdGgucm91bmQocmdiYVswXSkgKyAnLCAnICsgTWF0aC5yb3VuZChyZ2JhWzFdKSArICcsICcgKyBNYXRoLnJvdW5kKHJnYmFbMl0pICsgJywgJyArIHJnYmFbM10gKyAnKSc7XG59O1xuXG5jcy50by5yZ2IucGVyY2VudCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHJnYmEgPSBzd2l6emxlKGFyZ3VtZW50cyk7XG5cblx0dmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0gLyAyNTUgKiAxMDApO1xuXHR2YXIgZyA9IE1hdGgucm91bmQocmdiYVsxXSAvIDI1NSAqIDEwMCk7XG5cdHZhciBiID0gTWF0aC5yb3VuZChyZ2JhWzJdIC8gMjU1ICogMTAwKTtcblxuXHRyZXR1cm4gcmdiYS5sZW5ndGggPCA0IHx8IHJnYmFbM10gPT09IDFcblx0XHQ/ICdyZ2IoJyArIHIgKyAnJSwgJyArIGcgKyAnJSwgJyArIGIgKyAnJSknXG5cdFx0OiAncmdiYSgnICsgciArICclLCAnICsgZyArICclLCAnICsgYiArICclLCAnICsgcmdiYVszXSArICcpJztcbn07XG5cbmNzLnRvLmhzbCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGhzbGEgPSBzd2l6emxlKGFyZ3VtZW50cyk7XG5cdHJldHVybiBoc2xhLmxlbmd0aCA8IDQgfHwgaHNsYVszXSA9PT0gMVxuXHRcdD8gJ2hzbCgnICsgaHNsYVswXSArICcsICcgKyBoc2xhWzFdICsgJyUsICcgKyBoc2xhWzJdICsgJyUpJ1xuXHRcdDogJ2hzbGEoJyArIGhzbGFbMF0gKyAnLCAnICsgaHNsYVsxXSArICclLCAnICsgaHNsYVsyXSArICclLCAnICsgaHNsYVszXSArICcpJztcbn07XG5cbi8vIGh3YiBpcyBhIGJpdCBkaWZmZXJlbnQgdGhhbiByZ2IoYSkgJiBoc2woYSkgc2luY2UgdGhlcmUgaXMgbm8gYWxwaGEgc3BlY2lmaWMgc3ludGF4XG4vLyAoaHdiIGhhdmUgYWxwaGEgb3B0aW9uYWwgJiAxIGlzIGRlZmF1bHQgdmFsdWUpXG5jcy50by5od2IgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBod2JhID0gc3dpenpsZShhcmd1bWVudHMpO1xuXG5cdHZhciBhID0gJyc7XG5cdGlmIChod2JhLmxlbmd0aCA+PSA0ICYmIGh3YmFbM10gIT09IDEpIHtcblx0XHRhID0gJywgJyArIGh3YmFbM107XG5cdH1cblxuXHRyZXR1cm4gJ2h3YignICsgaHdiYVswXSArICcsICcgKyBod2JhWzFdICsgJyUsICcgKyBod2JhWzJdICsgJyUnICsgYSArICcpJztcbn07XG5cbmNzLnRvLmtleXdvcmQgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHJldHVybiByZXZlcnNlTmFtZXNbcmdiLnNsaWNlKDAsIDMpXTtcbn07XG5cbi8vIGhlbHBlcnNcbmZ1bmN0aW9uIGNsYW1wKG51bSwgbWluLCBtYXgpIHtcblx0cmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgbnVtKSwgbWF4KTtcbn1cblxuZnVuY3Rpb24gaGV4RG91YmxlKG51bSkge1xuXHR2YXIgc3RyID0gTWF0aC5yb3VuZChudW0pLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRyZXR1cm4gKHN0ci5sZW5ndGggPCAyKSA/ICcwJyArIHN0ciA6IHN0cjtcbn1cbiIsICIndXNlIHN0cmljdCdcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcclxuXHRcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNV0sXHJcblx0XCJhcXVhXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcclxuXHRcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1XSxcclxuXHRcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwXSxcclxuXHRcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXHJcblx0XCJibGFja1wiOiBbMCwgMCwgMF0sXHJcblx0XCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNV0sXHJcblx0XCJibHVlXCI6IFswLCAwLCAyNTVdLFxyXG5cdFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2XSxcclxuXHRcImJyb3duXCI6IFsxNjUsIDQyLCA0Ml0sXHJcblx0XCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxyXG5cdFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjBdLFxyXG5cdFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDBdLFxyXG5cdFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxyXG5cdFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MF0sXHJcblx0XCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzN10sXHJcblx0XCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXHJcblx0XCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MF0sXHJcblx0XCJjeWFuXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcclxuXHRcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOV0sXHJcblx0XCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTFdLFxyXG5cdFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDBdLFxyXG5cdFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcclxuXHRcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOV0sXHJcblx0XCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDddLFxyXG5cdFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxyXG5cdFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0XSxcclxuXHRcImRhcmtyZWRcIjogWzEzOSwgMCwgMF0sXHJcblx0XCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcclxuXHRcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0M10sXHJcblx0XCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOV0sXHJcblx0XCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDldLFxyXG5cdFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxyXG5cdFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0N10sXHJcblx0XCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTVdLFxyXG5cdFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NV0sXHJcblx0XCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcclxuXHRcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwXSxcclxuXHRcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNF0sXHJcblx0XCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjBdLFxyXG5cdFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NV0sXHJcblx0XCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXHJcblx0XCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMl0sXHJcblx0XCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxyXG5cdFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0N10sXHJcblx0XCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcclxuXHRcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODBdLFxyXG5cdFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5Ml0sXHJcblx0XCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxyXG5cdFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDBdLFxyXG5cdFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDBdLFxyXG5cdFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxyXG5cdFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NV0sXHJcblx0XCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwXSxcclxuXHRcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXHJcblx0XCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzBdLFxyXG5cdFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOF0sXHJcblx0XCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxyXG5cdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTBdLFxyXG5cdFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxyXG5cdFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5M10sXHJcblx0XCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXHJcblx0XCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzBdLFxyXG5cdFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwXSxcclxuXHRcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyXSxcclxuXHRcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcclxuXHRcImxpbWVcIjogWzAsIDI1NSwgMF0sXHJcblx0XCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwXSxcclxuXHRcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcclxuXHRcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcIm1hcm9vblwiOiBbMTI4LCAwLCAwXSxcclxuXHRcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxyXG5cdFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1XSxcclxuXHRcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExXSxcclxuXHRcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXHJcblx0XCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzXSxcclxuXHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOF0sXHJcblx0XCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxyXG5cdFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDRdLFxyXG5cdFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzNdLFxyXG5cdFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXHJcblx0XCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTBdLFxyXG5cdFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1XSxcclxuXHRcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcclxuXHRcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczXSxcclxuXHRcIm5hdnlcIjogWzAsIDAsIDEyOF0sXHJcblx0XCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcclxuXHRcIm9saXZlXCI6IFsxMjgsIDEyOCwgMF0sXHJcblx0XCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNV0sXHJcblx0XCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcclxuXHRcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMF0sXHJcblx0XCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTRdLFxyXG5cdFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXHJcblx0XCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTJdLFxyXG5cdFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOF0sXHJcblx0XCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcclxuXHRcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTNdLFxyXG5cdFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1XSxcclxuXHRcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXHJcblx0XCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzXSxcclxuXHRcInBsdW1cIjogWzIyMSwgMTYwLCAyMjFdLFxyXG5cdFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXHJcblx0XCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4XSxcclxuXHRcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1M10sXHJcblx0XCJyZWRcIjogWzI1NSwgMCwgMF0sXHJcblx0XCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDNdLFxyXG5cdFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjVdLFxyXG5cdFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcclxuXHRcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNF0sXHJcblx0XCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTZdLFxyXG5cdFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcclxuXHRcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4XSxcclxuXHRcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDVdLFxyXG5cdFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcclxuXHRcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzVdLFxyXG5cdFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDVdLFxyXG5cdFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwXSxcclxuXHRcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXHJcblx0XCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MF0sXHJcblx0XCJ0YW5cIjogWzIxMCwgMTgwLCAxNDBdLFxyXG5cdFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxyXG5cdFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNl0sXHJcblx0XCJ0b21hdG9cIjogWzI1NSwgOTksIDcxXSxcclxuXHRcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcclxuXHRcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOF0sXHJcblx0XCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OV0sXHJcblx0XCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXHJcblx0XCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1XSxcclxuXHRcInllbGxvd1wiOiBbMjU1LCAyNTUsIDBdLFxyXG5cdFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cclxufTtcclxuIiwgIi8qIE1JVCBsaWNlbnNlICovXG52YXIgY3NzS2V5d29yZHMgPSByZXF1aXJlKCdjb2xvci1uYW1lJyk7XG5cbi8vIE5PVEU6IGNvbnZlcnNpb25zIHNob3VsZCBvbmx5IHJldHVybiBwcmltaXRpdmUgdmFsdWVzIChpLmUuIGFycmF5cywgb3Jcbi8vICAgICAgIHZhbHVlcyB0aGF0IGdpdmUgY29ycmVjdCBgdHlwZW9mYCByZXN1bHRzKS5cbi8vICAgICAgIGRvIG5vdCB1c2UgYm94IHZhbHVlcyB0eXBlcyAoaS5lLiBOdW1iZXIoKSwgU3RyaW5nKCksIGV0Yy4pXG5cbnZhciByZXZlcnNlS2V5d29yZHMgPSB7fTtcbmZvciAodmFyIGtleSBpbiBjc3NLZXl3b3Jkcykge1xuXHRpZiAoY3NzS2V5d29yZHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdHJldmVyc2VLZXl3b3Jkc1tjc3NLZXl3b3Jkc1trZXldXSA9IGtleTtcblx0fVxufVxuXG52YXIgY29udmVydCA9IG1vZHVsZS5leHBvcnRzID0ge1xuXHRyZ2I6IHtjaGFubmVsczogMywgbGFiZWxzOiAncmdiJ30sXG5cdGhzbDoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdoc2wnfSxcblx0aHN2OiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2hzdid9LFxuXHRod2I6IHtjaGFubmVsczogMywgbGFiZWxzOiAnaHdiJ30sXG5cdGNteWs6IHtjaGFubmVsczogNCwgbGFiZWxzOiAnY215ayd9LFxuXHR4eXo6IHtjaGFubmVsczogMywgbGFiZWxzOiAneHl6J30sXG5cdGxhYjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdsYWInfSxcblx0bGNoOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2xjaCd9LFxuXHRoZXg6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2hleCddfSxcblx0a2V5d29yZDoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsna2V5d29yZCddfSxcblx0YW5zaTE2OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydhbnNpMTYnXX0sXG5cdGFuc2kyNTY6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2Fuc2kyNTYnXX0sXG5cdGhjZzoge2NoYW5uZWxzOiAzLCBsYWJlbHM6IFsnaCcsICdjJywgJ2cnXX0sXG5cdGFwcGxlOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogWydyMTYnLCAnZzE2JywgJ2IxNiddfSxcblx0Z3JheToge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnZ3JheSddfVxufTtcblxuLy8gaGlkZSAuY2hhbm5lbHMgYW5kIC5sYWJlbHMgcHJvcGVydGllc1xuZm9yICh2YXIgbW9kZWwgaW4gY29udmVydCkge1xuXHRpZiAoY29udmVydC5oYXNPd25Qcm9wZXJ0eShtb2RlbCkpIHtcblx0XHRpZiAoISgnY2hhbm5lbHMnIGluIGNvbnZlcnRbbW9kZWxdKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGNoYW5uZWxzIHByb3BlcnR5OiAnICsgbW9kZWwpO1xuXHRcdH1cblxuXHRcdGlmICghKCdsYWJlbHMnIGluIGNvbnZlcnRbbW9kZWxdKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGNoYW5uZWwgbGFiZWxzIHByb3BlcnR5OiAnICsgbW9kZWwpO1xuXHRcdH1cblxuXHRcdGlmIChjb252ZXJ0W21vZGVsXS5sYWJlbHMubGVuZ3RoICE9PSBjb252ZXJ0W21vZGVsXS5jaGFubmVscykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdjaGFubmVsIGFuZCBsYWJlbCBjb3VudHMgbWlzbWF0Y2g6ICcgKyBtb2RlbCk7XG5cdFx0fVxuXG5cdFx0dmFyIGNoYW5uZWxzID0gY29udmVydFttb2RlbF0uY2hhbm5lbHM7XG5cdFx0dmFyIGxhYmVscyA9IGNvbnZlcnRbbW9kZWxdLmxhYmVscztcblx0XHRkZWxldGUgY29udmVydFttb2RlbF0uY2hhbm5lbHM7XG5cdFx0ZGVsZXRlIGNvbnZlcnRbbW9kZWxdLmxhYmVscztcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFttb2RlbF0sICdjaGFubmVscycsIHt2YWx1ZTogY2hhbm5lbHN9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFttb2RlbF0sICdsYWJlbHMnLCB7dmFsdWU6IGxhYmVsc30pO1xuXHR9XG59XG5cbmNvbnZlcnQucmdiLmhzbCA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF0gLyAyNTU7XG5cdHZhciBnID0gcmdiWzFdIC8gMjU1O1xuXHR2YXIgYiA9IHJnYlsyXSAvIDI1NTtcblx0dmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHR2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG5cdHZhciBkZWx0YSA9IG1heCAtIG1pbjtcblx0dmFyIGg7XG5cdHZhciBzO1xuXHR2YXIgbDtcblxuXHRpZiAobWF4ID09PSBtaW4pIHtcblx0XHRoID0gMDtcblx0fSBlbHNlIGlmIChyID09PSBtYXgpIHtcblx0XHRoID0gKGcgLSBiKSAvIGRlbHRhO1xuXHR9IGVsc2UgaWYgKGcgPT09IG1heCkge1xuXHRcdGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuXHR9IGVsc2UgaWYgKGIgPT09IG1heCkge1xuXHRcdGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuXHR9XG5cblx0aCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuXHRpZiAoaCA8IDApIHtcblx0XHRoICs9IDM2MDtcblx0fVxuXG5cdGwgPSAobWluICsgbWF4KSAvIDI7XG5cblx0aWYgKG1heCA9PT0gbWluKSB7XG5cdFx0cyA9IDA7XG5cdH0gZWxzZSBpZiAobCA8PSAwLjUpIHtcblx0XHRzID0gZGVsdGEgLyAobWF4ICsgbWluKTtcblx0fSBlbHNlIHtcblx0XHRzID0gZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cdH1cblxuXHRyZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xufTtcblxuY29udmVydC5yZ2IuaHN2ID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgcmRpZjtcblx0dmFyIGdkaWY7XG5cdHZhciBiZGlmO1xuXHR2YXIgaDtcblx0dmFyIHM7XG5cblx0dmFyIHIgPSByZ2JbMF0gLyAyNTU7XG5cdHZhciBnID0gcmdiWzFdIC8gMjU1O1xuXHR2YXIgYiA9IHJnYlsyXSAvIDI1NTtcblx0dmFyIHYgPSBNYXRoLm1heChyLCBnLCBiKTtcblx0dmFyIGRpZmYgPSB2IC0gTWF0aC5taW4ociwgZywgYik7XG5cdHZhciBkaWZmYyA9IGZ1bmN0aW9uIChjKSB7XG5cdFx0cmV0dXJuICh2IC0gYykgLyA2IC8gZGlmZiArIDEgLyAyO1xuXHR9O1xuXG5cdGlmIChkaWZmID09PSAwKSB7XG5cdFx0aCA9IHMgPSAwO1xuXHR9IGVsc2Uge1xuXHRcdHMgPSBkaWZmIC8gdjtcblx0XHRyZGlmID0gZGlmZmMocik7XG5cdFx0Z2RpZiA9IGRpZmZjKGcpO1xuXHRcdGJkaWYgPSBkaWZmYyhiKTtcblxuXHRcdGlmIChyID09PSB2KSB7XG5cdFx0XHRoID0gYmRpZiAtIGdkaWY7XG5cdFx0fSBlbHNlIGlmIChnID09PSB2KSB7XG5cdFx0XHRoID0gKDEgLyAzKSArIHJkaWYgLSBiZGlmO1xuXHRcdH0gZWxzZSBpZiAoYiA9PT0gdikge1xuXHRcdFx0aCA9ICgyIC8gMykgKyBnZGlmIC0gcmRpZjtcblx0XHR9XG5cdFx0aWYgKGggPCAwKSB7XG5cdFx0XHRoICs9IDE7XG5cdFx0fSBlbHNlIGlmIChoID4gMSkge1xuXHRcdFx0aCAtPSAxO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBbXG5cdFx0aCAqIDM2MCxcblx0XHRzICogMTAwLFxuXHRcdHYgKiAxMDBcblx0XTtcbn07XG5cbmNvbnZlcnQucmdiLmh3YiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF07XG5cdHZhciBnID0gcmdiWzFdO1xuXHR2YXIgYiA9IHJnYlsyXTtcblx0dmFyIGggPSBjb252ZXJ0LnJnYi5oc2wocmdiKVswXTtcblx0dmFyIHcgPSAxIC8gMjU1ICogTWF0aC5taW4ociwgTWF0aC5taW4oZywgYikpO1xuXG5cdGIgPSAxIC0gMSAvIDI1NSAqIE1hdGgubWF4KHIsIE1hdGgubWF4KGcsIGIpKTtcblxuXHRyZXR1cm4gW2gsIHcgKiAxMDAsIGIgKiAxMDBdO1xufTtcblxuY29udmVydC5yZ2IuY215ayA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF0gLyAyNTU7XG5cdHZhciBnID0gcmdiWzFdIC8gMjU1O1xuXHR2YXIgYiA9IHJnYlsyXSAvIDI1NTtcblx0dmFyIGM7XG5cdHZhciBtO1xuXHR2YXIgeTtcblx0dmFyIGs7XG5cblx0ayA9IE1hdGgubWluKDEgLSByLCAxIC0gZywgMSAtIGIpO1xuXHRjID0gKDEgLSByIC0gaykgLyAoMSAtIGspIHx8IDA7XG5cdG0gPSAoMSAtIGcgLSBrKSAvICgxIC0gaykgfHwgMDtcblx0eSA9ICgxIC0gYiAtIGspIC8gKDEgLSBrKSB8fCAwO1xuXG5cdHJldHVybiBbYyAqIDEwMCwgbSAqIDEwMCwgeSAqIDEwMCwgayAqIDEwMF07XG59O1xuXG4vKipcbiAqIFNlZSBodHRwczovL2VuLm0ud2lraXBlZGlhLm9yZy93aWtpL0V1Y2xpZGVhbl9kaXN0YW5jZSNTcXVhcmVkX0V1Y2xpZGVhbl9kaXN0YW5jZVxuICogKi9cbmZ1bmN0aW9uIGNvbXBhcmF0aXZlRGlzdGFuY2UoeCwgeSkge1xuXHRyZXR1cm4gKFxuXHRcdE1hdGgucG93KHhbMF0gLSB5WzBdLCAyKSArXG5cdFx0TWF0aC5wb3coeFsxXSAtIHlbMV0sIDIpICtcblx0XHRNYXRoLnBvdyh4WzJdIC0geVsyXSwgMilcblx0KTtcbn1cblxuY29udmVydC5yZ2Iua2V5d29yZCA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHJldmVyc2VkID0gcmV2ZXJzZUtleXdvcmRzW3JnYl07XG5cdGlmIChyZXZlcnNlZCkge1xuXHRcdHJldHVybiByZXZlcnNlZDtcblx0fVxuXG5cdHZhciBjdXJyZW50Q2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG5cdHZhciBjdXJyZW50Q2xvc2VzdEtleXdvcmQ7XG5cblx0Zm9yICh2YXIga2V5d29yZCBpbiBjc3NLZXl3b3Jkcykge1xuXHRcdGlmIChjc3NLZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eShrZXl3b3JkKSkge1xuXHRcdFx0dmFyIHZhbHVlID0gY3NzS2V5d29yZHNba2V5d29yZF07XG5cblx0XHRcdC8vIENvbXB1dGUgY29tcGFyYXRpdmUgZGlzdGFuY2Vcblx0XHRcdHZhciBkaXN0YW5jZSA9IGNvbXBhcmF0aXZlRGlzdGFuY2UocmdiLCB2YWx1ZSk7XG5cblx0XHRcdC8vIENoZWNrIGlmIGl0cyBsZXNzLCBpZiBzbyBzZXQgYXMgY2xvc2VzdFxuXHRcdFx0aWYgKGRpc3RhbmNlIDwgY3VycmVudENsb3Nlc3REaXN0YW5jZSkge1xuXHRcdFx0XHRjdXJyZW50Q2xvc2VzdERpc3RhbmNlID0gZGlzdGFuY2U7XG5cdFx0XHRcdGN1cnJlbnRDbG9zZXN0S2V5d29yZCA9IGtleXdvcmQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGN1cnJlbnRDbG9zZXN0S2V5d29yZDtcbn07XG5cbmNvbnZlcnQua2V5d29yZC5yZ2IgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xuXHRyZXR1cm4gY3NzS2V5d29yZHNba2V5d29yZF07XG59O1xuXG5jb252ZXJ0LnJnYi54eXogPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdIC8gMjU1O1xuXHR2YXIgZyA9IHJnYlsxXSAvIDI1NTtcblx0dmFyIGIgPSByZ2JbMl0gLyAyNTU7XG5cblx0Ly8gYXNzdW1lIHNSR0Jcblx0ciA9IHIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChyICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKHIgLyAxMi45Mik7XG5cdGcgPSBnID4gMC4wNDA0NSA/IE1hdGgucG93KCgoZyArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChnIC8gMTIuOTIpO1xuXHRiID0gYiA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGIgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoYiAvIDEyLjkyKTtcblxuXHR2YXIgeCA9IChyICogMC40MTI0KSArIChnICogMC4zNTc2KSArIChiICogMC4xODA1KTtcblx0dmFyIHkgPSAociAqIDAuMjEyNikgKyAoZyAqIDAuNzE1MikgKyAoYiAqIDAuMDcyMik7XG5cdHZhciB6ID0gKHIgKiAwLjAxOTMpICsgKGcgKiAwLjExOTIpICsgKGIgKiAwLjk1MDUpO1xuXG5cdHJldHVybiBbeCAqIDEwMCwgeSAqIDEwMCwgeiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LnJnYi5sYWIgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciB4eXogPSBjb252ZXJ0LnJnYi54eXoocmdiKTtcblx0dmFyIHggPSB4eXpbMF07XG5cdHZhciB5ID0geHl6WzFdO1xuXHR2YXIgeiA9IHh5elsyXTtcblx0dmFyIGw7XG5cdHZhciBhO1xuXHR2YXIgYjtcblxuXHR4IC89IDk1LjA0Nztcblx0eSAvPSAxMDA7XG5cdHogLz0gMTA4Ljg4MztcblxuXHR4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMSAvIDMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuXHR5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMSAvIDMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuXHR6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMSAvIDMpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG5cdGwgPSAoMTE2ICogeSkgLSAxNjtcblx0YSA9IDUwMCAqICh4IC0geSk7XG5cdGIgPSAyMDAgKiAoeSAtIHopO1xuXG5cdHJldHVybiBbbCwgYSwgYl07XG59O1xuXG5jb252ZXJ0LmhzbC5yZ2IgPSBmdW5jdGlvbiAoaHNsKSB7XG5cdHZhciBoID0gaHNsWzBdIC8gMzYwO1xuXHR2YXIgcyA9IGhzbFsxXSAvIDEwMDtcblx0dmFyIGwgPSBoc2xbMl0gLyAxMDA7XG5cdHZhciB0MTtcblx0dmFyIHQyO1xuXHR2YXIgdDM7XG5cdHZhciByZ2I7XG5cdHZhciB2YWw7XG5cblx0aWYgKHMgPT09IDApIHtcblx0XHR2YWwgPSBsICogMjU1O1xuXHRcdHJldHVybiBbdmFsLCB2YWwsIHZhbF07XG5cdH1cblxuXHRpZiAobCA8IDAuNSkge1xuXHRcdHQyID0gbCAqICgxICsgcyk7XG5cdH0gZWxzZSB7XG5cdFx0dDIgPSBsICsgcyAtIGwgKiBzO1xuXHR9XG5cblx0dDEgPSAyICogbCAtIHQyO1xuXG5cdHJnYiA9IFswLCAwLCAwXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHR0MyA9IGggKyAxIC8gMyAqIC0oaSAtIDEpO1xuXHRcdGlmICh0MyA8IDApIHtcblx0XHRcdHQzKys7XG5cdFx0fVxuXHRcdGlmICh0MyA+IDEpIHtcblx0XHRcdHQzLS07XG5cdFx0fVxuXG5cdFx0aWYgKDYgKiB0MyA8IDEpIHtcblx0XHRcdHZhbCA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzO1xuXHRcdH0gZWxzZSBpZiAoMiAqIHQzIDwgMSkge1xuXHRcdFx0dmFsID0gdDI7XG5cdFx0fSBlbHNlIGlmICgzICogdDMgPCAyKSB7XG5cdFx0XHR2YWwgPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzKSAqIDY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbCA9IHQxO1xuXHRcdH1cblxuXHRcdHJnYltpXSA9IHZhbCAqIDI1NTtcblx0fVxuXG5cdHJldHVybiByZ2I7XG59O1xuXG5jb252ZXJ0LmhzbC5oc3YgPSBmdW5jdGlvbiAoaHNsKSB7XG5cdHZhciBoID0gaHNsWzBdO1xuXHR2YXIgcyA9IGhzbFsxXSAvIDEwMDtcblx0dmFyIGwgPSBoc2xbMl0gLyAxMDA7XG5cdHZhciBzbWluID0gcztcblx0dmFyIGxtaW4gPSBNYXRoLm1heChsLCAwLjAxKTtcblx0dmFyIHN2O1xuXHR2YXIgdjtcblxuXHRsICo9IDI7XG5cdHMgKj0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG5cdHNtaW4gKj0gbG1pbiA8PSAxID8gbG1pbiA6IDIgLSBsbWluO1xuXHR2ID0gKGwgKyBzKSAvIDI7XG5cdHN2ID0gbCA9PT0gMCA/ICgyICogc21pbikgLyAobG1pbiArIHNtaW4pIDogKDIgKiBzKSAvIChsICsgcyk7XG5cblx0cmV0dXJuIFtoLCBzdiAqIDEwMCwgdiAqIDEwMF07XG59O1xuXG5jb252ZXJ0Lmhzdi5yZ2IgPSBmdW5jdGlvbiAoaHN2KSB7XG5cdHZhciBoID0gaHN2WzBdIC8gNjA7XG5cdHZhciBzID0gaHN2WzFdIC8gMTAwO1xuXHR2YXIgdiA9IGhzdlsyXSAvIDEwMDtcblx0dmFyIGhpID0gTWF0aC5mbG9vcihoKSAlIDY7XG5cblx0dmFyIGYgPSBoIC0gTWF0aC5mbG9vcihoKTtcblx0dmFyIHAgPSAyNTUgKiB2ICogKDEgLSBzKTtcblx0dmFyIHEgPSAyNTUgKiB2ICogKDEgLSAocyAqIGYpKTtcblx0dmFyIHQgPSAyNTUgKiB2ICogKDEgLSAocyAqICgxIC0gZikpKTtcblx0diAqPSAyNTU7XG5cblx0c3dpdGNoIChoaSkge1xuXHRcdGNhc2UgMDpcblx0XHRcdHJldHVybiBbdiwgdCwgcF07XG5cdFx0Y2FzZSAxOlxuXHRcdFx0cmV0dXJuIFtxLCB2LCBwXTtcblx0XHRjYXNlIDI6XG5cdFx0XHRyZXR1cm4gW3AsIHYsIHRdO1xuXHRcdGNhc2UgMzpcblx0XHRcdHJldHVybiBbcCwgcSwgdl07XG5cdFx0Y2FzZSA0OlxuXHRcdFx0cmV0dXJuIFt0LCBwLCB2XTtcblx0XHRjYXNlIDU6XG5cdFx0XHRyZXR1cm4gW3YsIHAsIHFdO1xuXHR9XG59O1xuXG5jb252ZXJ0Lmhzdi5oc2wgPSBmdW5jdGlvbiAoaHN2KSB7XG5cdHZhciBoID0gaHN2WzBdO1xuXHR2YXIgcyA9IGhzdlsxXSAvIDEwMDtcblx0dmFyIHYgPSBoc3ZbMl0gLyAxMDA7XG5cdHZhciB2bWluID0gTWF0aC5tYXgodiwgMC4wMSk7XG5cdHZhciBsbWluO1xuXHR2YXIgc2w7XG5cdHZhciBsO1xuXG5cdGwgPSAoMiAtIHMpICogdjtcblx0bG1pbiA9ICgyIC0gcykgKiB2bWluO1xuXHRzbCA9IHMgKiB2bWluO1xuXHRzbCAvPSAobG1pbiA8PSAxKSA/IGxtaW4gOiAyIC0gbG1pbjtcblx0c2wgPSBzbCB8fCAwO1xuXHRsIC89IDI7XG5cblx0cmV0dXJuIFtoLCBzbCAqIDEwMCwgbCAqIDEwMF07XG59O1xuXG4vLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3MtY29sb3IvI2h3Yi10by1yZ2JcbmNvbnZlcnQuaHdiLnJnYiA9IGZ1bmN0aW9uIChod2IpIHtcblx0dmFyIGggPSBod2JbMF0gLyAzNjA7XG5cdHZhciB3aCA9IGh3YlsxXSAvIDEwMDtcblx0dmFyIGJsID0gaHdiWzJdIC8gMTAwO1xuXHR2YXIgcmF0aW8gPSB3aCArIGJsO1xuXHR2YXIgaTtcblx0dmFyIHY7XG5cdHZhciBmO1xuXHR2YXIgbjtcblxuXHQvLyB3aCArIGJsIGNhbnQgYmUgPiAxXG5cdGlmIChyYXRpbyA+IDEpIHtcblx0XHR3aCAvPSByYXRpbztcblx0XHRibCAvPSByYXRpbztcblx0fVxuXG5cdGkgPSBNYXRoLmZsb29yKDYgKiBoKTtcblx0diA9IDEgLSBibDtcblx0ZiA9IDYgKiBoIC0gaTtcblxuXHRpZiAoKGkgJiAweDAxKSAhPT0gMCkge1xuXHRcdGYgPSAxIC0gZjtcblx0fVxuXG5cdG4gPSB3aCArIGYgKiAodiAtIHdoKTsgLy8gbGluZWFyIGludGVycG9sYXRpb25cblxuXHR2YXIgcjtcblx0dmFyIGc7XG5cdHZhciBiO1xuXHRzd2l0Y2ggKGkpIHtcblx0XHRkZWZhdWx0OlxuXHRcdGNhc2UgNjpcblx0XHRjYXNlIDA6IHIgPSB2OyBnID0gbjsgYiA9IHdoOyBicmVhaztcblx0XHRjYXNlIDE6IHIgPSBuOyBnID0gdjsgYiA9IHdoOyBicmVhaztcblx0XHRjYXNlIDI6IHIgPSB3aDsgZyA9IHY7IGIgPSBuOyBicmVhaztcblx0XHRjYXNlIDM6IHIgPSB3aDsgZyA9IG47IGIgPSB2OyBicmVhaztcblx0XHRjYXNlIDQ6IHIgPSBuOyBnID0gd2g7IGIgPSB2OyBicmVhaztcblx0XHRjYXNlIDU6IHIgPSB2OyBnID0gd2g7IGIgPSBuOyBicmVhaztcblx0fVxuXG5cdHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuXG5jb252ZXJ0LmNteWsucmdiID0gZnVuY3Rpb24gKGNteWspIHtcblx0dmFyIGMgPSBjbXlrWzBdIC8gMTAwO1xuXHR2YXIgbSA9IGNteWtbMV0gLyAxMDA7XG5cdHZhciB5ID0gY215a1syXSAvIDEwMDtcblx0dmFyIGsgPSBjbXlrWzNdIC8gMTAwO1xuXHR2YXIgcjtcblx0dmFyIGc7XG5cdHZhciBiO1xuXG5cdHIgPSAxIC0gTWF0aC5taW4oMSwgYyAqICgxIC0gaykgKyBrKTtcblx0ZyA9IDEgLSBNYXRoLm1pbigxLCBtICogKDEgLSBrKSArIGspO1xuXHRiID0gMSAtIE1hdGgubWluKDEsIHkgKiAoMSAtIGspICsgayk7XG5cblx0cmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn07XG5cbmNvbnZlcnQueHl6LnJnYiA9IGZ1bmN0aW9uICh4eXopIHtcblx0dmFyIHggPSB4eXpbMF0gLyAxMDA7XG5cdHZhciB5ID0geHl6WzFdIC8gMTAwO1xuXHR2YXIgeiA9IHh5elsyXSAvIDEwMDtcblx0dmFyIHI7XG5cdHZhciBnO1xuXHR2YXIgYjtcblxuXHRyID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG5cdGcgPSAoeCAqIC0wLjk2ODkpICsgKHkgKiAxLjg3NTgpICsgKHogKiAwLjA0MTUpO1xuXHRiID0gKHggKiAwLjA1NTcpICsgKHkgKiAtMC4yMDQwKSArICh6ICogMS4wNTcwKTtcblxuXHQvLyBhc3N1bWUgc1JHQlxuXHRyID0gciA+IDAuMDAzMTMwOFxuXHRcdD8gKCgxLjA1NSAqIE1hdGgucG93KHIsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG5cdFx0OiByICogMTIuOTI7XG5cblx0ZyA9IGcgPiAwLjAwMzEzMDhcblx0XHQ/ICgoMS4wNTUgKiBNYXRoLnBvdyhnLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuXHRcdDogZyAqIDEyLjkyO1xuXG5cdGIgPSBiID4gMC4wMDMxMzA4XG5cdFx0PyAoKDEuMDU1ICogTWF0aC5wb3coYiwgMS4wIC8gMi40KSkgLSAwLjA1NSlcblx0XHQ6IGIgKiAxMi45MjtcblxuXHRyID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuXHRnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuXHRiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuXG5cdHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuXG5jb252ZXJ0Lnh5ei5sYWIgPSBmdW5jdGlvbiAoeHl6KSB7XG5cdHZhciB4ID0geHl6WzBdO1xuXHR2YXIgeSA9IHh5elsxXTtcblx0dmFyIHogPSB4eXpbMl07XG5cdHZhciBsO1xuXHR2YXIgYTtcblx0dmFyIGI7XG5cblx0eCAvPSA5NS4wNDc7XG5cdHkgLz0gMTAwO1xuXHR6IC89IDEwOC44ODM7XG5cblx0eCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEgLyAzKSA6ICg3Ljc4NyAqIHgpICsgKDE2IC8gMTE2KTtcblx0eSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEgLyAzKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcblx0eiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEgLyAzKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuXHRsID0gKDExNiAqIHkpIC0gMTY7XG5cdGEgPSA1MDAgKiAoeCAtIHkpO1xuXHRiID0gMjAwICogKHkgLSB6KTtcblxuXHRyZXR1cm4gW2wsIGEsIGJdO1xufTtcblxuY29udmVydC5sYWIueHl6ID0gZnVuY3Rpb24gKGxhYikge1xuXHR2YXIgbCA9IGxhYlswXTtcblx0dmFyIGEgPSBsYWJbMV07XG5cdHZhciBiID0gbGFiWzJdO1xuXHR2YXIgeDtcblx0dmFyIHk7XG5cdHZhciB6O1xuXG5cdHkgPSAobCArIDE2KSAvIDExNjtcblx0eCA9IGEgLyA1MDAgKyB5O1xuXHR6ID0geSAtIGIgLyAyMDA7XG5cblx0dmFyIHkyID0gTWF0aC5wb3coeSwgMyk7XG5cdHZhciB4MiA9IE1hdGgucG93KHgsIDMpO1xuXHR2YXIgejIgPSBNYXRoLnBvdyh6LCAzKTtcblx0eSA9IHkyID4gMC4wMDg4NTYgPyB5MiA6ICh5IC0gMTYgLyAxMTYpIC8gNy43ODc7XG5cdHggPSB4MiA+IDAuMDA4ODU2ID8geDIgOiAoeCAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuXHR6ID0gejIgPiAwLjAwODg1NiA/IHoyIDogKHogLSAxNiAvIDExNikgLyA3Ljc4NztcblxuXHR4ICo9IDk1LjA0Nztcblx0eSAqPSAxMDA7XG5cdHogKj0gMTA4Ljg4MztcblxuXHRyZXR1cm4gW3gsIHksIHpdO1xufTtcblxuY29udmVydC5sYWIubGNoID0gZnVuY3Rpb24gKGxhYikge1xuXHR2YXIgbCA9IGxhYlswXTtcblx0dmFyIGEgPSBsYWJbMV07XG5cdHZhciBiID0gbGFiWzJdO1xuXHR2YXIgaHI7XG5cdHZhciBoO1xuXHR2YXIgYztcblxuXHRociA9IE1hdGguYXRhbjIoYiwgYSk7XG5cdGggPSBociAqIDM2MCAvIDIgLyBNYXRoLlBJO1xuXG5cdGlmIChoIDwgMCkge1xuXHRcdGggKz0gMzYwO1xuXHR9XG5cblx0YyA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcblxuXHRyZXR1cm4gW2wsIGMsIGhdO1xufTtcblxuY29udmVydC5sY2gubGFiID0gZnVuY3Rpb24gKGxjaCkge1xuXHR2YXIgbCA9IGxjaFswXTtcblx0dmFyIGMgPSBsY2hbMV07XG5cdHZhciBoID0gbGNoWzJdO1xuXHR2YXIgYTtcblx0dmFyIGI7XG5cdHZhciBocjtcblxuXHRociA9IGggLyAzNjAgKiAyICogTWF0aC5QSTtcblx0YSA9IGMgKiBNYXRoLmNvcyhocik7XG5cdGIgPSBjICogTWF0aC5zaW4oaHIpO1xuXG5cdHJldHVybiBbbCwgYSwgYl07XG59O1xuXG5jb252ZXJ0LnJnYi5hbnNpMTYgPSBmdW5jdGlvbiAoYXJncykge1xuXHR2YXIgciA9IGFyZ3NbMF07XG5cdHZhciBnID0gYXJnc1sxXTtcblx0dmFyIGIgPSBhcmdzWzJdO1xuXHR2YXIgdmFsdWUgPSAxIGluIGFyZ3VtZW50cyA/IGFyZ3VtZW50c1sxXSA6IGNvbnZlcnQucmdiLmhzdihhcmdzKVsyXTsgLy8gaHN2IC0+IGFuc2kxNiBvcHRpbWl6YXRpb25cblxuXHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgLyA1MCk7XG5cblx0aWYgKHZhbHVlID09PSAwKSB7XG5cdFx0cmV0dXJuIDMwO1xuXHR9XG5cblx0dmFyIGFuc2kgPSAzMFxuXHRcdCsgKChNYXRoLnJvdW5kKGIgLyAyNTUpIDw8IDIpXG5cdFx0fCAoTWF0aC5yb3VuZChnIC8gMjU1KSA8PCAxKVxuXHRcdHwgTWF0aC5yb3VuZChyIC8gMjU1KSk7XG5cblx0aWYgKHZhbHVlID09PSAyKSB7XG5cdFx0YW5zaSArPSA2MDtcblx0fVxuXG5cdHJldHVybiBhbnNpO1xufTtcblxuY29udmVydC5oc3YuYW5zaTE2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0Ly8gb3B0aW1pemF0aW9uIGhlcmU7IHdlIGFscmVhZHkga25vdyB0aGUgdmFsdWUgYW5kIGRvbid0IG5lZWQgdG8gZ2V0XG5cdC8vIGl0IGNvbnZlcnRlZCBmb3IgdXMuXG5cdHJldHVybiBjb252ZXJ0LnJnYi5hbnNpMTYoY29udmVydC5oc3YucmdiKGFyZ3MpLCBhcmdzWzJdKTtcbn07XG5cbmNvbnZlcnQucmdiLmFuc2kyNTYgPSBmdW5jdGlvbiAoYXJncykge1xuXHR2YXIgciA9IGFyZ3NbMF07XG5cdHZhciBnID0gYXJnc1sxXTtcblx0dmFyIGIgPSBhcmdzWzJdO1xuXG5cdC8vIHdlIHVzZSB0aGUgZXh0ZW5kZWQgZ3JleXNjYWxlIHBhbGV0dGUgaGVyZSwgd2l0aCB0aGUgZXhjZXB0aW9uIG9mXG5cdC8vIGJsYWNrIGFuZCB3aGl0ZS4gbm9ybWFsIHBhbGV0dGUgb25seSBoYXMgNCBncmV5c2NhbGUgc2hhZGVzLlxuXHRpZiAociA9PT0gZyAmJiBnID09PSBiKSB7XG5cdFx0aWYgKHIgPCA4KSB7XG5cdFx0XHRyZXR1cm4gMTY7XG5cdFx0fVxuXG5cdFx0aWYgKHIgPiAyNDgpIHtcblx0XHRcdHJldHVybiAyMzE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIE1hdGgucm91bmQoKChyIC0gOCkgLyAyNDcpICogMjQpICsgMjMyO1xuXHR9XG5cblx0dmFyIGFuc2kgPSAxNlxuXHRcdCsgKDM2ICogTWF0aC5yb3VuZChyIC8gMjU1ICogNSkpXG5cdFx0KyAoNiAqIE1hdGgucm91bmQoZyAvIDI1NSAqIDUpKVxuXHRcdCsgTWF0aC5yb3VuZChiIC8gMjU1ICogNSk7XG5cblx0cmV0dXJuIGFuc2k7XG59O1xuXG5jb252ZXJ0LmFuc2kxNi5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuXHR2YXIgY29sb3IgPSBhcmdzICUgMTA7XG5cblx0Ly8gaGFuZGxlIGdyZXlzY2FsZVxuXHRpZiAoY29sb3IgPT09IDAgfHwgY29sb3IgPT09IDcpIHtcblx0XHRpZiAoYXJncyA+IDUwKSB7XG5cdFx0XHRjb2xvciArPSAzLjU7XG5cdFx0fVxuXG5cdFx0Y29sb3IgPSBjb2xvciAvIDEwLjUgKiAyNTU7XG5cblx0XHRyZXR1cm4gW2NvbG9yLCBjb2xvciwgY29sb3JdO1xuXHR9XG5cblx0dmFyIG11bHQgPSAofn4oYXJncyA+IDUwKSArIDEpICogMC41O1xuXHR2YXIgciA9ICgoY29sb3IgJiAxKSAqIG11bHQpICogMjU1O1xuXHR2YXIgZyA9ICgoKGNvbG9yID4+IDEpICYgMSkgKiBtdWx0KSAqIDI1NTtcblx0dmFyIGIgPSAoKChjb2xvciA+PiAyKSAmIDEpICogbXVsdCkgKiAyNTU7XG5cblx0cmV0dXJuIFtyLCBnLCBiXTtcbn07XG5cbmNvbnZlcnQuYW5zaTI1Ni5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuXHQvLyBoYW5kbGUgZ3JleXNjYWxlXG5cdGlmIChhcmdzID49IDIzMikge1xuXHRcdHZhciBjID0gKGFyZ3MgLSAyMzIpICogMTAgKyA4O1xuXHRcdHJldHVybiBbYywgYywgY107XG5cdH1cblxuXHRhcmdzIC09IDE2O1xuXG5cdHZhciByZW07XG5cdHZhciByID0gTWF0aC5mbG9vcihhcmdzIC8gMzYpIC8gNSAqIDI1NTtcblx0dmFyIGcgPSBNYXRoLmZsb29yKChyZW0gPSBhcmdzICUgMzYpIC8gNikgLyA1ICogMjU1O1xuXHR2YXIgYiA9IChyZW0gJSA2KSAvIDUgKiAyNTU7XG5cblx0cmV0dXJuIFtyLCBnLCBiXTtcbn07XG5cbmNvbnZlcnQucmdiLmhleCA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciBpbnRlZ2VyID0gKChNYXRoLnJvdW5kKGFyZ3NbMF0pICYgMHhGRikgPDwgMTYpXG5cdFx0KyAoKE1hdGgucm91bmQoYXJnc1sxXSkgJiAweEZGKSA8PCA4KVxuXHRcdCsgKE1hdGgucm91bmQoYXJnc1syXSkgJiAweEZGKTtcblxuXHR2YXIgc3RyaW5nID0gaW50ZWdlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0cmV0dXJuICcwMDAwMDAnLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbn07XG5cbmNvbnZlcnQuaGV4LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciBtYXRjaCA9IGFyZ3MudG9TdHJpbmcoMTYpLm1hdGNoKC9bYS1mMC05XXs2fXxbYS1mMC05XXszfS9pKTtcblx0aWYgKCFtYXRjaCkge1xuXHRcdHJldHVybiBbMCwgMCwgMF07XG5cdH1cblxuXHR2YXIgY29sb3JTdHJpbmcgPSBtYXRjaFswXTtcblxuXHRpZiAobWF0Y2hbMF0ubGVuZ3RoID09PSAzKSB7XG5cdFx0Y29sb3JTdHJpbmcgPSBjb2xvclN0cmluZy5zcGxpdCgnJykubWFwKGZ1bmN0aW9uIChjaGFyKSB7XG5cdFx0XHRyZXR1cm4gY2hhciArIGNoYXI7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHR2YXIgaW50ZWdlciA9IHBhcnNlSW50KGNvbG9yU3RyaW5nLCAxNik7XG5cdHZhciByID0gKGludGVnZXIgPj4gMTYpICYgMHhGRjtcblx0dmFyIGcgPSAoaW50ZWdlciA+PiA4KSAmIDB4RkY7XG5cdHZhciBiID0gaW50ZWdlciAmIDB4RkY7XG5cblx0cmV0dXJuIFtyLCBnLCBiXTtcbn07XG5cbmNvbnZlcnQucmdiLmhjZyA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF0gLyAyNTU7XG5cdHZhciBnID0gcmdiWzFdIC8gMjU1O1xuXHR2YXIgYiA9IHJnYlsyXSAvIDI1NTtcblx0dmFyIG1heCA9IE1hdGgubWF4KE1hdGgubWF4KHIsIGcpLCBiKTtcblx0dmFyIG1pbiA9IE1hdGgubWluKE1hdGgubWluKHIsIGcpLCBiKTtcblx0dmFyIGNocm9tYSA9IChtYXggLSBtaW4pO1xuXHR2YXIgZ3JheXNjYWxlO1xuXHR2YXIgaHVlO1xuXG5cdGlmIChjaHJvbWEgPCAxKSB7XG5cdFx0Z3JheXNjYWxlID0gbWluIC8gKDEgLSBjaHJvbWEpO1xuXHR9IGVsc2Uge1xuXHRcdGdyYXlzY2FsZSA9IDA7XG5cdH1cblxuXHRpZiAoY2hyb21hIDw9IDApIHtcblx0XHRodWUgPSAwO1xuXHR9IGVsc2Vcblx0aWYgKG1heCA9PT0gcikge1xuXHRcdGh1ZSA9ICgoZyAtIGIpIC8gY2hyb21hKSAlIDY7XG5cdH0gZWxzZVxuXHRpZiAobWF4ID09PSBnKSB7XG5cdFx0aHVlID0gMiArIChiIC0gcikgLyBjaHJvbWE7XG5cdH0gZWxzZSB7XG5cdFx0aHVlID0gNCArIChyIC0gZykgLyBjaHJvbWEgKyA0O1xuXHR9XG5cblx0aHVlIC89IDY7XG5cdGh1ZSAlPSAxO1xuXG5cdHJldHVybiBbaHVlICogMzYwLCBjaHJvbWEgKiAxMDAsIGdyYXlzY2FsZSAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhzbC5oY2cgPSBmdW5jdGlvbiAoaHNsKSB7XG5cdHZhciBzID0gaHNsWzFdIC8gMTAwO1xuXHR2YXIgbCA9IGhzbFsyXSAvIDEwMDtcblx0dmFyIGMgPSAxO1xuXHR2YXIgZiA9IDA7XG5cblx0aWYgKGwgPCAwLjUpIHtcblx0XHRjID0gMi4wICogcyAqIGw7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IDIuMCAqIHMgKiAoMS4wIC0gbCk7XG5cdH1cblxuXHRpZiAoYyA8IDEuMCkge1xuXHRcdGYgPSAobCAtIDAuNSAqIGMpIC8gKDEuMCAtIGMpO1xuXHR9XG5cblx0cmV0dXJuIFtoc2xbMF0sIGMgKiAxMDAsIGYgKiAxMDBdO1xufTtcblxuY29udmVydC5oc3YuaGNnID0gZnVuY3Rpb24gKGhzdikge1xuXHR2YXIgcyA9IGhzdlsxXSAvIDEwMDtcblx0dmFyIHYgPSBoc3ZbMl0gLyAxMDA7XG5cblx0dmFyIGMgPSBzICogdjtcblx0dmFyIGYgPSAwO1xuXG5cdGlmIChjIDwgMS4wKSB7XG5cdFx0ZiA9ICh2IC0gYykgLyAoMSAtIGMpO1xuXHR9XG5cblx0cmV0dXJuIFtoc3ZbMF0sIGMgKiAxMDAsIGYgKiAxMDBdO1xufTtcblxuY29udmVydC5oY2cucmdiID0gZnVuY3Rpb24gKGhjZykge1xuXHR2YXIgaCA9IGhjZ1swXSAvIDM2MDtcblx0dmFyIGMgPSBoY2dbMV0gLyAxMDA7XG5cdHZhciBnID0gaGNnWzJdIC8gMTAwO1xuXG5cdGlmIChjID09PSAwLjApIHtcblx0XHRyZXR1cm4gW2cgKiAyNTUsIGcgKiAyNTUsIGcgKiAyNTVdO1xuXHR9XG5cblx0dmFyIHB1cmUgPSBbMCwgMCwgMF07XG5cdHZhciBoaSA9IChoICUgMSkgKiA2O1xuXHR2YXIgdiA9IGhpICUgMTtcblx0dmFyIHcgPSAxIC0gdjtcblx0dmFyIG1nID0gMDtcblxuXHRzd2l0Y2ggKE1hdGguZmxvb3IoaGkpKSB7XG5cdFx0Y2FzZSAwOlxuXHRcdFx0cHVyZVswXSA9IDE7IHB1cmVbMV0gPSB2OyBwdXJlWzJdID0gMDsgYnJlYWs7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0cHVyZVswXSA9IHc7IHB1cmVbMV0gPSAxOyBwdXJlWzJdID0gMDsgYnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0cHVyZVswXSA9IDA7IHB1cmVbMV0gPSAxOyBwdXJlWzJdID0gdjsgYnJlYWs7XG5cdFx0Y2FzZSAzOlxuXHRcdFx0cHVyZVswXSA9IDA7IHB1cmVbMV0gPSB3OyBwdXJlWzJdID0gMTsgYnJlYWs7XG5cdFx0Y2FzZSA0OlxuXHRcdFx0cHVyZVswXSA9IHY7IHB1cmVbMV0gPSAwOyBwdXJlWzJdID0gMTsgYnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHB1cmVbMF0gPSAxOyBwdXJlWzFdID0gMDsgcHVyZVsyXSA9IHc7XG5cdH1cblxuXHRtZyA9ICgxLjAgLSBjKSAqIGc7XG5cblx0cmV0dXJuIFtcblx0XHQoYyAqIHB1cmVbMF0gKyBtZykgKiAyNTUsXG5cdFx0KGMgKiBwdXJlWzFdICsgbWcpICogMjU1LFxuXHRcdChjICogcHVyZVsyXSArIG1nKSAqIDI1NVxuXHRdO1xufTtcblxuY29udmVydC5oY2cuaHN2ID0gZnVuY3Rpb24gKGhjZykge1xuXHR2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcblx0dmFyIGcgPSBoY2dbMl0gLyAxMDA7XG5cblx0dmFyIHYgPSBjICsgZyAqICgxLjAgLSBjKTtcblx0dmFyIGYgPSAwO1xuXG5cdGlmICh2ID4gMC4wKSB7XG5cdFx0ZiA9IGMgLyB2O1xuXHR9XG5cblx0cmV0dXJuIFtoY2dbMF0sIGYgKiAxMDAsIHYgKiAxMDBdO1xufTtcblxuY29udmVydC5oY2cuaHNsID0gZnVuY3Rpb24gKGhjZykge1xuXHR2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcblx0dmFyIGcgPSBoY2dbMl0gLyAxMDA7XG5cblx0dmFyIGwgPSBnICogKDEuMCAtIGMpICsgMC41ICogYztcblx0dmFyIHMgPSAwO1xuXG5cdGlmIChsID4gMC4wICYmIGwgPCAwLjUpIHtcblx0XHRzID0gYyAvICgyICogbCk7XG5cdH0gZWxzZVxuXHRpZiAobCA+PSAwLjUgJiYgbCA8IDEuMCkge1xuXHRcdHMgPSBjIC8gKDIgKiAoMSAtIGwpKTtcblx0fVxuXG5cdHJldHVybiBbaGNnWzBdLCBzICogMTAwLCBsICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaGNnLmh3YiA9IGZ1bmN0aW9uIChoY2cpIHtcblx0dmFyIGMgPSBoY2dbMV0gLyAxMDA7XG5cdHZhciBnID0gaGNnWzJdIC8gMTAwO1xuXHR2YXIgdiA9IGMgKyBnICogKDEuMCAtIGMpO1xuXHRyZXR1cm4gW2hjZ1swXSwgKHYgLSBjKSAqIDEwMCwgKDEgLSB2KSAqIDEwMF07XG59O1xuXG5jb252ZXJ0Lmh3Yi5oY2cgPSBmdW5jdGlvbiAoaHdiKSB7XG5cdHZhciB3ID0gaHdiWzFdIC8gMTAwO1xuXHR2YXIgYiA9IGh3YlsyXSAvIDEwMDtcblx0dmFyIHYgPSAxIC0gYjtcblx0dmFyIGMgPSB2IC0gdztcblx0dmFyIGcgPSAwO1xuXG5cdGlmIChjIDwgMSkge1xuXHRcdGcgPSAodiAtIGMpIC8gKDEgLSBjKTtcblx0fVxuXG5cdHJldHVybiBbaHdiWzBdLCBjICogMTAwLCBnICogMTAwXTtcbn07XG5cbmNvbnZlcnQuYXBwbGUucmdiID0gZnVuY3Rpb24gKGFwcGxlKSB7XG5cdHJldHVybiBbKGFwcGxlWzBdIC8gNjU1MzUpICogMjU1LCAoYXBwbGVbMV0gLyA2NTUzNSkgKiAyNTUsIChhcHBsZVsyXSAvIDY1NTM1KSAqIDI1NV07XG59O1xuXG5jb252ZXJ0LnJnYi5hcHBsZSA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0cmV0dXJuIFsocmdiWzBdIC8gMjU1KSAqIDY1NTM1LCAocmdiWzFdIC8gMjU1KSAqIDY1NTM1LCAocmdiWzJdIC8gMjU1KSAqIDY1NTM1XTtcbn07XG5cbmNvbnZlcnQuZ3JheS5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuXHRyZXR1cm4gW2FyZ3NbMF0gLyAxMDAgKiAyNTUsIGFyZ3NbMF0gLyAxMDAgKiAyNTUsIGFyZ3NbMF0gLyAxMDAgKiAyNTVdO1xufTtcblxuY29udmVydC5ncmF5LmhzbCA9IGNvbnZlcnQuZ3JheS5oc3YgPSBmdW5jdGlvbiAoYXJncykge1xuXHRyZXR1cm4gWzAsIDAsIGFyZ3NbMF1dO1xufTtcblxuY29udmVydC5ncmF5Lmh3YiA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdHJldHVybiBbMCwgMTAwLCBncmF5WzBdXTtcbn07XG5cbmNvbnZlcnQuZ3JheS5jbXlrID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0cmV0dXJuIFswLCAwLCAwLCBncmF5WzBdXTtcbn07XG5cbmNvbnZlcnQuZ3JheS5sYWIgPSBmdW5jdGlvbiAoZ3JheSkge1xuXHRyZXR1cm4gW2dyYXlbMF0sIDAsIDBdO1xufTtcblxuY29udmVydC5ncmF5LmhleCA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdHZhciB2YWwgPSBNYXRoLnJvdW5kKGdyYXlbMF0gLyAxMDAgKiAyNTUpICYgMHhGRjtcblx0dmFyIGludGVnZXIgPSAodmFsIDw8IDE2KSArICh2YWwgPDwgOCkgKyB2YWw7XG5cblx0dmFyIHN0cmluZyA9IGludGVnZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdHJldHVybiAnMDAwMDAwJy5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59O1xuXG5jb252ZXJ0LnJnYi5ncmF5ID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgdmFsID0gKHJnYlswXSArIHJnYlsxXSArIHJnYlsyXSkgLyAzO1xuXHRyZXR1cm4gW3ZhbCAvIDI1NSAqIDEwMF07XG59O1xuIiwgInZhciBjb252ZXJzaW9ucyA9IHJlcXVpcmUoJy4vY29udmVyc2lvbnMnKTtcblxuLypcblx0dGhpcyBmdW5jdGlvbiByb3V0ZXMgYSBtb2RlbCB0byBhbGwgb3RoZXIgbW9kZWxzLlxuXG5cdGFsbCBmdW5jdGlvbnMgdGhhdCBhcmUgcm91dGVkIGhhdmUgYSBwcm9wZXJ0eSBgLmNvbnZlcnNpb25gIGF0dGFjaGVkXG5cdHRvIHRoZSByZXR1cm5lZCBzeW50aGV0aWMgZnVuY3Rpb24uIFRoaXMgcHJvcGVydHkgaXMgYW4gYXJyYXlcblx0b2Ygc3RyaW5ncywgZWFjaCB3aXRoIHRoZSBzdGVwcyBpbiBiZXR3ZWVuIHRoZSAnZnJvbScgYW5kICd0bydcblx0Y29sb3IgbW9kZWxzIChpbmNsdXNpdmUpLlxuXG5cdGNvbnZlcnNpb25zIHRoYXQgYXJlIG5vdCBwb3NzaWJsZSBzaW1wbHkgYXJlIG5vdCBpbmNsdWRlZC5cbiovXG5cbmZ1bmN0aW9uIGJ1aWxkR3JhcGgoKSB7XG5cdHZhciBncmFwaCA9IHt9O1xuXHQvLyBodHRwczovL2pzcGVyZi5jb20vb2JqZWN0LWtleXMtdnMtZm9yLWluLXdpdGgtY2xvc3VyZS8zXG5cdHZhciBtb2RlbHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9ucyk7XG5cblx0Zm9yICh2YXIgbGVuID0gbW9kZWxzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdGdyYXBoW21vZGVsc1tpXV0gPSB7XG5cdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS8xLXZzLWluZmluaXR5XG5cdFx0XHQvLyBtaWNyby1vcHQsIGJ1dCB0aGlzIGlzIHNpbXBsZS5cblx0XHRcdGRpc3RhbmNlOiAtMSxcblx0XHRcdHBhcmVudDogbnVsbFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gZ3JhcGg7XG59XG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JyZWFkdGgtZmlyc3Rfc2VhcmNoXG5mdW5jdGlvbiBkZXJpdmVCRlMoZnJvbU1vZGVsKSB7XG5cdHZhciBncmFwaCA9IGJ1aWxkR3JhcGgoKTtcblx0dmFyIHF1ZXVlID0gW2Zyb21Nb2RlbF07IC8vIHVuc2hpZnQgLT4gcXVldWUgLT4gcG9wXG5cblx0Z3JhcGhbZnJvbU1vZGVsXS5kaXN0YW5jZSA9IDA7XG5cblx0d2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuXHRcdHZhciBjdXJyZW50ID0gcXVldWUucG9wKCk7XG5cdFx0dmFyIGFkamFjZW50cyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zW2N1cnJlbnRdKTtcblxuXHRcdGZvciAodmFyIGxlbiA9IGFkamFjZW50cy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHZhciBhZGphY2VudCA9IGFkamFjZW50c1tpXTtcblx0XHRcdHZhciBub2RlID0gZ3JhcGhbYWRqYWNlbnRdO1xuXG5cdFx0XHRpZiAobm9kZS5kaXN0YW5jZSA9PT0gLTEpIHtcblx0XHRcdFx0bm9kZS5kaXN0YW5jZSA9IGdyYXBoW2N1cnJlbnRdLmRpc3RhbmNlICsgMTtcblx0XHRcdFx0bm9kZS5wYXJlbnQgPSBjdXJyZW50O1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KGFkamFjZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZ3JhcGg7XG59XG5cbmZ1bmN0aW9uIGxpbmsoZnJvbSwgdG8pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0cmV0dXJuIHRvKGZyb20oYXJncykpO1xuXHR9O1xufVxuXG5mdW5jdGlvbiB3cmFwQ29udmVyc2lvbih0b01vZGVsLCBncmFwaCkge1xuXHR2YXIgcGF0aCA9IFtncmFwaFt0b01vZGVsXS5wYXJlbnQsIHRvTW9kZWxdO1xuXHR2YXIgZm4gPSBjb252ZXJzaW9uc1tncmFwaFt0b01vZGVsXS5wYXJlbnRdW3RvTW9kZWxdO1xuXG5cdHZhciBjdXIgPSBncmFwaFt0b01vZGVsXS5wYXJlbnQ7XG5cdHdoaWxlIChncmFwaFtjdXJdLnBhcmVudCkge1xuXHRcdHBhdGgudW5zaGlmdChncmFwaFtjdXJdLnBhcmVudCk7XG5cdFx0Zm4gPSBsaW5rKGNvbnZlcnNpb25zW2dyYXBoW2N1cl0ucGFyZW50XVtjdXJdLCBmbik7XG5cdFx0Y3VyID0gZ3JhcGhbY3VyXS5wYXJlbnQ7XG5cdH1cblxuXHRmbi5jb252ZXJzaW9uID0gcGF0aDtcblx0cmV0dXJuIGZuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmcm9tTW9kZWwpIHtcblx0dmFyIGdyYXBoID0gZGVyaXZlQkZTKGZyb21Nb2RlbCk7XG5cdHZhciBjb252ZXJzaW9uID0ge307XG5cblx0dmFyIG1vZGVscyA9IE9iamVjdC5rZXlzKGdyYXBoKTtcblx0Zm9yICh2YXIgbGVuID0gbW9kZWxzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdHZhciB0b01vZGVsID0gbW9kZWxzW2ldO1xuXHRcdHZhciBub2RlID0gZ3JhcGhbdG9Nb2RlbF07XG5cblx0XHRpZiAobm9kZS5wYXJlbnQgPT09IG51bGwpIHtcblx0XHRcdC8vIG5vIHBvc3NpYmxlIGNvbnZlcnNpb24sIG9yIHRoaXMgbm9kZSBpcyB0aGUgc291cmNlIG1vZGVsLlxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udmVyc2lvblt0b01vZGVsXSA9IHdyYXBDb252ZXJzaW9uKHRvTW9kZWwsIGdyYXBoKTtcblx0fVxuXG5cdHJldHVybiBjb252ZXJzaW9uO1xufTtcblxuIiwgInZhciBjb252ZXJzaW9ucyA9IHJlcXVpcmUoJy4vY29udmVyc2lvbnMnKTtcbnZhciByb3V0ZSA9IHJlcXVpcmUoJy4vcm91dGUnKTtcblxudmFyIGNvbnZlcnQgPSB7fTtcblxudmFyIG1vZGVscyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zKTtcblxuZnVuY3Rpb24gd3JhcFJhdyhmbikge1xuXHR2YXIgd3JhcHBlZEZuID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRpZiAoYXJncyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3MgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBhcmdzO1xuXHRcdH1cblxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZuKGFyZ3MpO1xuXHR9O1xuXG5cdC8vIHByZXNlcnZlIC5jb252ZXJzaW9uIHByb3BlcnR5IGlmIHRoZXJlIGlzIG9uZVxuXHRpZiAoJ2NvbnZlcnNpb24nIGluIGZuKSB7XG5cdFx0d3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuXHR9XG5cblx0cmV0dXJuIHdyYXBwZWRGbjtcbn1cblxuZnVuY3Rpb24gd3JhcFJvdW5kZWQoZm4pIHtcblx0dmFyIHdyYXBwZWRGbiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0aWYgKGFyZ3MgPT09IHVuZGVmaW5lZCB8fCBhcmdzID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gYXJncztcblx0XHR9XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdHZhciByZXN1bHQgPSBmbihhcmdzKTtcblxuXHRcdC8vIHdlJ3JlIGFzc3VtaW5nIHRoZSByZXN1bHQgaXMgYW4gYXJyYXkgaGVyZS5cblx0XHQvLyBzZWUgbm90aWNlIGluIGNvbnZlcnNpb25zLmpzOyBkb24ndCB1c2UgYm94IHR5cGVzXG5cdFx0Ly8gaW4gY29udmVyc2lvbiBmdW5jdGlvbnMuXG5cdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRmb3IgKHZhciBsZW4gPSByZXN1bHQubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHJlc3VsdFtpXSA9IE1hdGgucm91bmQocmVzdWx0W2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8vIHByZXNlcnZlIC5jb252ZXJzaW9uIHByb3BlcnR5IGlmIHRoZXJlIGlzIG9uZVxuXHRpZiAoJ2NvbnZlcnNpb24nIGluIGZuKSB7XG5cdFx0d3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuXHR9XG5cblx0cmV0dXJuIHdyYXBwZWRGbjtcbn1cblxubW9kZWxzLmZvckVhY2goZnVuY3Rpb24gKGZyb21Nb2RlbCkge1xuXHRjb252ZXJ0W2Zyb21Nb2RlbF0gPSB7fTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFtmcm9tTW9kZWxdLCAnY2hhbm5lbHMnLCB7dmFsdWU6IGNvbnZlcnNpb25zW2Zyb21Nb2RlbF0uY2hhbm5lbHN9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbZnJvbU1vZGVsXSwgJ2xhYmVscycsIHt2YWx1ZTogY29udmVyc2lvbnNbZnJvbU1vZGVsXS5sYWJlbHN9KTtcblxuXHR2YXIgcm91dGVzID0gcm91dGUoZnJvbU1vZGVsKTtcblx0dmFyIHJvdXRlTW9kZWxzID0gT2JqZWN0LmtleXMocm91dGVzKTtcblxuXHRyb3V0ZU1vZGVscy5mb3JFYWNoKGZ1bmN0aW9uICh0b01vZGVsKSB7XG5cdFx0dmFyIGZuID0gcm91dGVzW3RvTW9kZWxdO1xuXG5cdFx0Y29udmVydFtmcm9tTW9kZWxdW3RvTW9kZWxdID0gd3JhcFJvdW5kZWQoZm4pO1xuXHRcdGNvbnZlcnRbZnJvbU1vZGVsXVt0b01vZGVsXS5yYXcgPSB3cmFwUmF3KGZuKTtcblx0fSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXJ0O1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbG9yU3RyaW5nID0gcmVxdWlyZSgnY29sb3Itc3RyaW5nJyk7XG52YXIgY29udmVydCA9IHJlcXVpcmUoJ2NvbG9yLWNvbnZlcnQnKTtcblxudmFyIF9zbGljZSA9IFtdLnNsaWNlO1xuXG52YXIgc2tpcHBlZE1vZGVscyA9IFtcblx0Ly8gdG8gYmUgaG9uZXN0LCBJIGRvbid0IHJlYWxseSBmZWVsIGxpa2Uga2V5d29yZCBiZWxvbmdzIGluIGNvbG9yIGNvbnZlcnQsIGJ1dCBlaC5cblx0J2tleXdvcmQnLFxuXG5cdC8vIGdyYXkgY29uZmxpY3RzIHdpdGggc29tZSBtZXRob2QgbmFtZXMsIGFuZCBoYXMgaXRzIG93biBtZXRob2QgZGVmaW5lZC5cblx0J2dyYXknLFxuXG5cdC8vIHNob3VsZG4ndCByZWFsbHkgYmUgaW4gY29sb3ItY29udmVydCBlaXRoZXIuLi5cblx0J2hleCdcbl07XG5cbnZhciBoYXNoZWRNb2RlbEtleXMgPSB7fTtcbk9iamVjdC5rZXlzKGNvbnZlcnQpLmZvckVhY2goZnVuY3Rpb24gKG1vZGVsKSB7XG5cdGhhc2hlZE1vZGVsS2V5c1tfc2xpY2UuY2FsbChjb252ZXJ0W21vZGVsXS5sYWJlbHMpLnNvcnQoKS5qb2luKCcnKV0gPSBtb2RlbDtcbn0pO1xuXG52YXIgbGltaXRlcnMgPSB7fTtcblxuZnVuY3Rpb24gQ29sb3Iob2JqLCBtb2RlbCkge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29sb3IpKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihvYmosIG1vZGVsKTtcblx0fVxuXG5cdGlmIChtb2RlbCAmJiBtb2RlbCBpbiBza2lwcGVkTW9kZWxzKSB7XG5cdFx0bW9kZWwgPSBudWxsO1xuXHR9XG5cblx0aWYgKG1vZGVsICYmICEobW9kZWwgaW4gY29udmVydCkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbW9kZWw6ICcgKyBtb2RlbCk7XG5cdH1cblxuXHR2YXIgaTtcblx0dmFyIGNoYW5uZWxzO1xuXG5cdGlmIChvYmogPT0gbnVsbCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG5cdFx0dGhpcy5tb2RlbCA9ICdyZ2InO1xuXHRcdHRoaXMuY29sb3IgPSBbMCwgMCwgMF07XG5cdFx0dGhpcy52YWxwaGEgPSAxO1xuXHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIENvbG9yKSB7XG5cdFx0dGhpcy5tb2RlbCA9IG9iai5tb2RlbDtcblx0XHR0aGlzLmNvbG9yID0gb2JqLmNvbG9yLnNsaWNlKCk7XG5cdFx0dGhpcy52YWxwaGEgPSBvYmoudmFscGhhO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG5cdFx0dmFyIHJlc3VsdCA9IGNvbG9yU3RyaW5nLmdldChvYmopO1xuXHRcdGlmIChyZXN1bHQgPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhcnNlIGNvbG9yIGZyb20gc3RyaW5nOiAnICsgb2JqKTtcblx0XHR9XG5cblx0XHR0aGlzLm1vZGVsID0gcmVzdWx0Lm1vZGVsO1xuXHRcdGNoYW5uZWxzID0gY29udmVydFt0aGlzLm1vZGVsXS5jaGFubmVscztcblx0XHR0aGlzLmNvbG9yID0gcmVzdWx0LnZhbHVlLnNsaWNlKDAsIGNoYW5uZWxzKTtcblx0XHR0aGlzLnZhbHBoYSA9IHR5cGVvZiByZXN1bHQudmFsdWVbY2hhbm5lbHNdID09PSAnbnVtYmVyJyA/IHJlc3VsdC52YWx1ZVtjaGFubmVsc10gOiAxO1xuXHR9IGVsc2UgaWYgKG9iai5sZW5ndGgpIHtcblx0XHR0aGlzLm1vZGVsID0gbW9kZWwgfHwgJ3JnYic7XG5cdFx0Y2hhbm5lbHMgPSBjb252ZXJ0W3RoaXMubW9kZWxdLmNoYW5uZWxzO1xuXHRcdHZhciBuZXdBcnIgPSBfc2xpY2UuY2FsbChvYmosIDAsIGNoYW5uZWxzKTtcblx0XHR0aGlzLmNvbG9yID0gemVyb0FycmF5KG5ld0FyciwgY2hhbm5lbHMpO1xuXHRcdHRoaXMudmFscGhhID0gdHlwZW9mIG9ialtjaGFubmVsc10gPT09ICdudW1iZXInID8gb2JqW2NoYW5uZWxzXSA6IDE7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcblx0XHQvLyB0aGlzIGlzIGFsd2F5cyBSR0IgLSBjYW4gYmUgY29udmVydGVkIGxhdGVyIG9uLlxuXHRcdG9iaiAmPSAweEZGRkZGRjtcblx0XHR0aGlzLm1vZGVsID0gJ3JnYic7XG5cdFx0dGhpcy5jb2xvciA9IFtcblx0XHRcdChvYmogPj4gMTYpICYgMHhGRixcblx0XHRcdChvYmogPj4gOCkgJiAweEZGLFxuXHRcdFx0b2JqICYgMHhGRlxuXHRcdF07XG5cdFx0dGhpcy52YWxwaGEgPSAxO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMudmFscGhhID0gMTtcblxuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0XHRpZiAoJ2FscGhhJyBpbiBvYmopIHtcblx0XHRcdGtleXMuc3BsaWNlKGtleXMuaW5kZXhPZignYWxwaGEnKSwgMSk7XG5cdFx0XHR0aGlzLnZhbHBoYSA9IHR5cGVvZiBvYmouYWxwaGEgPT09ICdudW1iZXInID8gb2JqLmFscGhhIDogMDtcblx0XHR9XG5cblx0XHR2YXIgaGFzaGVkS2V5cyA9IGtleXMuc29ydCgpLmpvaW4oJycpO1xuXHRcdGlmICghKGhhc2hlZEtleXMgaW4gaGFzaGVkTW9kZWxLZXlzKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgY29sb3IgZnJvbSBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShvYmopKTtcblx0XHR9XG5cblx0XHR0aGlzLm1vZGVsID0gaGFzaGVkTW9kZWxLZXlzW2hhc2hlZEtleXNdO1xuXG5cdFx0dmFyIGxhYmVscyA9IGNvbnZlcnRbdGhpcy5tb2RlbF0ubGFiZWxzO1xuXHRcdHZhciBjb2xvciA9IFtdO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbG9yLnB1c2gob2JqW2xhYmVsc1tpXV0pO1xuXHRcdH1cblxuXHRcdHRoaXMuY29sb3IgPSB6ZXJvQXJyYXkoY29sb3IpO1xuXHR9XG5cblx0Ly8gcGVyZm9ybSBsaW1pdGF0aW9ucyAoY2xhbXBpbmcsIGV0Yy4pXG5cdGlmIChsaW1pdGVyc1t0aGlzLm1vZGVsXSkge1xuXHRcdGNoYW5uZWxzID0gY29udmVydFt0aGlzLm1vZGVsXS5jaGFubmVscztcblx0XHRmb3IgKGkgPSAwOyBpIDwgY2hhbm5lbHM7IGkrKykge1xuXHRcdFx0dmFyIGxpbWl0ID0gbGltaXRlcnNbdGhpcy5tb2RlbF1baV07XG5cdFx0XHRpZiAobGltaXQpIHtcblx0XHRcdFx0dGhpcy5jb2xvcltpXSA9IGxpbWl0KHRoaXMuY29sb3JbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHRoaXMudmFscGhhID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdGhpcy52YWxwaGEpKTtcblxuXHRpZiAoT2JqZWN0LmZyZWV6ZSkge1xuXHRcdE9iamVjdC5mcmVlemUodGhpcyk7XG5cdH1cbn1cblxuQ29sb3IucHJvdG90eXBlID0ge1xuXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnN0cmluZygpO1xuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzW3RoaXMubW9kZWxdKCk7XG5cdH0sXG5cblx0c3RyaW5nOiBmdW5jdGlvbiAocGxhY2VzKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLm1vZGVsIGluIGNvbG9yU3RyaW5nLnRvID8gdGhpcyA6IHRoaXMucmdiKCk7XG5cdFx0c2VsZiA9IHNlbGYucm91bmQodHlwZW9mIHBsYWNlcyA9PT0gJ251bWJlcicgPyBwbGFjZXMgOiAxKTtcblx0XHR2YXIgYXJncyA9IHNlbGYudmFscGhhID09PSAxID8gc2VsZi5jb2xvciA6IHNlbGYuY29sb3IuY29uY2F0KHRoaXMudmFscGhhKTtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcudG9bc2VsZi5tb2RlbF0oYXJncyk7XG5cdH0sXG5cblx0cGVyY2VudFN0cmluZzogZnVuY3Rpb24gKHBsYWNlcykge1xuXHRcdHZhciBzZWxmID0gdGhpcy5yZ2IoKS5yb3VuZCh0eXBlb2YgcGxhY2VzID09PSAnbnVtYmVyJyA/IHBsYWNlcyA6IDEpO1xuXHRcdHZhciBhcmdzID0gc2VsZi52YWxwaGEgPT09IDEgPyBzZWxmLmNvbG9yIDogc2VsZi5jb2xvci5jb25jYXQodGhpcy52YWxwaGEpO1xuXHRcdHJldHVybiBjb2xvclN0cmluZy50by5yZ2IucGVyY2VudChhcmdzKTtcblx0fSxcblxuXHRhcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHBoYSA9PT0gMSA/IHRoaXMuY29sb3Iuc2xpY2UoKSA6IHRoaXMuY29sb3IuY29uY2F0KHRoaXMudmFscGhhKTtcblx0fSxcblxuXHRvYmplY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmVzdWx0ID0ge307XG5cdFx0dmFyIGNoYW5uZWxzID0gY29udmVydFt0aGlzLm1vZGVsXS5jaGFubmVscztcblx0XHR2YXIgbGFiZWxzID0gY29udmVydFt0aGlzLm1vZGVsXS5sYWJlbHM7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5uZWxzOyBpKyspIHtcblx0XHRcdHJlc3VsdFtsYWJlbHNbaV1dID0gdGhpcy5jb2xvcltpXTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy52YWxwaGEgIT09IDEpIHtcblx0XHRcdHJlc3VsdC5hbHBoYSA9IHRoaXMudmFscGhhO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0dW5pdEFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IHRoaXMucmdiKCkuY29sb3I7XG5cdFx0cmdiWzBdIC89IDI1NTtcblx0XHRyZ2JbMV0gLz0gMjU1O1xuXHRcdHJnYlsyXSAvPSAyNTU7XG5cblx0XHRpZiAodGhpcy52YWxwaGEgIT09IDEpIHtcblx0XHRcdHJnYi5wdXNoKHRoaXMudmFscGhhKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmdiO1xuXHR9LFxuXG5cdHVuaXRPYmplY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy5yZ2IoKS5vYmplY3QoKTtcblx0XHRyZ2IuciAvPSAyNTU7XG5cdFx0cmdiLmcgLz0gMjU1O1xuXHRcdHJnYi5iIC89IDI1NTtcblxuXHRcdGlmICh0aGlzLnZhbHBoYSAhPT0gMSkge1xuXHRcdFx0cmdiLmFscGhhID0gdGhpcy52YWxwaGE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJnYjtcblx0fSxcblxuXHRyb3VuZDogZnVuY3Rpb24gKHBsYWNlcykge1xuXHRcdHBsYWNlcyA9IE1hdGgubWF4KHBsYWNlcyB8fCAwLCAwKTtcblx0XHRyZXR1cm4gbmV3IENvbG9yKHRoaXMuY29sb3IubWFwKHJvdW5kVG9QbGFjZShwbGFjZXMpKS5jb25jYXQodGhpcy52YWxwaGEpLCB0aGlzLm1vZGVsKTtcblx0fSxcblxuXHRhbHBoYTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHRoaXMuY29sb3IuY29uY2F0KE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHZhbCkpKSwgdGhpcy5tb2RlbCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMudmFscGhhO1xuXHR9LFxuXG5cdC8vIHJnYlxuXHRyZWQ6IGdldHNldCgncmdiJywgMCwgbWF4Zm4oMjU1KSksXG5cdGdyZWVuOiBnZXRzZXQoJ3JnYicsIDEsIG1heGZuKDI1NSkpLFxuXHRibHVlOiBnZXRzZXQoJ3JnYicsIDIsIG1heGZuKDI1NSkpLFxuXG5cdGh1ZTogZ2V0c2V0KFsnaHNsJywgJ2hzdicsICdoc2wnLCAnaHdiJywgJ2hjZyddLCAwLCBmdW5jdGlvbiAodmFsKSB7IHJldHVybiAoKHZhbCAlIDM2MCkgKyAzNjApICUgMzYwOyB9KSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBicmFjZS1zdHlsZVxuXG5cdHNhdHVyYXRpb25sOiBnZXRzZXQoJ2hzbCcsIDEsIG1heGZuKDEwMCkpLFxuXHRsaWdodG5lc3M6IGdldHNldCgnaHNsJywgMiwgbWF4Zm4oMTAwKSksXG5cblx0c2F0dXJhdGlvbnY6IGdldHNldCgnaHN2JywgMSwgbWF4Zm4oMTAwKSksXG5cdHZhbHVlOiBnZXRzZXQoJ2hzdicsIDIsIG1heGZuKDEwMCkpLFxuXG5cdGNocm9tYTogZ2V0c2V0KCdoY2cnLCAxLCBtYXhmbigxMDApKSxcblx0Z3JheTogZ2V0c2V0KCdoY2cnLCAyLCBtYXhmbigxMDApKSxcblxuXHR3aGl0ZTogZ2V0c2V0KCdod2InLCAxLCBtYXhmbigxMDApKSxcblx0d2JsYWNrOiBnZXRzZXQoJ2h3YicsIDIsIG1heGZuKDEwMCkpLFxuXG5cdGN5YW46IGdldHNldCgnY215aycsIDAsIG1heGZuKDEwMCkpLFxuXHRtYWdlbnRhOiBnZXRzZXQoJ2NteWsnLCAxLCBtYXhmbigxMDApKSxcblx0eWVsbG93OiBnZXRzZXQoJ2NteWsnLCAyLCBtYXhmbigxMDApKSxcblx0YmxhY2s6IGdldHNldCgnY215aycsIDMsIG1heGZuKDEwMCkpLFxuXG5cdHg6IGdldHNldCgneHl6JywgMCwgbWF4Zm4oMTAwKSksXG5cdHk6IGdldHNldCgneHl6JywgMSwgbWF4Zm4oMTAwKSksXG5cdHo6IGdldHNldCgneHl6JywgMiwgbWF4Zm4oMTAwKSksXG5cblx0bDogZ2V0c2V0KCdsYWInLCAwLCBtYXhmbigxMDApKSxcblx0YTogZ2V0c2V0KCdsYWInLCAxKSxcblx0YjogZ2V0c2V0KCdsYWInLCAyKSxcblxuXHRrZXl3b3JkOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodmFsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29udmVydFt0aGlzLm1vZGVsXS5rZXl3b3JkKHRoaXMuY29sb3IpO1xuXHR9LFxuXG5cdGhleDogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHZhbCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnRvLmhleCh0aGlzLnJnYigpLnJvdW5kKCkuY29sb3IpO1xuXHR9LFxuXG5cdHJnYk51bWJlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuXHRcdHJldHVybiAoKHJnYlswXSAmIDB4RkYpIDw8IDE2KSB8ICgocmdiWzFdICYgMHhGRikgPDwgOCkgfCAocmdiWzJdICYgMHhGRik7XG5cdH0sXG5cblx0bHVtaW5vc2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcblx0XHR2YXIgcmdiID0gdGhpcy5yZ2IoKS5jb2xvcjtcblxuXHRcdHZhciBsdW0gPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGNoYW4gPSByZ2JbaV0gLyAyNTU7XG5cdFx0XHRsdW1baV0gPSAoY2hhbiA8PSAwLjAzOTI4KSA/IGNoYW4gLyAxMi45MiA6IE1hdGgucG93KCgoY2hhbiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gMC4yMTI2ICogbHVtWzBdICsgMC43MTUyICogbHVtWzFdICsgMC4wNzIyICogbHVtWzJdO1xuXHR9LFxuXG5cdGNvbnRyYXN0OiBmdW5jdGlvbiAoY29sb3IyKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNjb250cmFzdC1yYXRpb2RlZlxuXHRcdHZhciBsdW0xID0gdGhpcy5sdW1pbm9zaXR5KCk7XG5cdFx0dmFyIGx1bTIgPSBjb2xvcjIubHVtaW5vc2l0eSgpO1xuXG5cdFx0aWYgKGx1bTEgPiBsdW0yKSB7XG5cdFx0XHRyZXR1cm4gKGx1bTEgKyAwLjA1KSAvIChsdW0yICsgMC4wNSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChsdW0yICsgMC4wNSkgLyAobHVtMSArIDAuMDUpO1xuXHR9LFxuXG5cdGxldmVsOiBmdW5jdGlvbiAoY29sb3IyKSB7XG5cdFx0dmFyIGNvbnRyYXN0UmF0aW8gPSB0aGlzLmNvbnRyYXN0KGNvbG9yMik7XG5cdFx0aWYgKGNvbnRyYXN0UmF0aW8gPj0gNy4xKSB7XG5cdFx0XHRyZXR1cm4gJ0FBQSc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChjb250cmFzdFJhdGlvID49IDQuNSkgPyAnQUEnIDogJyc7XG5cdH0sXG5cblx0aXNEYXJrOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gWUlRIGVxdWF0aW9uIGZyb20gaHR0cDovLzI0d2F5cy5vcmcvMjAxMC9jYWxjdWxhdGluZy1jb2xvci1jb250cmFzdFxuXHRcdHZhciByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuXHRcdHZhciB5aXEgPSAocmdiWzBdICogMjk5ICsgcmdiWzFdICogNTg3ICsgcmdiWzJdICogMTE0KSAvIDEwMDA7XG5cdFx0cmV0dXJuIHlpcSA8IDEyODtcblx0fSxcblxuXHRpc0xpZ2h0OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmlzRGFyaygpO1xuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSB0aGlzLnJnYigpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2IuY29sb3JbaV0gPSAyNTUgLSByZ2IuY29sb3JbaV07XG5cdFx0fVxuXHRcdHJldHVybiByZ2I7XG5cdH0sXG5cblx0bGlnaHRlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMuaHNsKCk7XG5cdFx0aHNsLmNvbG9yWzJdICs9IGhzbC5jb2xvclsyXSAqIHJhdGlvO1xuXHRcdHJldHVybiBoc2w7XG5cdH0sXG5cblx0ZGFya2VuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy5oc2woKTtcblx0XHRoc2wuY29sb3JbMl0gLT0gaHNsLmNvbG9yWzJdICogcmF0aW87XG5cdFx0cmV0dXJuIGhzbDtcblx0fSxcblxuXHRzYXR1cmF0ZTogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMuaHNsKCk7XG5cdFx0aHNsLmNvbG9yWzFdICs9IGhzbC5jb2xvclsxXSAqIHJhdGlvO1xuXHRcdHJldHVybiBoc2w7XG5cdH0sXG5cblx0ZGVzYXR1cmF0ZTogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMuaHNsKCk7XG5cdFx0aHNsLmNvbG9yWzFdIC09IGhzbC5jb2xvclsxXSAqIHJhdGlvO1xuXHRcdHJldHVybiBoc2w7XG5cdH0sXG5cblx0d2hpdGVuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHdiID0gdGhpcy5od2IoKTtcblx0XHRod2IuY29sb3JbMV0gKz0gaHdiLmNvbG9yWzFdICogcmF0aW87XG5cdFx0cmV0dXJuIGh3Yjtcblx0fSxcblxuXHRibGFja2VuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHdiID0gdGhpcy5od2IoKTtcblx0XHRod2IuY29sb3JbMl0gKz0gaHdiLmNvbG9yWzJdICogcmF0aW87XG5cdFx0cmV0dXJuIGh3Yjtcblx0fSxcblxuXHRncmF5c2NhbGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyYXlzY2FsZSNDb252ZXJ0aW5nX2NvbG9yX3RvX2dyYXlzY2FsZVxuXHRcdHZhciByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuXHRcdHZhciB2YWwgPSByZ2JbMF0gKiAwLjMgKyByZ2JbMV0gKiAwLjU5ICsgcmdiWzJdICogMC4xMTtcblx0XHRyZXR1cm4gQ29sb3IucmdiKHZhbCwgdmFsLCB2YWwpO1xuXHR9LFxuXG5cdGZhZGU6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHJldHVybiB0aGlzLmFscGhhKHRoaXMudmFscGhhIC0gKHRoaXMudmFscGhhICogcmF0aW8pKTtcblx0fSxcblxuXHRvcGFxdWVyOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHRyZXR1cm4gdGhpcy5hbHBoYSh0aGlzLnZhbHBoYSArICh0aGlzLnZhbHBoYSAqIHJhdGlvKSk7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbiAoZGVncmVlcykge1xuXHRcdHZhciBoc2wgPSB0aGlzLmhzbCgpO1xuXHRcdHZhciBodWUgPSBoc2wuY29sb3JbMF07XG5cdFx0aHVlID0gKGh1ZSArIGRlZ3JlZXMpICUgMzYwO1xuXHRcdGh1ZSA9IGh1ZSA8IDAgPyAzNjAgKyBodWUgOiBodWU7XG5cdFx0aHNsLmNvbG9yWzBdID0gaHVlO1xuXHRcdHJldHVybiBoc2w7XG5cdH0sXG5cblx0bWl4OiBmdW5jdGlvbiAobWl4aW5Db2xvciwgd2VpZ2h0KSB7XG5cdFx0Ly8gcG9ydGVkIGZyb20gc2FzcyBpbXBsZW1lbnRhdGlvbiBpbiBDXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3Nhc3MvbGlic2Fzcy9ibG9iLzBlNmI0YTI4NTAwOTIzNTZhYTNlY2UwN2M2YjI0OWYwMjIxY2FjZWQvZnVuY3Rpb25zLmNwcCNMMjA5XG5cdFx0aWYgKCFtaXhpbkNvbG9yIHx8ICFtaXhpbkNvbG9yLnJnYikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCB0byBcIm1peFwiIHdhcyBub3QgYSBDb2xvciBpbnN0YW5jZSwgYnV0IHJhdGhlciBhbiBpbnN0YW5jZSBvZiAnICsgdHlwZW9mIG1peGluQ29sb3IpO1xuXHRcdH1cblx0XHR2YXIgY29sb3IxID0gbWl4aW5Db2xvci5yZ2IoKTtcblx0XHR2YXIgY29sb3IyID0gdGhpcy5yZ2IoKTtcblx0XHR2YXIgcCA9IHdlaWdodCA9PT0gdW5kZWZpbmVkID8gMC41IDogd2VpZ2h0O1xuXG5cdFx0dmFyIHcgPSAyICogcCAtIDE7XG5cdFx0dmFyIGEgPSBjb2xvcjEuYWxwaGEoKSAtIGNvbG9yMi5hbHBoYSgpO1xuXG5cdFx0dmFyIHcxID0gKCgodyAqIGEgPT09IC0xKSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG5cdFx0dmFyIHcyID0gMSAtIHcxO1xuXG5cdFx0cmV0dXJuIENvbG9yLnJnYihcblx0XHRcdFx0dzEgKiBjb2xvcjEucmVkKCkgKyB3MiAqIGNvbG9yMi5yZWQoKSxcblx0XHRcdFx0dzEgKiBjb2xvcjEuZ3JlZW4oKSArIHcyICogY29sb3IyLmdyZWVuKCksXG5cdFx0XHRcdHcxICogY29sb3IxLmJsdWUoKSArIHcyICogY29sb3IyLmJsdWUoKSxcblx0XHRcdFx0Y29sb3IxLmFscGhhKCkgKiBwICsgY29sb3IyLmFscGhhKCkgKiAoMSAtIHApKTtcblx0fVxufTtcblxuLy8gbW9kZWwgY29udmVyc2lvbiBtZXRob2RzIGFuZCBzdGF0aWMgY29uc3RydWN0b3JzXG5PYmplY3Qua2V5cyhjb252ZXJ0KS5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbCkge1xuXHRpZiAoc2tpcHBlZE1vZGVscy5pbmRleE9mKG1vZGVsKSAhPT0gLTEpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgY2hhbm5lbHMgPSBjb252ZXJ0W21vZGVsXS5jaGFubmVscztcblxuXHQvLyBjb252ZXJzaW9uIG1ldGhvZHNcblx0Q29sb3IucHJvdG90eXBlW21vZGVsXSA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5tb2RlbCA9PT0gbW9kZWwpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IoYXJndW1lbnRzLCBtb2RlbCk7XG5cdFx0fVxuXG5cdFx0dmFyIG5ld0FscGhhID0gdHlwZW9mIGFyZ3VtZW50c1tjaGFubmVsc10gPT09ICdudW1iZXInID8gY2hhbm5lbHMgOiB0aGlzLnZhbHBoYTtcblx0XHRyZXR1cm4gbmV3IENvbG9yKGFzc2VydEFycmF5KGNvbnZlcnRbdGhpcy5tb2RlbF1bbW9kZWxdLnJhdyh0aGlzLmNvbG9yKSkuY29uY2F0KG5ld0FscGhhKSwgbW9kZWwpO1xuXHR9O1xuXG5cdC8vICdzdGF0aWMnIGNvbnN0cnVjdGlvbiBtZXRob2RzXG5cdENvbG9yW21vZGVsXSA9IGZ1bmN0aW9uIChjb2xvcikge1xuXHRcdGlmICh0eXBlb2YgY29sb3IgPT09ICdudW1iZXInKSB7XG5cdFx0XHRjb2xvciA9IHplcm9BcnJheShfc2xpY2UuY2FsbChhcmd1bWVudHMpLCBjaGFubmVscyk7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgQ29sb3IoY29sb3IsIG1vZGVsKTtcblx0fTtcbn0pO1xuXG5mdW5jdGlvbiByb3VuZFRvKG51bSwgcGxhY2VzKSB7XG5cdHJldHVybiBOdW1iZXIobnVtLnRvRml4ZWQocGxhY2VzKSk7XG59XG5cbmZ1bmN0aW9uIHJvdW5kVG9QbGFjZShwbGFjZXMpIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChudW0pIHtcblx0XHRyZXR1cm4gcm91bmRUbyhudW0sIHBsYWNlcyk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGdldHNldChtb2RlbCwgY2hhbm5lbCwgbW9kaWZpZXIpIHtcblx0bW9kZWwgPSBBcnJheS5pc0FycmF5KG1vZGVsKSA/IG1vZGVsIDogW21vZGVsXTtcblxuXHRtb2RlbC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG5cdFx0KGxpbWl0ZXJzW21dIHx8IChsaW1pdGVyc1ttXSA9IFtdKSlbY2hhbm5lbF0gPSBtb2RpZmllcjtcblx0fSk7XG5cblx0bW9kZWwgPSBtb2RlbFswXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuXHRcdHZhciByZXN1bHQ7XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0aWYgKG1vZGlmaWVyKSB7XG5cdFx0XHRcdHZhbCA9IG1vZGlmaWVyKHZhbCk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3VsdCA9IHRoaXNbbW9kZWxdKCk7XG5cdFx0XHRyZXN1bHQuY29sb3JbY2hhbm5lbF0gPSB2YWw7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblxuXHRcdHJlc3VsdCA9IHRoaXNbbW9kZWxdKCkuY29sb3JbY2hhbm5lbF07XG5cdFx0aWYgKG1vZGlmaWVyKSB7XG5cdFx0XHRyZXN1bHQgPSBtb2RpZmllcihyZXN1bHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG59XG5cbmZ1bmN0aW9uIG1heGZuKG1heCkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKHYpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCB2KSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFycmF5KHZhbCkge1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF07XG59XG5cbmZ1bmN0aW9uIHplcm9BcnJheShhcnIsIGxlbmd0aCkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHR5cGVvZiBhcnJbaV0gIT09ICdudW1iZXInKSB7XG5cdFx0XHRhcnJbaV0gPSAwO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sb3I7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKioqXG4gKiBDb252ZXJ0IHN0cmluZyB0byBoZXggY29sb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUZXh0IHRvIGhhc2ggYW5kIGNvbnZlcnQgdG8gaGV4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGV4KHN0cikge1xuICBmb3IgKFxuICAgIHZhciBpID0gMCwgaGFzaCA9IDA7XG4gICAgaSA8IHN0ci5sZW5ndGg7XG4gICAgaGFzaCA9IHN0ci5jaGFyQ29kZUF0KGkrKykgKyAoKGhhc2ggPDwgNSkgLSBoYXNoKVxuICApO1xuXG4gIHZhciBjb2xvciA9IE1hdGguZmxvb3IoXG4gICAgTWF0aC5hYnMoXG4gICAgICAoTWF0aC5zaW4oaGFzaCkgKiAxMDAwMCkgJSAxICogMTY3NzcyMTZcbiAgICApXG4gICkudG9TdHJpbmcoMTYpO1xuXG4gIHJldHVybiAnIycgKyBBcnJheSg2IC0gY29sb3IubGVuZ3RoICsgMSkuam9pbignMCcpICsgY29sb3I7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbG9yID0gcmVxdWlyZSgnY29sb3InKVxuICAsIGhleCA9IHJlcXVpcmUoJ3RleHQtaGV4Jyk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBjb2xvciBmb3IgYSBnaXZlbiBuYW1lLiBCdXQgYmUgcmVhc29uYWJseSBzbWFydCBhYm91dCBpdCBieVxuICogdW5kZXJzdGFuZGluZyBuYW1lIHNwYWNlcyBhbmQgY29sb3JpbmcgZWFjaCBuYW1lc3BhY2UgYSBiaXQgbGlnaHRlciBzbyB0aGV5XG4gKiBzdGlsbCBoYXZlIHRoZSBzYW1lIGJhc2UgY29sb3IgYXMgdGhlIHJvb3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2RlbGltaXRlcl0gVGhlIGRlbGltaXRlclxuICogQHJldHVybnMge3N0cmluZ30gY29sb3JcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb2xvcnNwYWNlKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG4gIHZhciBzcGxpdCA9IG5hbWVzcGFjZS5zcGxpdChkZWxpbWl0ZXIgfHwgJzonKTtcbiAgdmFyIGJhc2UgPSBoZXgoc3BsaXRbMF0pO1xuXG4gIGlmICghc3BsaXQubGVuZ3RoKSByZXR1cm4gYmFzZTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHNwbGl0Lmxlbmd0aCAtIDE7IGkgPCBsOyBpKyspIHtcbiAgICBiYXNlID0gY29sb3IoYmFzZSlcbiAgICAubWl4KGNvbG9yKGhleChzcGxpdFtpICsgMV0pKSlcbiAgICAuc2F0dXJhdGUoMSlcbiAgICAuaGV4KCk7XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEt1bGVyOiBDb2xvciB0ZXh0IHVzaW5nIENTUyBjb2xvcnNcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRoYXQgbmVlZHMgdG8gYmUgc3R5bGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgT3B0aW9uYWwgY29sb3IgZm9yIGFsdGVybmF0ZSBBUEkuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBLdWxlcih0ZXh0LCBjb2xvcikge1xuICBpZiAoY29sb3IpIHJldHVybiAobmV3IEt1bGVyKHRleHQpKS5zdHlsZShjb2xvcik7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBLdWxlcikpIHJldHVybiBuZXcgS3VsZXIodGV4dCk7XG5cbiAgdGhpcy50ZXh0ID0gdGV4dDtcbn1cblxuLyoqXG4gKiBBTlNJIGNvbG9yIGNvZGVzLlxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5LdWxlci5wcm90b3R5cGUucHJlZml4ID0gJ1xceDFiWyc7XG5LdWxlci5wcm90b3R5cGUuc3VmZml4ID0gJ20nO1xuXG4vKipcbiAqIFBhcnNlIGEgaGV4IGNvbG9yIHN0cmluZyBhbmQgcGFyc2UgaXQgdG8gaXQncyBSR0IgZXF1aXYuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuS3VsZXIucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uIGhleChjb2xvcikge1xuICBjb2xvciA9IGNvbG9yWzBdID09PSAnIycgPyBjb2xvci5zdWJzdHJpbmcoMSkgOiBjb2xvcjtcblxuICAvL1xuICAvLyBQcmUtcGFyc2UgZm9yIHNob3J0aGFuZCBoZXggY29sb3JzLlxuICAvL1xuICBpZiAoY29sb3IubGVuZ3RoID09PSAzKSB7XG4gICAgY29sb3IgPSBjb2xvci5zcGxpdCgnJyk7XG5cbiAgICBjb2xvcls1XSA9IGNvbG9yWzJdOyAvLyBGNjAjIzBcbiAgICBjb2xvcls0XSA9IGNvbG9yWzJdOyAvLyBGNjAjMDBcbiAgICBjb2xvclszXSA9IGNvbG9yWzFdOyAvLyBGNjA2MDBcbiAgICBjb2xvclsyXSA9IGNvbG9yWzFdOyAvLyBGNjY2MDBcbiAgICBjb2xvclsxXSA9IGNvbG9yWzBdOyAvLyBGRjY2MDBcblxuICAgIGNvbG9yID0gY29sb3Iuam9pbignJyk7XG4gIH1cblxuICB2YXIgciA9IGNvbG9yLnN1YnN0cmluZygwLCAyKVxuICAgICwgZyA9IGNvbG9yLnN1YnN0cmluZygyLCA0KVxuICAgICwgYiA9IGNvbG9yLnN1YnN0cmluZyg0LCA2KTtcblxuICByZXR1cm4gWyBwYXJzZUludChyLCAxNiksIHBhcnNlSW50KGcsIDE2KSwgcGFyc2VJbnQoYiwgMTYpIF07XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhIDI1NSBSR0IgdmFsdWUgdG8gYW4gUkdWIGNvZGUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHIgUmVkIGNvbG9yIGNoYW5uZWwuXG4gKiBAcGFyYW0ge051bWJlcn0gZyBHcmVlbiBjb2xvciBjaGFubmVsLlxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQmx1ZSBjb2xvciBjaGFubmVsLlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbkt1bGVyLnByb3RvdHlwZS5yZ2IgPSBmdW5jdGlvbiByZ2IociwgZywgYikge1xuICB2YXIgcmVkID0gciAvIDI1NSAqIDVcbiAgICAsIGdyZWVuID0gZyAvIDI1NSAqIDVcbiAgICAsIGJsdWUgPSBiIC8gMjU1ICogNTtcblxuICByZXR1cm4gdGhpcy5hbnNpKHJlZCwgZ3JlZW4sIGJsdWUpO1xufTtcblxuLyoqXG4gKiBUdXJucyBSR0IgMC01IHZhbHVlcyBpbnRvIGEgc2luZ2xlIEFOU0kgY29kZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gciBSZWQgY29sb3IgY2hhbm5lbC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBnIEdyZWVuIGNvbG9yIGNoYW5uZWwuXG4gKiBAcGFyYW0ge051bWJlcn0gYiBCbHVlIGNvbG9yIGNoYW5uZWwuXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuS3VsZXIucHJvdG90eXBlLmFuc2kgPSBmdW5jdGlvbiBhbnNpKHIsIGcsIGIpIHtcbiAgdmFyIHJlZCA9IE1hdGgucm91bmQocilcbiAgICAsIGdyZWVuID0gTWF0aC5yb3VuZChnKVxuICAgICwgYmx1ZSA9IE1hdGgucm91bmQoYik7XG5cbiAgcmV0dXJuIDE2ICsgKHJlZCAqIDM2KSArIChncmVlbiAqIDYpICsgYmx1ZTtcbn07XG5cbi8qKlxuICogTWFya3MgYW4gZW5kIG9mIGNvbG9yIHNlcXVlbmNlLlxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFJlc2V0IHNlcXVlbmNlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuS3VsZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJldHVybiB0aGlzLnByZWZpeCArJzM5OzQ5JysgdGhpcy5zdWZmaXg7XG59O1xuXG4vKipcbiAqIENvbG91ciB0aGUgdGVybWluYWwgdXNpbmcgQ1NTLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBUaGUgSEVYIGNvbG9yIGNvZGUuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgZXNjYXBlIGNvZGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5LdWxlci5wcm90b3R5cGUuc3R5bGUgPSBmdW5jdGlvbiBzdHlsZShjb2xvcikge1xuICByZXR1cm4gdGhpcy5wcmVmaXggKyczODs1OycrIHRoaXMucmdiLmFwcGx5KHRoaXMsIHRoaXMuaGV4KGNvbG9yKSkgKyB0aGlzLnN1ZmZpeCArIHRoaXMudGV4dCArIHRoaXMucmVzZXQoKTtcbn07XG5cblxuLy9cbi8vIEV4cG9zZSB0aGUgYWN0dWFsIGludGVyZmFjZS5cbi8vXG5tb2R1bGUuZXhwb3J0cyA9IEt1bGVyO1xuIiwgInZhciBjb2xvcnNwYWNlID0gcmVxdWlyZSgnY29sb3JzcGFjZScpO1xudmFyIGt1bGVyID0gcmVxdWlyZSgna3VsZXInKTtcblxuLyoqXG4gKiBQcmVmaXggdGhlIG1lc3NhZ2VzIHdpdGggYSBjb2xvcmVkIG5hbWVzcGFjZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBtZXNzYWdlcyBhcnJheSB0aGF0IGlzIGdldHRpbmcgd3JpdHRlbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgZm9yIGRpYWdub3N0aWNzLlxuICogQHJldHVybnMge0FycmF5fSBBbHRlcmVkIG1lc3NhZ2VzIGFycmF5LlxuICogQHB1YmxpY1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFuc2lNb2RpZmllcihhcmdzLCBvcHRpb25zKSB7XG4gIHZhciBuYW1lc3BhY2UgPSBvcHRpb25zLm5hbWVzcGFjZTtcbiAgdmFyIGFuc2kgPSBvcHRpb25zLmNvbG9ycyAhPT0gZmFsc2VcbiAgPyBrdWxlcihuYW1lc3BhY2UgKyc6JywgY29sb3JzcGFjZShuYW1lc3BhY2UpKVxuICA6IG5hbWVzcGFjZSArJzonO1xuXG4gIGFyZ3NbMF0gPSBhbnNpICsnICcrIGFyZ3NbMF07XG4gIHJldHVybiBhcmdzO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gbmFtZXNwYWNlIGlzIGFsbG93ZWQgYnkgdGhlIGdpdmVuIHZhcmlhYmxlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWVzcGFjZSB0aGF0IHNob3VsZCBiZSBpbmNsdWRlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB2YXJpYWJsZSBWYWx1ZSB0aGF0IG5lZWRzIHRvIGJlIHRlc3RlZC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJbmRpY2F0aW9uIGlmIG5hbWVzcGFjZSBpcyBlbmFibGVkLlxuICogQHB1YmxpY1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuYWJsZWQobmFtZSwgdmFyaWFibGUpIHtcbiAgaWYgKCF2YXJpYWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciB2YXJpYWJsZXMgPSB2YXJpYWJsZS5zcGxpdCgvW1xccyxdKy8pXG4gICAgLCBpID0gMDtcblxuICBmb3IgKDsgaSA8IHZhcmlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhcmlhYmxlID0gdmFyaWFibGVzW2ldLnJlcGxhY2UoJyonLCAnLio/Jyk7XG5cbiAgICBpZiAoJy0nID09PSB2YXJpYWJsZS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgobmV3IFJlZ0V4cCgnXicrIHZhcmlhYmxlLnN1YnN0cigxKSArJyQnKSkudGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICgobmV3IFJlZ0V4cCgnXicrIHZhcmlhYmxlICsnJCcpKS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwgInZhciBlbmFibGVkID0gcmVxdWlyZSgnZW5hYmxlZCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgQWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgYWRhcHRlciBsb2dpYy5cbiAqIEBwdWJsaWNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFkYXB0ZXIobmFtZXNwYWNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBlbmFibGVkKG5hbWVzcGFjZSwgZm4oKSk7XG4gICAgfSBjYXRjaCAoZSkgeyAvKiBBbnkgZmFpbHVyZSBtZWFucyB0aGF0IHdlIGZvdW5kIG5vdGhpbmcgKi8gfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufVxuIiwgInZhciBhZGFwdGVyID0gcmVxdWlyZSgnLi8nKTtcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgdmFsdWVzIGZyb20gcHJvY2Vzcy5lbnYuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQHB1YmxpY1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGFkYXB0ZXIoZnVuY3Rpb24gcHJvY2Vzc2VudigpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHIHx8IHByb2Nlc3MuZW52LkRJQUdOT1NUSUNTO1xufSk7XG4iLCAiLyoqXG4gKiBBbiBpZGlvdCBwcm9vZiBsb2dnZXIgdG8gYmUgdXNlZCBhcyBkZWZhdWx0LiBXZSd2ZSB3cmFwcGVkIGl0IGluIGEgdHJ5L2NhdGNoXG4gKiBzdGF0ZW1lbnQgdG8gZW5zdXJlIHRoZSBlbnZpcm9ubWVudHMgd2l0aG91dCB0aGUgYGNvbnNvbGVgIEFQSSBkbyBub3QgY3Jhc2hcbiAqIGFzIHdlbGwgYXMgYW4gYWRkaXRpb25hbCBmaXggZm9yIGFuY2llbnQgYnJvd3NlcnMgbGlrZSBJRTggd2hlcmUgdGhlXG4gKiBgY29uc29sZS5sb2dgIEFQSSBkb2Vzbid0IGhhdmUgYW4gYGFwcGx5YCwgc28gd2UgbmVlZCB0byB1c2UgdGhlIEZ1bmN0aW9uJ3NcbiAqIGFwcGx5IGZ1bmN0aW9uYWxpdHkgdG8gYXBwbHkgdGhlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWV0YSBPcHRpb25zIG9mIHRoZSBsb2dnZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBtZXNzYWdlcyBUaGUgYWN0dWFsbCBtZXNzYWdlIHRoYXQgbmVlZHMgdG8gYmUgbG9nZ2VkLlxuICogQHB1YmxpY1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRhLCBtZXNzYWdlcykge1xuICAvL1xuICAvLyBTbyB5ZWEuIElFOCBkb2Vzbid0IGhhdmUgYW4gYXBwbHkgc28gd2UgbmVlZCBhIHdvcmsgYXJvdW5kIHRvIHB1a2UgdGhlXG4gIC8vIGFyZ3VtZW50cyBpbiBwbGFjZS5cbiAgLy9cbiAgdHJ5IHsgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIG1lc3NhZ2VzKTsgfVxuICBjYXRjaCAoZSkge31cbn1cbiIsICJ2YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vZGlhZ25vc3RpY3MnKTtcbnZhciB0dHkgPSByZXF1aXJlKCd0dHknKS5pc2F0dHkoMSk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGRpYWdub3N0aWNzIGxvZ2dlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2UgaXQgc2hvdWxkIGVuYWJsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIGxvZ2dlci5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIGRpYWdub3N0aWNzID0gY3JlYXRlKGZ1bmN0aW9uIGRldihuYW1lc3BhY2UsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuY29sb3JzID0gJ2NvbG9ycycgaW4gb3B0aW9ucyA/IG9wdGlvbnMuY29sb3JzIDogdHR5O1xuICBvcHRpb25zLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgb3B0aW9ucy5wcm9kID0gZmFsc2U7XG4gIG9wdGlvbnMuZGV2ID0gdHJ1ZTtcblxuICBpZiAoIWRldi5lbmFibGVkKG5hbWVzcGFjZSkgJiYgIShvcHRpb25zLmZvcmNlIHx8IGRldi5mb3JjZSkpIHtcbiAgICByZXR1cm4gZGV2Lm5vcGUob3B0aW9ucyk7XG4gIH1cbiAgXG4gIHJldHVybiBkZXYueWVwKG9wdGlvbnMpO1xufSk7XG5cbi8vXG4vLyBDb25maWd1cmUgdGhlIGxvZ2dlciBmb3IgdGhlIGdpdmVuIGVudmlyb25tZW50LlxuLy9cbmRpYWdub3N0aWNzLm1vZGlmeShyZXF1aXJlKCcuLi9tb2RpZmllcnMvbmFtZXNwYWNlLWFuc2knKSk7XG5kaWFnbm9zdGljcy51c2UocmVxdWlyZSgnLi4vYWRhcHRlcnMvcHJvY2Vzcy5lbnYnKSk7XG5kaWFnbm9zdGljcy5zZXQocmVxdWlyZSgnLi4vbG9nZ2VyL2NvbnNvbGUnKSk7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIGRpYWdub3N0aWNzIGxvZ2dlci5cbi8vXG5tb2R1bGUuZXhwb3J0cyA9IGRpYWdub3N0aWNzO1xuIiwgIi8vXG4vLyBTZWxlY3QgdGhlIGNvcnJlY3QgYnVpbGQgdmVyc2lvbiBkZXBlbmRpbmcgb24gdGhlIGVudmlyb25tZW50LlxuLy9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsICIvKipcbiAqIHRhaWwtZmlsZS5qczogVE9ETzogYWRkIGZpbGUgaGVhZGVyIGRlc2NyaXB0aW9uLlxuICpcbiAqIChDKSAyMDEwIENoYXJsaWUgUm9iYmluc1xuICogTUlUIExJQ0VOQ0VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHsgU3RyaW5nRGVjb2RlciB9ID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKTtcbmNvbnN0IHsgU3RyZWFtIH0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKTtcblxuLyoqXG4gKiBTaW1wbGUgbm8tb3AgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBub29wKCkge31cblxuLyoqXG4gKiBUT0RPOiBhZGQgZnVuY3Rpb24gZGVzY3JpcHRpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRhaWwuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyIC0gSXRlcmF0b3IgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBldmVyeSBsaW5lLlxuKiBgdGFpbCAtZmAgYSBmaWxlLiBPcHRpb25zIG11c3QgaW5jbHVkZSBmaWxlLlxuICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKG9wdGlvbnMsIGl0ZXIpID0+IHtcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDY0ICogMTAyNCk7XG4gIGNvbnN0IGRlY29kZSA9IG5ldyBTdHJpbmdEZWNvZGVyKCd1dGY4Jyk7XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBTdHJlYW0oKTtcbiAgbGV0IGJ1ZmYgPSAnJztcbiAgbGV0IHBvcyA9IDA7XG4gIGxldCByb3cgPSAwO1xuXG4gIGlmIChvcHRpb25zLnN0YXJ0ID09PSAtMSkge1xuICAgIGRlbGV0ZSBvcHRpb25zLnN0YXJ0O1xuICB9XG5cbiAgc3RyZWFtLnJlYWRhYmxlID0gdHJ1ZTtcbiAgc3RyZWFtLmRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgc3RyZWFtLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgIHN0cmVhbS5lbWl0KCdjbG9zZScpO1xuICB9O1xuXG4gIGZzLm9wZW4ob3B0aW9ucy5maWxlLCAnYSsnLCAnMDY0NCcsIChlcnIsIGZkKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgaWYgKCFpdGVyKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyKGVycik7XG4gICAgICB9XG4gICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIChmdW5jdGlvbiByZWFkKCkge1xuICAgICAgaWYgKHN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgZnMuY2xvc2UoZmQsIG5vb3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmcy5yZWFkKGZkLCBidWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGgsIHBvcywgKGVycm9yLCBieXRlcykgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIWl0ZXIpIHtcbiAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFieXRlcykge1xuICAgICAgICAgIGlmIChidWZmKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydCA9PSBudWxsIHx8IHJvdyA+IG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgICAgICAgaWYgKCFpdGVyKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2xpbmUnLCBidWZmKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyKG51bGwsIGJ1ZmYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3crKztcbiAgICAgICAgICAgIGJ1ZmYgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQocmVhZCwgMTAwMCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGF0YSA9IGRlY29kZS53cml0ZShidWZmZXIuc2xpY2UoMCwgYnl0ZXMpKTtcbiAgICAgICAgaWYgKCFpdGVyKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEgPSAoYnVmZiArIGRhdGEpLnNwbGl0KC9cXG4rLyk7XG5cbiAgICAgICAgY29uc3QgbCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgbGV0IGkgPSAwO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0ID09IG51bGwgfHwgcm93ID4gb3B0aW9ucy5zdGFydCkge1xuICAgICAgICAgICAgaWYgKCFpdGVyKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdsaW5lJywgZGF0YVtpXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpdGVyKG51bGwsIGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByb3crKztcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmYgPSBkYXRhW2xdO1xuICAgICAgICBwb3MgKz0gYnl0ZXM7XG4gICAgICAgIHJldHVybiByZWFkKCk7XG4gICAgICB9KTtcbiAgICB9KCkpO1xuICB9KTtcblxuICBpZiAoIWl0ZXIpIHtcbiAgICByZXR1cm4gc3RyZWFtO1xuICB9XG5cbiAgcmV0dXJuIHN0cmVhbS5kZXN0cm95O1xufTtcbiIsICIvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5LG1heC1zdGF0ZW1lbnRzICovXG4vKipcbiAqIGZpbGUuanM6IFRyYW5zcG9ydCBmb3Igb3V0cHV0dGluZyB0byBhIGxvY2FsIGxvZyBmaWxlLlxuICpcbiAqIChDKSAyMDEwIENoYXJsaWUgUm9iYmluc1xuICogTUlUIExJQ0VOQ0VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBhc3luY1NlcmllcyA9IHJlcXVpcmUoJ2FzeW5jL3NlcmllcycpO1xuY29uc3QgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcbmNvbnN0IHsgTUVTU0FHRSB9ID0gcmVxdWlyZSgndHJpcGxlLWJlYW0nKTtcbmNvbnN0IHsgU3RyZWFtLCBQYXNzVGhyb3VnaCB9ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJyk7XG5jb25zdCBUcmFuc3BvcnRTdHJlYW0gPSByZXF1aXJlKCd3aW5zdG9uLXRyYW5zcG9ydCcpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdAZGFiaC9kaWFnbm9zdGljcycpKCd3aW5zdG9uOmZpbGUnKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IHRhaWxGaWxlID0gcmVxdWlyZSgnLi4vdGFpbC1maWxlJyk7XG5cbi8qKlxuICogVHJhbnNwb3J0IGZvciBvdXRwdXR0aW5nIHRvIGEgbG9jYWwgbG9nIGZpbGUuXG4gKiBAdHlwZSB7RmlsZX1cbiAqIEBleHRlbmRzIHtUcmFuc3BvcnRTdHJlYW19XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRmlsZSBleHRlbmRzIFRyYW5zcG9ydFN0cmVhbSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIEZpbGUgdHJhbnNwb3J0IG9iamVjdCByZXNwb25zaWJsZSBmb3JcbiAgICogcGVyc2lzdGluZyBsb2cgbWVzc2FnZXMgYW5kIG1ldGFkYXRhIHRvIG9uZSBvciBtb3JlIGZpbGVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIC8vIEV4cG9zZSB0aGUgbmFtZSBvZiB0aGlzIFRyYW5zcG9ydCBvbiB0aGUgcHJvdG90eXBlLlxuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCAnZmlsZSc7XG5cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gd2hpY2ggdGhyb3dzIGFuIGBFcnJvcmAgaW4gdGhlIGV2ZW50IHRoYXQgYW55IG9mIHRoZVxuICAgIC8vIHJlc3Qgb2YgdGhlIGFyZ3VtZW50cyBpcyBwcmVzZW50IGluIGBvcHRpb25zYC5cbiAgICBmdW5jdGlvbiB0aHJvd0lmKHRhcmdldCwgLi4uYXJncykge1xuICAgICAgYXJncy5zbGljZSgxKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICBpZiAob3B0aW9uc1tuYW1lXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHNldCAke25hbWV9IGFuZCAke3RhcmdldH0gdG9nZXRoZXJgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU2V0dXAgdGhlIGJhc2Ugc3RyZWFtIHRoYXQgYWx3YXlzIGdldHMgcGlwZWQgdG8gdG8gaGFuZGxlIGJ1ZmZlcmluZy5cbiAgICB0aGlzLl9zdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2goKTtcbiAgICB0aGlzLl9zdHJlYW0uc2V0TWF4TGlzdGVuZXJzKDMwKTtcblxuICAgIC8vIEJpbmQgdGhpcyBjb250ZXh0IGZvciBsaXN0ZW5lciBtZXRob2RzLlxuICAgIHRoaXMuX29uRXJyb3IgPSB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyk7XG5cbiAgICBpZiAob3B0aW9ucy5maWxlbmFtZSB8fCBvcHRpb25zLmRpcm5hbWUpIHtcbiAgICAgIHRocm93SWYoJ2ZpbGVuYW1lIG9yIGRpcm5hbWUnLCAnc3RyZWFtJyk7XG4gICAgICB0aGlzLl9iYXNlbmFtZSA9IHRoaXMuZmlsZW5hbWUgPSBvcHRpb25zLmZpbGVuYW1lXG4gICAgICAgID8gcGF0aC5iYXNlbmFtZShvcHRpb25zLmZpbGVuYW1lKVxuICAgICAgICA6ICd3aW5zdG9uLmxvZyc7XG5cbiAgICAgIHRoaXMuZGlybmFtZSA9IG9wdGlvbnMuZGlybmFtZSB8fCBwYXRoLmRpcm5hbWUob3B0aW9ucy5maWxlbmFtZSk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLm9wdGlvbnMgfHwgeyBmbGFnczogJ2EnIH07XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnN0cmVhbSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2Fybignb3B0aW9ucy5zdHJlYW0gd2lsbCBiZSByZW1vdmVkIGluIHdpbnN0b25ANC4gVXNlIHdpbnN0b24udHJhbnNwb3J0cy5TdHJlYW0nKTtcbiAgICAgIHRocm93SWYoJ3N0cmVhbScsICdmaWxlbmFtZScsICdtYXhzaXplJyk7XG4gICAgICB0aGlzLl9kZXN0ID0gdGhpcy5fc3RyZWFtLnBpcGUodGhpcy5fc2V0dXBTdHJlYW0ob3B0aW9ucy5zdHJlYW0pKTtcbiAgICAgIHRoaXMuZGlybmFtZSA9IHBhdGguZGlybmFtZSh0aGlzLl9kZXN0LnBhdGgpO1xuICAgICAgLy8gV2UgbmVlZCB0byBsaXN0ZW4gZm9yIGRyYWluIGV2ZW50cyB3aGVuIHdyaXRlKCkgcmV0dXJucyBmYWxzZS4gVGhpc1xuICAgICAgLy8gY2FuIG1ha2Ugbm9kZSBtYWQgYXQgdGltZXMuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGxvZyB0byBmaWxlIHdpdGhvdXQgZmlsZW5hbWUgb3Igc3RyZWFtLicpO1xuICAgIH1cblxuICAgIHRoaXMubWF4c2l6ZSA9IG9wdGlvbnMubWF4c2l6ZSB8fCBudWxsO1xuICAgIHRoaXMucm90YXRpb25Gb3JtYXQgPSBvcHRpb25zLnJvdGF0aW9uRm9ybWF0IHx8IGZhbHNlO1xuICAgIHRoaXMuemlwcGVkQXJjaGl2ZSA9IG9wdGlvbnMuemlwcGVkQXJjaGl2ZSB8fCBmYWxzZTtcbiAgICB0aGlzLm1heEZpbGVzID0gb3B0aW9ucy5tYXhGaWxlcyB8fCBudWxsO1xuICAgIHRoaXMuZW9sID0gKHR5cGVvZiBvcHRpb25zLmVvbCA9PT0gJ3N0cmluZycpID8gb3B0aW9ucy5lb2wgOiBvcy5FT0w7XG4gICAgdGhpcy50YWlsYWJsZSA9IG9wdGlvbnMudGFpbGFibGUgfHwgZmFsc2U7XG4gICAgdGhpcy5sYXp5ID0gb3B0aW9ucy5sYXp5IHx8IGZhbHNlO1xuXG4gICAgLy8gSW50ZXJuYWwgc3RhdGUgdmFyaWFibGVzIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIGZpbGVzIHRoaXMgaW5zdGFuY2VcbiAgICAvLyBoYXMgY3JlYXRlZCBhbmQgdGhlIGN1cnJlbnQgc2l6ZSAoaW4gYnl0ZXMpIG9mIHRoZSBjdXJyZW50IGxvZ2ZpbGUuXG4gICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgdGhpcy5fcGVuZGluZ1NpemUgPSAwO1xuICAgIHRoaXMuX2NyZWF0ZWQgPSAwO1xuICAgIHRoaXMuX2RyYWluID0gZmFsc2U7XG4gICAgdGhpcy5fb3BlbmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2VuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbGVFeGlzdCA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuZGlybmFtZSkgdGhpcy5fY3JlYXRlTG9nRGlySWZOb3RFeGlzdCh0aGlzLmRpcm5hbWUpO1xuICAgIGlmICghdGhpcy5sYXp5KSB0aGlzLm9wZW4oKTtcbiAgfVxuXG4gIGZpbmlzaElmRW5kaW5nKCkge1xuICAgIGlmICh0aGlzLl9lbmRpbmcpIHtcbiAgICAgIGlmICh0aGlzLl9vcGVuaW5nKSB7XG4gICAgICAgIHRoaXMub25jZSgnb3BlbicsICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9zdHJlYW0ub25jZSgnZmluaXNoJywgKCkgPT4gdGhpcy5lbWl0KCdmaW5pc2gnKSk7XG4gICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3N0cmVhbS5lbmQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsICgpID0+IHRoaXMuZW1pdCgnZmluaXNoJykpO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fc3RyZWFtLmVuZCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29yZSBsb2dnaW5nIG1ldGhvZCBleHBvc2VkIHRvIFdpbnN0b24uIE1ldGFkYXRhIGlzIG9wdGlvbmFsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5mbyAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBsb2coaW5mbywgY2FsbGJhY2sgPSAoKSA9PiB7IH0pIHtcbiAgICAvLyBSZW1hcms6IChqY3J1Z3p6KSBXaGF0IGlzIG5lY2Vzc2FyeSBhYm91dCB0aGlzIGNhbGxiYWNrKG51bGwsIHRydWUpIG5vd1xuICAgIC8vIHdoZW4gdGhpbmtpbmcgYWJvdXQgMy54PyBTaG91bGQgc2lsZW50IGJlIGhhbmRsZWQgaW4gdGhlIGJhc2VcbiAgICAvLyBUcmFuc3BvcnRTdHJlYW0gX3dyaXRlIG1ldGhvZD9cbiAgICBpZiAodGhpcy5zaWxlbnQpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuICAgIC8vIE91dHB1dCBzdHJlYW0gYnVmZmVyIGlzIGZ1bGwgYW5kIGhhcyBhc2tlZCB1cyB0byB3YWl0IGZvciB0aGUgZHJhaW4gZXZlbnRcbiAgICBpZiAodGhpcy5fZHJhaW4pIHtcbiAgICAgIHRoaXMuX3N0cmVhbS5vbmNlKCdkcmFpbicsICgpID0+IHtcbiAgICAgICAgdGhpcy5fZHJhaW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2coaW5mbywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9yb3RhdGUpIHtcbiAgICAgIHRoaXMuX3N0cmVhbS5vbmNlKCdyb3RhdGUnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3JvdGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvZyhpbmZvLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubGF6eSkge1xuICAgICAgaWYgKCF0aGlzLl9maWxlRXhpc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuaW5nKSB7XG4gICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbmNlKCdvcGVuJywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2ZpbGVFeGlzdCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5sb2coaW5mbywgY2FsbGJhY2spO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9uZWVkc05ld0ZpbGUodGhpcy5fcGVuZGluZ1NpemUpKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Qub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9vcGVuaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5vbmNlKCdvcGVuJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coaW5mbywgY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHcmFiIHRoZSByYXcgc3RyaW5nIGFuZCBhcHBlbmQgdGhlIGV4cGVjdGVkIEVPTC5cbiAgICBjb25zdCBvdXRwdXQgPSBgJHtpbmZvW01FU1NBR0VdfSR7dGhpcy5lb2x9YDtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG91dHB1dCk7XG5cbiAgICAvLyBBZnRlciB3ZSBoYXZlIHdyaXR0ZW4gdG8gdGhlIFBhc3NUaHJvdWdoIGNoZWNrIHRvIHNlZSBpZiB3ZSBuZWVkXG4gICAgLy8gdG8gcm90YXRlIHRvIHRoZSBuZXh0IGZpbGUuXG4gICAgLy9cbiAgICAvLyBSZW1hcms6IFRoaXMgZ2V0cyBjYWxsZWQgdG9vIGVhcmx5IGFuZCBkb2VzIG5vdCBkZXBpY3Qgd2hlbiBkYXRhXG4gICAgLy8gaGFzIGJlZW4gYWN0dWFsbHkgZmx1c2hlZCB0byBkaXNrLlxuICAgIGZ1bmN0aW9uIGxvZ2dlZCgpIHtcbiAgICAgIHRoaXMuX3NpemUgKz0gYnl0ZXM7XG4gICAgICB0aGlzLl9wZW5kaW5nU2l6ZSAtPSBieXRlcztcblxuICAgICAgZGVidWcoJ2xvZ2dlZCAlcyAlcycsIHRoaXMuX3NpemUsIG91dHB1dCk7XG4gICAgICB0aGlzLmVtaXQoJ2xvZ2dlZCcsIGluZm8pO1xuXG4gICAgICAvLyBEbyBub3QgYXR0ZW1wdCB0byByb3RhdGUgZmlsZXMgd2hpbGUgcm90YXRpbmdcbiAgICAgIGlmICh0aGlzLl9yb3RhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBEbyBub3QgYXR0ZW1wdCB0byByb3RhdGUgZmlsZXMgd2hpbGUgb3BlbmluZ1xuICAgICAgaWYgKHRoaXMuX29wZW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgbmVlZCB0byBlbmQgdGhlIHN0cmVhbSBhbmQgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgIGlmICghdGhpcy5fbmVlZHNOZXdGaWxlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGF6eSkge1xuICAgICAgICB0aGlzLl9lbmRTdHJlYW0oKCkgPT4ge3RoaXMuZW1pdCgnZmlsZWNsb3NlZCcpfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRW5kIHRoZSBjdXJyZW50IHN0cmVhbSwgZW5zdXJlIGl0IGZsdXNoZXMgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICAvLyBUaGlzIGNvdWxkIHBvdGVudGlhbGx5IGJlIG9wdGltaXplZCB0byBub3QgcnVuIGEgc3RhdCBjYWxsIGJ1dCBpdHNcbiAgICAgIC8vIHRoZSBzYWZlc3Qgd2F5IHNpbmNlIHdlIGFyZSBzdXBwb3J0aW5nIGBtYXhGaWxlc2AuXG4gICAgICB0aGlzLl9yb3RhdGUgPSB0cnVlO1xuICAgICAgdGhpcy5fZW5kU3RyZWFtKCgpID0+IHRoaXMuX3JvdGF0ZUZpbGUoKSk7XG4gICAgfVxuXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgcGVuZGluZyBieXRlcyBiZWluZyB3cml0dGVuIHdoaWxlIGZpbGVzIGFyZSBvcGVuaW5nXG4gICAgLy8gaW4gb3JkZXIgdG8gcHJvcGVybHkgcm90YXRlIHRoZSBQYXNzVGhyb3VnaCB0aGlzLl9zdHJlYW0gd2hlbiB0aGUgZmlsZVxuICAgIC8vIGV2ZW50dWFsbHkgZG9lcyBvcGVuLlxuICAgIHRoaXMuX3BlbmRpbmdTaXplICs9IGJ5dGVzO1xuICAgIGlmICh0aGlzLl9vcGVuaW5nXG4gICAgICAmJiAhdGhpcy5yb3RhdGVkV2hpbGVPcGVuaW5nXG4gICAgICAmJiB0aGlzLl9uZWVkc05ld0ZpbGUodGhpcy5fc2l6ZSArIHRoaXMuX3BlbmRpbmdTaXplKSkge1xuICAgICAgdGhpcy5yb3RhdGVkV2hpbGVPcGVuaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB3cml0dGVuID0gdGhpcy5fc3RyZWFtLndyaXRlKG91dHB1dCwgbG9nZ2VkLmJpbmQodGhpcykpO1xuICAgIGlmICghd3JpdHRlbikge1xuICAgICAgdGhpcy5fZHJhaW4gPSB0cnVlO1xuICAgICAgdGhpcy5fc3RyZWFtLm9uY2UoJ2RyYWluJywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9kcmFpbiA9IGZhbHNlO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgfVxuXG4gICAgZGVidWcoJ3dyaXR0ZW4nLCB3cml0dGVuLCB0aGlzLl9kcmFpbik7XG5cbiAgICB0aGlzLmZpbmlzaElmRW5kaW5nKCk7XG5cbiAgICByZXR1cm4gd3JpdHRlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyeSB0aGUgdHJhbnNwb3J0LiBPcHRpb25zIG9iamVjdCBpcyBvcHRpb25hbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBMb2dnbHktbGlrZSBxdWVyeSBvcHRpb25zIGZvciB0aGlzIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENvbnRpbnVhdGlvbiB0byByZXNwb25kIHRvIHdoZW4gY29tcGxldGUuXG4gICAqIFRPRE86IFJlZmFjdG9yIG1lLlxuICAgKi9cbiAgcXVlcnkob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gbm9ybWFsaXplUXVlcnkob3B0aW9ucyk7XG4gICAgY29uc3QgZmlsZSA9IHBhdGguam9pbih0aGlzLmRpcm5hbWUsIHRoaXMuZmlsZW5hbWUpO1xuICAgIGxldCBidWZmID0gJyc7XG4gICAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgICBsZXQgcm93ID0gMDtcblxuICAgIGNvbnN0IHN0cmVhbSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oZmlsZSwge1xuICAgICAgZW5jb2Rpbmc6ICd1dGY4J1xuICAgIH0pO1xuXG4gICAgc3RyZWFtLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICBpZiAoc3RyZWFtLnJlYWRhYmxlKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVyci5jb2RlICE9PSAnRU5PRU5UJyA/IGNhbGxiYWNrKGVycikgOiBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICB9KTtcblxuICAgIHN0cmVhbS5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgZGF0YSA9IChidWZmICsgZGF0YSkuc3BsaXQoL1xcbisvKTtcbiAgICAgIGNvbnN0IGwgPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgaSA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5zdGFydCB8fCByb3cgPj0gb3B0aW9ucy5zdGFydCkge1xuICAgICAgICAgIGFkZChkYXRhW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByb3crKztcbiAgICAgIH1cblxuICAgICAgYnVmZiA9IGRhdGFbbF07XG4gICAgfSk7XG5cbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgaWYgKGJ1ZmYpIHtcbiAgICAgICAgYWRkKGJ1ZmYsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub3JkZXIgPT09ICdkZXNjJykge1xuICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5yZXZlcnNlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYWxsYmFjay1yZXR1cm5cbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGQoYnVmZiwgYXR0ZW1wdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbG9nID0gSlNPTi5wYXJzZShidWZmKTtcbiAgICAgICAgaWYgKGNoZWNrKGxvZykpIHtcbiAgICAgICAgICBwdXNoKGxvZyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCFhdHRlbXB0KSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwdXNoKGxvZykge1xuICAgICAgaWYgKFxuICAgICAgICBvcHRpb25zLnJvd3MgJiZcbiAgICAgICAgcmVzdWx0cy5sZW5ndGggPj0gb3B0aW9ucy5yb3dzICYmXG4gICAgICAgIG9wdGlvbnMub3JkZXIgIT09ICdkZXNjJ1xuICAgICAgKSB7XG4gICAgICAgIGlmIChzdHJlYW0ucmVhZGFibGUpIHtcbiAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICAgIGxvZyA9IG9wdGlvbnMuZmllbGRzLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcbiAgICAgICAgICBvYmpba2V5XSA9IGxvZ1trZXldO1xuICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMub3JkZXIgPT09ICdkZXNjJykge1xuICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPj0gb3B0aW9ucy5yb3dzKSB7XG4gICAgICAgICAgcmVzdWx0cy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHRzLnB1c2gobG9nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVjayhsb2cpIHtcbiAgICAgIGlmICghbG9nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBsb2cgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGltZSA9IG5ldyBEYXRlKGxvZy50aW1lc3RhbXApO1xuICAgICAgaWYgKFxuICAgICAgICAob3B0aW9ucy5mcm9tICYmIHRpbWUgPCBvcHRpb25zLmZyb20pIHx8XG4gICAgICAgIChvcHRpb25zLnVudGlsICYmIHRpbWUgPiBvcHRpb25zLnVudGlsKSB8fFxuICAgICAgICAob3B0aW9ucy5sZXZlbCAmJiBvcHRpb25zLmxldmVsICE9PSBsb2cubGV2ZWwpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVRdWVyeShvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgLy8gbGltaXRcbiAgICAgIG9wdGlvbnMucm93cyA9IG9wdGlvbnMucm93cyB8fCBvcHRpb25zLmxpbWl0IHx8IDEwO1xuXG4gICAgICAvLyBzdGFydGluZyByb3cgb2Zmc2V0XG4gICAgICBvcHRpb25zLnN0YXJ0ID0gb3B0aW9ucy5zdGFydCB8fCAwO1xuXG4gICAgICAvLyBub3dcbiAgICAgIG9wdGlvbnMudW50aWwgPSBvcHRpb25zLnVudGlsIHx8IG5ldyBEYXRlKCk7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMudW50aWwgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdGlvbnMudW50aWwgPSBuZXcgRGF0ZShvcHRpb25zLnVudGlsKTtcbiAgICAgIH1cblxuICAgICAgLy8gbm93IC0gMjRcbiAgICAgIG9wdGlvbnMuZnJvbSA9IG9wdGlvbnMuZnJvbSB8fCAob3B0aW9ucy51bnRpbCAtICgyNCAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZnJvbSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9ucy5mcm9tID0gbmV3IERhdGUob3B0aW9ucy5mcm9tKTtcbiAgICAgIH1cblxuICAgICAgLy8gJ2FzYycgb3IgJ2Rlc2MnXG4gICAgICBvcHRpb25zLm9yZGVyID0gb3B0aW9ucy5vcmRlciB8fCAnZGVzYyc7XG5cbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9nIHN0cmVhbSBmb3IgdGhpcyB0cmFuc3BvcnQuIE9wdGlvbnMgb2JqZWN0IGlzIG9wdGlvbmFsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFN0cmVhbSBvcHRpb25zIGZvciB0aGlzIGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyB7U3RyZWFtfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqIFRPRE86IFJlZmFjdG9yIG1lLlxuICAgKi9cbiAgc3RyZWFtKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGZpbGUgPSBwYXRoLmpvaW4odGhpcy5kaXJuYW1lLCB0aGlzLmZpbGVuYW1lKTtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgU3RyZWFtKCk7XG4gICAgY29uc3QgdGFpbCA9IHtcbiAgICAgIGZpbGUsXG4gICAgICBzdGFydDogb3B0aW9ucy5zdGFydFxuICAgIH07XG5cbiAgICBzdHJlYW0uZGVzdHJveSA9IHRhaWxGaWxlKHRhaWwsIChlcnIsIGxpbmUpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgbGluZSk7XG4gICAgICAgIGxpbmUgPSBKU09OLnBhcnNlKGxpbmUpO1xuICAgICAgICBzdHJlYW0uZW1pdCgnbG9nJywgbGluZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdG8gc2VlIHRoZSBmaWxlc2l6ZSBvZi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIG9wZW4oKSB7XG4gICAgLy8gSWYgd2UgZG8gbm90IGhhdmUgYSBmaWxlbmFtZSB0aGVuIHdlIHdlcmUgcGFzc2VkIGEgc3RyZWFtIGFuZFxuICAgIC8vIGRvbid0IG5lZWQgdG8ga2VlcCB0cmFjayBvZiBzaXplLlxuICAgIGlmICghdGhpcy5maWxlbmFtZSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLl9vcGVuaW5nKSByZXR1cm47XG5cbiAgICB0aGlzLl9vcGVuaW5nID0gdHJ1ZTtcblxuICAgIC8vIFN0YXQgdGhlIHRhcmdldCBmaWxlIHRvIGdldCB0aGUgc2l6ZSBhbmQgY3JlYXRlIHRoZSBzdHJlYW0uXG4gICAgdGhpcy5zdGF0KChlcnIsIHNpemUpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgICAgZGVidWcoJ3N0YXQgZG9uZTogJXMgeyBzaXplOiAlcyB9JywgdGhpcy5maWxlbmFtZSwgc2l6ZSk7XG4gICAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgICAgIHRoaXMuX2Rlc3QgPSB0aGlzLl9jcmVhdGVTdHJlYW0odGhpcy5fc3RyZWFtKTtcbiAgICAgIHRoaXMuX29wZW5pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMub25jZSgnb3BlbicsICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3N0cmVhbS5ldmVudE5hbWVzKCkuaW5jbHVkZXMoJ3JvdGF0ZScpKSB7XG4gICAgICAgICAgdGhpcy5fc3RyZWFtLmVtaXQoJ3JvdGF0ZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3JvdGF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0IHRoZSBmaWxlIGFuZCBhc3Nlc3MgaW5mb3JtYXRpb24gaW4gb3JkZXIgdG8gY3JlYXRlIHRoZSBwcm9wZXIgc3RyZWFtLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHN0YXQoY2FsbGJhY2spIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9nZXRGaWxlKCk7XG4gICAgY29uc3QgZnVsbHBhdGggPSBwYXRoLmpvaW4odGhpcy5kaXJuYW1lLCB0YXJnZXQpO1xuXG4gICAgZnMuc3RhdChmdWxscGF0aCwgKGVyciwgc3RhdCkgPT4ge1xuICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgZGVidWcoJ0VOT0VOVFx1MDBBMG9rJywgZnVsbHBhdGgpO1xuICAgICAgICAvLyBVcGRhdGUgaW50ZXJuYWxseSB0cmFja2VkIGZpbGVuYW1lIHdpdGggdGhlIG5ldyB0YXJnZXQgbmFtZS5cbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IHRhcmdldDtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGRlYnVnKGBlcnIgJHtlcnIuY29kZX0gJHtmdWxscGF0aH1gKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3RhdCB8fCB0aGlzLl9uZWVkc05ld0ZpbGUoc3RhdC5zaXplKSkge1xuICAgICAgICAvLyBJZiBgc3RhdHMuc2l6ZWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBgbWF4c2l6ZWAgZm9yIHRoaXNcbiAgICAgICAgLy8gaW5zdGFuY2UgdGhlbiB0cnkgYWdhaW4uXG4gICAgICAgIHJldHVybiB0aGlzLl9pbmNGaWxlKCgpID0+IHRoaXMuc3RhdChjYWxsYmFjaykpO1xuICAgICAgfVxuXG4gICAgICAvLyBPbmNlIHdlIGhhdmUgZmlndXJlZCBvdXQgd2hhdCB0aGUgZmlsZW5hbWUgaXMsIHNldCBpdFxuICAgICAgLy8gYW5kIHJldHVybiB0aGUgc2l6ZS5cbiAgICAgIHRoaXMuZmlsZW5hbWUgPSB0YXJnZXQ7XG4gICAgICBjYWxsYmFjayhudWxsLCBzdGF0LnNpemUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgc3RyZWFtIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGNsb3NlKGNiKSB7XG4gICAgaWYgKCF0aGlzLl9zdHJlYW0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9zdHJlYW0uZW5kKCgpID0+IHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICBjYigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbGxiYWNrLXJldHVyblxuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCdmbHVzaCcpO1xuICAgICAgdGhpcy5lbWl0KCdjbG9zZWQnKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPOiBhZGQgbWV0aG9kIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIF9uZWVkc05ld0ZpbGUoc2l6ZSkge1xuICAgIHNpemUgPSBzaXplIHx8IHRoaXMuX3NpemU7XG4gICAgcmV0dXJuIHRoaXMubWF4c2l6ZSAmJiBzaXplID49IHRoaXMubWF4c2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPOiBhZGQgbWV0aG9kIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBfb25FcnJvcihlcnIpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPOiBhZGQgbWV0aG9kIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7bWl4ZWR9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICovXG4gIF9zZXR1cFN0cmVhbShzdHJlYW0pIHtcbiAgICBzdHJlYW0ub24oJ2Vycm9yJywgdGhpcy5fb25FcnJvcik7XG5cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9XG5cbiAgLyoqXG4gICAqIFRPRE86IGFkZCBtZXRob2QgZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgX2NsZWFudXBTdHJlYW0oc3RyZWFtKSB7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHRoaXMuX29uRXJyb3IpO1xuICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPOiBhZGQgbWV0aG9kIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgX3JvdGF0ZUZpbGUoKSB7XG4gICAgdGhpcy5faW5jRmlsZSgoKSA9PiB0aGlzLm9wZW4oKSk7XG4gIH1cblxuICAvKipcbiAgICogVW5waXBlIGZyb20gdGhlIHN0cmVhbSB0aGF0IGhhcyBiZWVuIG1hcmtlZCBhcyBmdWxsIGFuZCBlbmQgaXQgc28gaXRcbiAgICogZmx1c2hlcyB0byBkaXNrLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIGZvciB3aGVuIHRoZSBjdXJyZW50IGZpbGUgaGFzIGNsb3NlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9lbmRTdHJlYW0oY2FsbGJhY2sgPSAoKSA9PiB7IH0pIHtcbiAgICBpZiAodGhpcy5fZGVzdCkge1xuICAgICAgdGhpcy5fc3RyZWFtLnVucGlwZSh0aGlzLl9kZXN0KTtcbiAgICAgIHRoaXMuX2Rlc3QuZW5kKCgpID0+IHtcbiAgICAgICAgdGhpcy5fY2xlYW51cFN0cmVhbSh0aGlzLl9kZXN0KTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjaygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbGxiYWNrLXJldHVyblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBXcml0YWJsZVN0cmVhbSBmb3IgdGhlIGFjdGl2ZSBmaWxlIG9uIHRoaXMgaW5zdGFuY2UuIElmIHdlXG4gICAqIHNob3VsZCBnemlwIHRoZSBmaWxlIHRoZW4gYSB6bGliIHN0cmVhbSBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbX0gc291cmNlIFx1MjAxM1Bhc3NUaHJvdWdoIHRvIHBpcGUgdG8gdGhlIGZpbGUgd2hlbiBvcGVuLlxuICAgKiBAcmV0dXJucyB7V3JpdGFibGVTdHJlYW19IFN0cmVhbSB0aGF0IHdyaXRlcyB0byBkaXNrIGZvciB0aGUgYWN0aXZlIGZpbGUuXG4gICAqL1xuICBfY3JlYXRlU3RyZWFtKHNvdXJjZSkge1xuICAgIGNvbnN0IGZ1bGxwYXRoID0gcGF0aC5qb2luKHRoaXMuZGlybmFtZSwgdGhpcy5maWxlbmFtZSk7XG5cbiAgICBkZWJ1ZygnY3JlYXRlIHN0cmVhbSBzdGFydCcsIGZ1bGxwYXRoLCB0aGlzLm9wdGlvbnMpO1xuICAgIGNvbnN0IGRlc3QgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShmdWxscGF0aCwgdGhpcy5vcHRpb25zKVxuICAgICAgLy8gVE9ETzogV2hhdCBzaG91bGQgd2UgZG8gd2l0aCBlcnJvcnMgaGVyZT9cbiAgICAgIC5vbignZXJyb3InLCBlcnIgPT4gZGVidWcoZXJyKSlcbiAgICAgIC5vbignY2xvc2UnLCAoKSA9PiBkZWJ1ZygnY2xvc2UnLCBkZXN0LnBhdGgsIGRlc3QuYnl0ZXNXcml0dGVuKSlcbiAgICAgIC5vbignb3BlbicsICgpID0+IHtcbiAgICAgICAgZGVidWcoJ2ZpbGUgb3BlbiBvaycsIGZ1bGxwYXRoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdvcGVuJywgZnVsbHBhdGgpO1xuICAgICAgICBzb3VyY2UucGlwZShkZXN0KTtcblxuICAgICAgICAvLyBJZiByb3RhdGlvbiBvY2N1cmVkIGR1cmluZyB0aGUgb3BlbiBvcGVyYXRpb24gdGhlbiB3ZSBpbW1lZGlhdGVseVxuICAgICAgICAvLyBzdGFydCB3cml0aW5nIHRvIGEgbmV3IFBhc3NUaHJvdWdoLCBiZWdpbiBvcGVuaW5nIHRoZSBuZXh0IGZpbGVcbiAgICAgICAgLy8gYW5kIGNsZWFudXAgdGhlIHByZXZpb3VzIHNvdXJjZSBhbmQgZGVzdCBvbmNlIHRoZSBzb3VyY2UgaGFzIGRyYWluZWQuXG4gICAgICAgIGlmICh0aGlzLnJvdGF0ZWRXaGlsZU9wZW5pbmcpIHtcbiAgICAgICAgICB0aGlzLl9zdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2goKTtcbiAgICAgICAgICB0aGlzLl9zdHJlYW0uc2V0TWF4TGlzdGVuZXJzKDMwKTtcbiAgICAgICAgICB0aGlzLl9yb3RhdGVGaWxlKCk7XG4gICAgICAgICAgdGhpcy5yb3RhdGVkV2hpbGVPcGVuaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5fY2xlYW51cFN0cmVhbShkZXN0KTtcbiAgICAgICAgICBzb3VyY2UuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgZGVidWcoJ2NyZWF0ZSBzdHJlYW0gb2snLCBmdWxscGF0aCk7XG4gICAgaWYgKHRoaXMuemlwcGVkQXJjaGl2ZSkge1xuICAgICAgY29uc3QgZ3ppcCA9IHpsaWIuY3JlYXRlR3ppcCgpO1xuICAgICAgZ3ppcC5waXBlKGRlc3QpO1xuICAgICAgcmV0dXJuIGd6aXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICAvKipcbiAgICogVE9ETzogYWRkIG1ldGhvZCBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBfaW5jRmlsZShjYWxsYmFjaykge1xuICAgIGRlYnVnKCdfaW5jRmlsZScsIHRoaXMuZmlsZW5hbWUpO1xuICAgIGNvbnN0IGV4dCA9IHBhdGguZXh0bmFtZSh0aGlzLl9iYXNlbmFtZSk7XG4gICAgY29uc3QgYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lKHRoaXMuX2Jhc2VuYW1lLCBleHQpO1xuXG4gICAgaWYgKCF0aGlzLnRhaWxhYmxlKSB7XG4gICAgICB0aGlzLl9jcmVhdGVkICs9IDE7XG4gICAgICB0aGlzLl9jaGVja01heEZpbGVzSW5jcmVtZW50aW5nKGV4dCwgYmFzZW5hbWUsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY2hlY2tNYXhGaWxlc1RhaWxhYmxlKGV4dCwgYmFzZW5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbmV4dCBmaWxlbmFtZSB0byB1c2UgZm9yIHRoaXMgaW5zdGFuY2UgaW4gdGhlIGNhc2UgdGhhdCBsb2dcbiAgICogZmlsZXNpemVzIGFyZSBiZWluZyBjYXBwZWQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRGaWxlKCkge1xuICAgIGNvbnN0IGV4dCA9IHBhdGguZXh0bmFtZSh0aGlzLl9iYXNlbmFtZSk7XG4gICAgY29uc3QgYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lKHRoaXMuX2Jhc2VuYW1lLCBleHQpO1xuICAgIGNvbnN0IGlzUm90YXRpb24gPSB0aGlzLnJvdGF0aW9uRm9ybWF0XG4gICAgICA/IHRoaXMucm90YXRpb25Gb3JtYXQoKVxuICAgICAgOiB0aGlzLl9jcmVhdGVkO1xuXG4gICAgLy8gQ2F2ZWF0IGVtcHRvciAoaW5kZXh6ZXJvKTogcm90YXRpb25Gb3JtYXQoKSB3YXMgYnJva2VuIGJ5IGRlc2lnbiBXaGVuXG4gICAgLy8gY29tYmluZWQgd2l0aCBtYXggZmlsZXMgYmVjYXVzZSB0aGUgc2V0IG9mIGZpbGVzIHRvIHVubGluayBpcyBuZXZlclxuICAgIC8vIHN0b3JlZC5cbiAgICBjb25zdCB0YXJnZXQgPSAhdGhpcy50YWlsYWJsZSAmJiB0aGlzLl9jcmVhdGVkXG4gICAgICA/IGAke2Jhc2VuYW1lfSR7aXNSb3RhdGlvbn0ke2V4dH1gXG4gICAgICA6IGAke2Jhc2VuYW1lfSR7ZXh0fWA7XG5cbiAgICByZXR1cm4gdGhpcy56aXBwZWRBcmNoaXZlICYmICF0aGlzLnRhaWxhYmxlXG4gICAgICA/IGAke3RhcmdldH0uZ3pgXG4gICAgICA6IHRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgdGhlIG51bWJlciBvZiBmaWxlcyBjcmVhdGVkIG9yIGNoZWNrZWQgYnkgdGhpcyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHttaXhlZH0gZXh0IC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge21peGVkfSBiYXNlbmFtZSAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHttaXhlZH0gY2FsbGJhY2sgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tNYXhGaWxlc0luY3JlbWVudGluZyhleHQsIGJhc2VuYW1lLCBjYWxsYmFjaykge1xuICAgIC8vIENoZWNrIGZvciBtYXhGaWxlcyBvcHRpb24gYW5kIGRlbGV0ZSBmaWxlLlxuICAgIGlmICghdGhpcy5tYXhGaWxlcyB8fCB0aGlzLl9jcmVhdGVkIDwgdGhpcy5tYXhGaWxlcykge1xuICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkZXN0ID0gdGhpcy5fY3JlYXRlZCAtIHRoaXMubWF4RmlsZXM7XG4gICAgY29uc3QgaXNPbGRlc3QgPSBvbGRlc3QgIT09IDAgPyBvbGRlc3QgOiAnJztcbiAgICBjb25zdCBpc1ppcHBlZCA9IHRoaXMuemlwcGVkQXJjaGl2ZSA/ICcuZ3onIDogJyc7XG4gICAgY29uc3QgZmlsZVBhdGggPSBgJHtiYXNlbmFtZX0ke2lzT2xkZXN0fSR7ZXh0fSR7aXNaaXBwZWR9YDtcbiAgICBjb25zdCB0YXJnZXQgPSBwYXRoLmpvaW4odGhpcy5kaXJuYW1lLCBmaWxlUGF0aCk7XG5cbiAgICBmcy51bmxpbmsodGFyZ2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUm9sbCBmaWxlcyBmb3J3YXJkIGJhc2VkIG9uIGludGVnZXIsIHVwIHRvIG1heEZpbGVzLiBlLmcuIGlmIGJhc2UgaWZcbiAgICogZmlsZS5sb2cgYW5kIGl0IGJlY29tZXMgb3ZlcnNpemVkLCByb2xsIHRvIGZpbGUxLmxvZywgYW5kIGFsbG93IGZpbGUubG9nXG4gICAqIHRvIGJlIHJlLXVzZWQuIElmIGZpbGUgaXMgb3ZlcnNpemVkIGFnYWluLCByb2xsIGZpbGUxLmxvZyB0byBmaWxlMi5sb2csXG4gICAqIHJvbGwgZmlsZS5sb2cgdG8gZmlsZTEubG9nLCBhbmQgc28gb24uXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGV4dCAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHttaXhlZH0gYmFzZW5hbWUgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGNhbGxiYWNrIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrTWF4RmlsZXNUYWlsYWJsZShleHQsIGJhc2VuYW1lLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHRhc2tzID0gW107XG4gICAgaWYgKCF0aGlzLm1heEZpbGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY29uc3QgaXNaaXBwZWQgPSB0aGlzLnppcHBlZEFyY2hpdmUgPyAnLmd6JyA6ICcnO1xuICAgIGNvbnN0IGlzWmlwcGVkID0gdGhpcy56aXBwZWRBcmNoaXZlID8gJy5neicgOiAnJztcbiAgICBmb3IgKGxldCB4ID0gdGhpcy5tYXhGaWxlcyAtIDE7IHggPiAxOyB4LS0pIHtcbiAgICAgIHRhc2tzLnB1c2goZnVuY3Rpb24gKGksIGNiKSB7XG4gICAgICAgIGxldCBmaWxlTmFtZSA9IGAke2Jhc2VuYW1lfSR7KGkgLSAxKX0ke2V4dH0ke2lzWmlwcGVkfWA7XG4gICAgICAgIGNvbnN0IHRtcHBhdGggPSBwYXRoLmpvaW4odGhpcy5kaXJuYW1lLCBmaWxlTmFtZSk7XG5cbiAgICAgICAgZnMuZXhpc3RzKHRtcHBhdGgsIGV4aXN0cyA9PiB7XG4gICAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihudWxsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWxlTmFtZSA9IGAke2Jhc2VuYW1lfSR7aX0ke2V4dH0ke2lzWmlwcGVkfWA7XG4gICAgICAgICAgZnMucmVuYW1lKHRtcHBhdGgsIHBhdGguam9pbih0aGlzLmRpcm5hbWUsIGZpbGVOYW1lKSwgY2IpO1xuICAgICAgICB9KTtcbiAgICAgIH0uYmluZCh0aGlzLCB4KSk7XG4gICAgfVxuXG4gICAgYXN5bmNTZXJpZXModGFza3MsICgpID0+IHtcbiAgICAgIGZzLnJlbmFtZShcbiAgICAgICAgcGF0aC5qb2luKHRoaXMuZGlybmFtZSwgYCR7YmFzZW5hbWV9JHtleHR9YCksXG4gICAgICAgIHBhdGguam9pbih0aGlzLmRpcm5hbWUsIGAke2Jhc2VuYW1lfTEke2V4dH0ke2lzWmlwcGVkfWApLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVMb2dEaXJJZk5vdEV4aXN0KGRpclBhdGgpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zeW5jICovXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGRpclBhdGgpKSB7XG4gICAgICBmcy5ta2RpclN5bmMoZGlyUGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tc3luYyAqL1xuICB9XG59O1xuIiwgIi8qKlxuICogaHR0cC5qczogVHJhbnNwb3J0IGZvciBvdXRwdXR0aW5nIHRvIGEganNvbi1ycGNzZXJ2ZXIuXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IHsgU3RyZWFtIH0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKTtcbmNvbnN0IFRyYW5zcG9ydFN0cmVhbSA9IHJlcXVpcmUoJ3dpbnN0b24tdHJhbnNwb3J0Jyk7XG5jb25zdCBqc29uU3RyaW5naWZ5ID0gcmVxdWlyZSgnc2FmZS1zdGFibGUtc3RyaW5naWZ5Jyk7XG5cbi8qKlxuICogVHJhbnNwb3J0IGZvciBvdXRwdXR0aW5nIHRvIGEganNvbi1ycGMgc2VydmVyLlxuICogQHR5cGUge1N0cmVhbX1cbiAqIEBleHRlbmRzIHtUcmFuc3BvcnRTdHJlYW19XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgSHR0cCBleHRlbmRzIFRyYW5zcG9ydFN0cmVhbSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIEh0dHAgdHJhbnNwb3J0IG9iamVjdCByZXNwb25zaWJsZSBmb3JcbiAgICogcGVyc2lzdGluZyBsb2cgbWVzc2FnZXMgYW5kIG1ldGFkYXRhIHRvIGEgdGVybWluYWwgb3IgVFRZLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IFtvcHRpb25zPXt9XSAtIE9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCAnaHR0cCc7XG4gICAgdGhpcy5zc2wgPSAhIW9wdGlvbnMuc3NsO1xuICAgIHRoaXMuaG9zdCA9IG9wdGlvbnMuaG9zdCB8fCAnbG9jYWxob3N0JztcbiAgICB0aGlzLnBvcnQgPSBvcHRpb25zLnBvcnQ7XG4gICAgdGhpcy5hdXRoID0gb3B0aW9ucy5hdXRoO1xuICAgIHRoaXMucGF0aCA9IG9wdGlvbnMucGF0aCB8fCAnJztcbiAgICB0aGlzLmFnZW50ID0gb3B0aW9ucy5hZ2VudDtcbiAgICB0aGlzLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgdGhpcy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICB0aGlzLmJhdGNoID0gb3B0aW9ucy5iYXRjaCB8fCBmYWxzZTtcbiAgICB0aGlzLmJhdGNoSW50ZXJ2YWwgPSBvcHRpb25zLmJhdGNoSW50ZXJ2YWwgfHwgNTAwMDtcbiAgICB0aGlzLmJhdGNoQ291bnQgPSBvcHRpb25zLmJhdGNoQ291bnQgfHwgMTA7XG4gICAgdGhpcy5iYXRjaE9wdGlvbnMgPSBbXTtcbiAgICB0aGlzLmJhdGNoVGltZW91dElEID0gLTE7XG4gICAgdGhpcy5iYXRjaENhbGxiYWNrID0ge307XG5cbiAgICBpZiAoIXRoaXMucG9ydCkge1xuICAgICAgdGhpcy5wb3J0ID0gdGhpcy5zc2wgPyA0NDMgOiA4MDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29yZSBsb2dnaW5nIG1ldGhvZCBleHBvc2VkIHRvIFdpbnN0b24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGxvZyhpbmZvLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3JlcXVlc3QoaW5mbywgbnVsbCwgbnVsbCwgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAocmVzICYmIHJlcy5zdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgZXJyID0gbmV3IEVycm9yKGBJbnZhbGlkIEhUVFAgU3RhdHVzIENvZGU6ICR7cmVzLnN0YXR1c0NvZGV9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5lbWl0KCd3YXJuJywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbG9nZ2VkJywgaW5mbyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZW1hcms6IChqY3J1Z3p6KSBGaXJlIGFuZCBmb3JnZXQgaGVyZSBzbyByZXF1ZXN0cyBkb250IGNhdXNlIGJ1ZmZlcmluZ1xuICAgIC8vIGFuZCBibG9jayBtb3JlIHJlcXVlc3RzIGZyb20gaGFwcGVuaW5nP1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUXVlcnkgdGhlIHRyYW5zcG9ydC4gT3B0aW9ucyBvYmplY3QgaXMgb3B0aW9uYWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gIExvZ2dseS1saWtlIHF1ZXJ5IG9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ29udGludWF0aW9uIHRvIHJlc3BvbmQgdG8gd2hlbiBjb21wbGV0ZS5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHF1ZXJ5KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1ldGhvZDogJ3F1ZXJ5JyxcbiAgICAgIHBhcmFtczogdGhpcy5ub3JtYWxpemVRdWVyeShvcHRpb25zKVxuICAgIH07XG5cbiAgICBjb25zdCBhdXRoID0gb3B0aW9ucy5wYXJhbXMuYXV0aCB8fCBudWxsO1xuICAgIGRlbGV0ZSBvcHRpb25zLnBhcmFtcy5hdXRoO1xuXG4gICAgY29uc3QgcGF0aCA9IG9wdGlvbnMucGFyYW1zLnBhdGggfHwgbnVsbDtcbiAgICBkZWxldGUgb3B0aW9ucy5wYXJhbXMucGF0aDtcblxuICAgIHRoaXMuX3JlcXVlc3Qob3B0aW9ucywgYXV0aCwgcGF0aCwgKGVyciwgcmVzLCBib2R5KSA9PiB7XG4gICAgICBpZiAocmVzICYmIHJlcy5zdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgZXJyID0gbmV3IEVycm9yKGBJbnZhbGlkIEhUVFAgU3RhdHVzIENvZGU6ICR7cmVzLnN0YXR1c0NvZGV9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBib2R5KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9nIHN0cmVhbSBmb3IgdGhpcyB0cmFuc3BvcnQuIE9wdGlvbnMgb2JqZWN0IGlzIG9wdGlvbmFsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFN0cmVhbSBvcHRpb25zIGZvciB0aGlzIGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyB7U3RyZWFtfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb25cbiAgICovXG4gIHN0cmVhbShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgU3RyZWFtKCk7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1ldGhvZDogJ3N0cmVhbScsXG4gICAgICBwYXJhbXM6IG9wdGlvbnNcbiAgICB9O1xuXG4gICAgY29uc3QgcGF0aCA9IG9wdGlvbnMucGFyYW1zLnBhdGggfHwgbnVsbDtcbiAgICBkZWxldGUgb3B0aW9ucy5wYXJhbXMucGF0aDtcblxuICAgIGNvbnN0IGF1dGggPSBvcHRpb25zLnBhcmFtcy5hdXRoIHx8IG51bGw7XG4gICAgZGVsZXRlIG9wdGlvbnMucGFyYW1zLmF1dGg7XG5cbiAgICBsZXQgYnVmZiA9ICcnO1xuICAgIGNvbnN0IHJlcSA9IHRoaXMuX3JlcXVlc3Qob3B0aW9ucywgYXV0aCwgcGF0aCk7XG5cbiAgICBzdHJlYW0uZGVzdHJveSA9ICgpID0+IHJlcS5kZXN0cm95KCk7XG4gICAgcmVxLm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICBkYXRhID0gKGJ1ZmYgKyBkYXRhKS5zcGxpdCgvXFxuKy8pO1xuICAgICAgY29uc3QgbCA9IGRhdGEubGVuZ3RoIC0gMTtcblxuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnbG9nJywgSlNPTi5wYXJzZShkYXRhW2ldKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBidWZmID0gZGF0YVtsXTtcbiAgICB9KTtcbiAgICByZXEub24oJ2Vycm9yJywgZXJyID0+IHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycikpO1xuXG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgcmVxdWVzdCB0byBhIHdpbnN0b25kIHNlcnZlciBvciBhbnkgaHR0cCBzZXJ2ZXIgd2hpY2ggY2FuXG4gICAqIGhhbmRsZSBqc29uLXJwYy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gc2VudCB0aGUgcmVxdWVzdC5cbiAgICogQHBhcmFtIHtPYmplY3Q/fSBhdXRoIC0gYXV0aGVudGljYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHJlcXVlc3QgcGF0aFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENvbnRpbnVhdGlvbiB0byByZXNwb25kIHRvIHdoZW4gY29tcGxldGUuXG4gICAqL1xuICBfcmVxdWVzdChvcHRpb25zLCBhdXRoLCBwYXRoLCBjYWxsYmFjaykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgYXV0aCA9IGF1dGggfHwgdGhpcy5hdXRoO1xuICAgIHBhdGggPSBwYXRoIHx8IHRoaXMucGF0aCB8fCAnJztcblxuICAgIGlmICh0aGlzLmJhdGNoKSB7XG4gICAgICB0aGlzLl9kb0JhdGNoKG9wdGlvbnMsIGNhbGxiYWNrLCBhdXRoLCBwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZG9SZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCBhdXRoLCBwYXRoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBvciBtZW1vcml6ZSB0aGUgb3B0aW9ucyBhY2NvcmRpbmcgdG8gYmF0Y2ggY29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zIC0gT3B0aW9ucyB0byBzZW50IHRoZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENvbnRpbnVhdGlvbiB0byByZXNwb25kIHRvIHdoZW4gY29tcGxldGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0P30gYXV0aCAtIGF1dGhlbnRpY2F0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSByZXF1ZXN0IHBhdGhcbiAgICovXG4gIF9kb0JhdGNoKG9wdGlvbnMsIGNhbGxiYWNrLCBhdXRoLCBwYXRoKSB7XG4gICAgdGhpcy5iYXRjaE9wdGlvbnMucHVzaChvcHRpb25zKTtcbiAgICBpZiAodGhpcy5iYXRjaE9wdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBGaXJzdCBtZXNzYWdlIHN0b3JlZCwgaXQncyB0aW1lIHRvIHN0YXJ0IHRoZSB0aW1lb3V0IVxuICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgdGhpcy5iYXRjaENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLmJhdGNoVGltZW91dElEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRpbWVvdXQgaXMgcmVhY2hlZCwgc2VuZCBhbGwgbWVzc2FnZXMgdG8gZW5kcG9pbnRcbiAgICAgICAgbWUuYmF0Y2hUaW1lb3V0SUQgPSAtMTtcbiAgICAgICAgbWUuX2RvQmF0Y2hSZXF1ZXN0KG1lLmJhdGNoQ2FsbGJhY2ssIGF1dGgsIHBhdGgpO1xuICAgICAgfSwgdGhpcy5iYXRjaEludGVydmFsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYmF0Y2hPcHRpb25zLmxlbmd0aCA9PT0gdGhpcy5iYXRjaENvdW50KSB7XG4gICAgICAvLyBtYXggYmF0Y2ggY291bnQgaXMgcmVhY2hlZCwgc2VuZCBhbGwgbWVzc2FnZXMgdG8gZW5kcG9pbnRcbiAgICAgIHRoaXMuX2RvQmF0Y2hSZXF1ZXN0KHRoaXMuYmF0Y2hDYWxsYmFjaywgYXV0aCwgcGF0aCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlIGEgcmVxdWVzdCB3aXRoIHRoZSBtZW1vcml6ZWQgYmF0Y2ggb3B0aW9ucywgc3RvcCB0aGUgYmF0Y2ggdGltZW91dFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENvbnRpbnVhdGlvbiB0byByZXNwb25kIHRvIHdoZW4gY29tcGxldGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0P30gYXV0aCAtIGF1dGhlbnRpY2F0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSByZXF1ZXN0IHBhdGhcbiAgICovXG4gIF9kb0JhdGNoUmVxdWVzdChjYWxsYmFjaywgYXV0aCwgcGF0aCkge1xuICAgIGlmICh0aGlzLmJhdGNoVGltZW91dElEID4gMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYmF0Y2hUaW1lb3V0SUQpO1xuICAgICAgdGhpcy5iYXRjaFRpbWVvdXRJRCA9IC0xO1xuICAgIH1cbiAgICBjb25zdCBiYXRjaE9wdGlvbnNDb3B5ID0gdGhpcy5iYXRjaE9wdGlvbnMuc2xpY2UoKTtcbiAgICB0aGlzLmJhdGNoT3B0aW9ucyA9IFtdO1xuICAgIHRoaXMuX2RvUmVxdWVzdChiYXRjaE9wdGlvbnNDb3B5LCBjYWxsYmFjaywgYXV0aCwgcGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIHJlcXVlc3QgdG8gYSB3aW5zdG9uZCBzZXJ2ZXIgb3IgYW55IGh0dHAgc2VydmVyIHdoaWNoIGNhblxuICAgKiBoYW5kbGUganNvbi1ycGMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMgLSBPcHRpb25zIHRvIHNlbnQgdGhlIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ29udGludWF0aW9uIHRvIHJlc3BvbmQgdG8gd2hlbiBjb21wbGV0ZS5cbiAgICogQHBhcmFtIHtPYmplY3Q/fSBhdXRoIC0gYXV0aGVudGljYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHJlcXVlc3QgcGF0aFxuICAgKi9cbiAgX2RvUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaywgYXV0aCwgcGF0aCkge1xuICAgIC8vIFByZXBhcmUgb3B0aW9ucyBmb3Igb3V0Z29pbmcgSFRUUCByZXF1ZXN0XG4gICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyk7XG4gICAgaWYgKGF1dGggJiYgYXV0aC5iZWFyZXIpIHtcbiAgICAgIGhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHthdXRoLmJlYXJlcn1gO1xuICAgIH1cbiAgICBjb25zdCByZXEgPSAodGhpcy5zc2wgPyBodHRwcyA6IGh0dHApLnJlcXVlc3Qoe1xuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBob3N0OiB0aGlzLmhvc3QsXG4gICAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgICBwYXRoOiBgLyR7cGF0aC5yZXBsYWNlKC9eXFwvLywgJycpfWAsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgYXV0aDogKGF1dGggJiYgYXV0aC51c2VybmFtZSAmJiBhdXRoLnBhc3N3b3JkKSA/IChgJHthdXRoLnVzZXJuYW1lfToke2F1dGgucGFzc3dvcmR9YCkgOiAnJyxcbiAgICAgIGFnZW50OiB0aGlzLmFnZW50XG4gICAgfSk7XG5cbiAgICByZXEub24oJ2Vycm9yJywgY2FsbGJhY2spO1xuICAgIHJlcS5vbigncmVzcG9uc2UnLCByZXMgPT4gKFxuICAgICAgcmVzLm9uKCdlbmQnLCAoKSA9PiBjYWxsYmFjayhudWxsLCByZXMpKS5yZXN1bWUoKVxuICAgICkpO1xuICAgIHJlcS5lbmQoQnVmZmVyLmZyb20oanNvblN0cmluZ2lmeShvcHRpb25zLCB0aGlzLm9wdGlvbnMucmVwbGFjZXIpLCAndXRmOCcpKTtcbiAgfVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzU3RyZWFtID0gc3RyZWFtID0+XG5cdHN0cmVhbSAhPT0gbnVsbCAmJlxuXHR0eXBlb2Ygc3RyZWFtID09PSAnb2JqZWN0JyAmJlxuXHR0eXBlb2Ygc3RyZWFtLnBpcGUgPT09ICdmdW5jdGlvbic7XG5cbmlzU3RyZWFtLndyaXRhYmxlID0gc3RyZWFtID0+XG5cdGlzU3RyZWFtKHN0cmVhbSkgJiZcblx0c3RyZWFtLndyaXRhYmxlICE9PSBmYWxzZSAmJlxuXHR0eXBlb2Ygc3RyZWFtLl93cml0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHR0eXBlb2Ygc3RyZWFtLl93cml0YWJsZVN0YXRlID09PSAnb2JqZWN0JztcblxuaXNTdHJlYW0ucmVhZGFibGUgPSBzdHJlYW0gPT5cblx0aXNTdHJlYW0oc3RyZWFtKSAmJlxuXHRzdHJlYW0ucmVhZGFibGUgIT09IGZhbHNlICYmXG5cdHR5cGVvZiBzdHJlYW0uX3JlYWQgPT09ICdmdW5jdGlvbicgJiZcblx0dHlwZW9mIHN0cmVhbS5fcmVhZGFibGVTdGF0ZSA9PT0gJ29iamVjdCc7XG5cbmlzU3RyZWFtLmR1cGxleCA9IHN0cmVhbSA9PlxuXHRpc1N0cmVhbS53cml0YWJsZShzdHJlYW0pICYmXG5cdGlzU3RyZWFtLnJlYWRhYmxlKHN0cmVhbSk7XG5cbmlzU3RyZWFtLnRyYW5zZm9ybSA9IHN0cmVhbSA9PlxuXHRpc1N0cmVhbS5kdXBsZXgoc3RyZWFtKSAmJlxuXHR0eXBlb2Ygc3RyZWFtLl90cmFuc2Zvcm0gPT09ICdmdW5jdGlvbic7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJlYW07XG4iLCAiLyoqXG4gKiBzdHJlYW0uanM6IFRyYW5zcG9ydCBmb3Igb3V0cHV0dGluZyB0byBhbnkgYXJiaXRyYXJ5IHN0cmVhbS5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpc1N0cmVhbSA9IHJlcXVpcmUoJ2lzLXN0cmVhbScpO1xuY29uc3QgeyBNRVNTQUdFIH0gPSByZXF1aXJlKCd0cmlwbGUtYmVhbScpO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgVHJhbnNwb3J0U3RyZWFtID0gcmVxdWlyZSgnd2luc3Rvbi10cmFuc3BvcnQnKTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgZm9yIG91dHB1dHRpbmcgdG8gYW55IGFyYml0cmFyeSBzdHJlYW0uXG4gKiBAdHlwZSB7U3RyZWFtfVxuICogQGV4dGVuZHMge1RyYW5zcG9ydFN0cmVhbX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTdHJlYW0gZXh0ZW5kcyBUcmFuc3BvcnRTdHJlYW0ge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBDb25zb2xlIHRyYW5zcG9ydCBvYmplY3QgcmVzcG9uc2libGUgZm9yXG4gICAqIHBlcnNpc3RpbmcgbG9nIG1lc3NhZ2VzIGFuZCBtZXRhZGF0YSB0byBhIHRlcm1pbmFsIG9yIFRUWS5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPcHRpb25zIGZvciB0aGlzIGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICBpZiAoIW9wdGlvbnMuc3RyZWFtIHx8ICFpc1N0cmVhbShvcHRpb25zLnN0cmVhbSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJlYW0gaXMgcmVxdWlyZWQuJyk7XG4gICAgfVxuXG4gICAgLy8gV2UgbmVlZCB0byBsaXN0ZW4gZm9yIGRyYWluIGV2ZW50cyB3aGVuIHdyaXRlKCkgcmV0dXJucyBmYWxzZS4gVGhpcyBjYW5cbiAgICAvLyBtYWtlIG5vZGUgbWFkIGF0IHRpbWVzLlxuICAgIHRoaXMuX3N0cmVhbSA9IG9wdGlvbnMuc3RyZWFtO1xuICAgIHRoaXMuX3N0cmVhbS5zZXRNYXhMaXN0ZW5lcnMoSW5maW5pdHkpO1xuICAgIHRoaXMuaXNPYmplY3RNb2RlID0gb3B0aW9ucy5zdHJlYW0uX3dyaXRhYmxlU3RhdGUub2JqZWN0TW9kZTtcbiAgICB0aGlzLmVvbCA9ICh0eXBlb2Ygb3B0aW9ucy5lb2wgPT09ICdzdHJpbmcnKSA/IG9wdGlvbnMuZW9sIDogb3MuRU9MO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcmUgbG9nZ2luZyBtZXRob2QgZXhwb3NlZCB0byBXaW5zdG9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5mbyAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBsb2coaW5mbywgY2FsbGJhY2spIHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5lbWl0KCdsb2dnZWQnLCBpbmZvKSk7XG4gICAgaWYgKHRoaXMuaXNPYmplY3RNb2RlKSB7XG4gICAgICB0aGlzLl9zdHJlYW0ud3JpdGUoaW5mbyk7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYWxsYmFjay1yZXR1cm5cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9zdHJlYW0ud3JpdGUoYCR7aW5mb1tNRVNTQUdFXX0ke3RoaXMuZW9sfWApO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYWxsYmFjay1yZXR1cm5cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG59O1xuIiwgIi8qKlxuICogdHJhbnNwb3J0cy5qczogU2V0IG9mIGFsbCB0cmFuc3BvcnRzIFdpbnN0b24ga25vd3MgYWJvdXQuXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUT0RPOiBhZGQgcHJvcGVydHkgZGVzY3JpcHRpb24uXG4gKiBAdHlwZSB7Q29uc29sZX1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdDb25zb2xlJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldCgpIHtcbiAgICByZXR1cm4gcmVxdWlyZSgnLi9jb25zb2xlJyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFRPRE86IGFkZCBwcm9wZXJ0eSBkZXNjcmlwdGlvbi5cbiAqIEB0eXBlIHtGaWxlfVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0ZpbGUnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0KCkge1xuICAgIHJldHVybiByZXF1aXJlKCcuL2ZpbGUnKTtcbiAgfVxufSk7XG5cbi8qKlxuICogVE9ETzogYWRkIHByb3BlcnR5IGRlc2NyaXB0aW9uLlxuICogQHR5cGUge0h0dHB9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnSHR0cCcsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJy4vaHR0cCcpO1xuICB9XG59KTtcblxuLyoqXG4gKiBUT0RPOiBhZGQgcHJvcGVydHkgZGVzY3JpcHRpb24uXG4gKiBAdHlwZSB7U3RyZWFtfVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1N0cmVhbScsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJy4vc3RyZWFtJyk7XG4gIH1cbn0pO1xuIiwgIi8qKlxuICogaW5kZXguanM6IERlZmF1bHQgc2V0dGluZ3MgZm9yIGFsbCBsZXZlbHMgdGhhdCB3aW5zdG9uIGtub3dzIGFib3V0LlxuICpcbiAqIChDKSAyMDEwIENoYXJsaWUgUm9iYmluc1xuICogTUlUIExJQ0VOQ0VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGxvZ2Zvcm0gPSByZXF1aXJlKCdsb2dmb3JtJyk7XG5jb25zdCB7IGNvbmZpZ3MgfSA9IHJlcXVpcmUoJ3RyaXBsZS1iZWFtJyk7XG5cbi8qKlxuICogRXhwb3J0IGNvbmZpZyBzZXQgZm9yIHRoZSBDTEkuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLmNsaSA9IGxvZ2Zvcm0ubGV2ZWxzKGNvbmZpZ3MuY2xpKTtcblxuLyoqXG4gKiBFeHBvcnQgY29uZmlnIHNldCBmb3IgbnBtLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5ucG0gPSBsb2dmb3JtLmxldmVscyhjb25maWdzLm5wbSk7XG5cbi8qKlxuICogRXhwb3J0IGNvbmZpZyBzZXQgZm9yIHRoZSBzeXNsb2cuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLnN5c2xvZyA9IGxvZ2Zvcm0ubGV2ZWxzKGNvbmZpZ3Muc3lzbG9nKTtcblxuLyoqXG4gKiBIb2lzdCBhZGRDb2xvcnMgZnJvbSBsb2dmb3JtIHdoZXJlIGl0IHdhcyByZWZhY3RvcmVkIGludG8gaW4gd2luc3RvbkAzLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5hZGRDb2xvcnMgPSBsb2dmb3JtLmxldmVscztcbiIsICIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9pc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvaXNBcnJheUxpa2UuanMnKTtcblxudmFyIF9pc0FycmF5TGlrZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0FycmF5TGlrZSk7XG5cbnZhciBfYnJlYWtMb29wID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9icmVha0xvb3AuanMnKTtcblxudmFyIF9icmVha0xvb3AyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJlYWtMb29wKTtcblxudmFyIF9lYWNoT2ZMaW1pdCA9IHJlcXVpcmUoJy4vZWFjaE9mTGltaXQuanMnKTtcblxudmFyIF9lYWNoT2ZMaW1pdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoT2ZMaW1pdCk7XG5cbnZhciBfb25jZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvb25jZS5qcycpO1xuXG52YXIgX29uY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb25jZSk7XG5cbnZhciBfb25seU9uY2UgPSByZXF1aXJlKCcuL2ludGVybmFsL29ubHlPbmNlLmpzJyk7XG5cbnZhciBfb25seU9uY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb25seU9uY2UpO1xuXG52YXIgX3dyYXBBc3luYyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvd3JhcEFzeW5jLmpzJyk7XG5cbnZhciBfd3JhcEFzeW5jMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dyYXBBc3luYyk7XG5cbnZhciBfYXdhaXRpZnkgPSByZXF1aXJlKCcuL2ludGVybmFsL2F3YWl0aWZ5LmpzJyk7XG5cbnZhciBfYXdhaXRpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXdhaXRpZnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBlYWNoT2YgaW1wbGVtZW50YXRpb24gb3B0aW1pemVkIGZvciBhcnJheS1saWtlc1xuZnVuY3Rpb24gZWFjaE9mQXJyYXlMaWtlKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gKDAsIF9vbmNlMi5kZWZhdWx0KShjYWxsYmFjayk7XG4gICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgY29tcGxldGVkID0gMCxcbiAgICAgICAgeyBsZW5ndGggfSA9IGNvbGwsXG4gICAgICAgIGNhbmNlbGVkID0gZmFsc2U7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdGVyYXRvckNhbGxiYWNrKGVyciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuY2VsZWQgPT09IHRydWUpIHJldHVybjtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSBlbHNlIGlmICgrK2NvbXBsZXRlZCA9PT0gbGVuZ3RoIHx8IHZhbHVlID09PSBfYnJlYWtMb29wMi5kZWZhdWx0KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBpdGVyYXRlZShjb2xsW2luZGV4XSwgaW5kZXgsICgwLCBfb25seU9uY2UyLmRlZmF1bHQpKGl0ZXJhdG9yQ2FsbGJhY2spKTtcbiAgICB9XG59XG5cbi8vIGEgZ2VuZXJpYyB2ZXJzaW9uIG9mIGVhY2hPZiB3aGljaCBjYW4gaGFuZGxlIGFycmF5LCBvYmplY3QsIGFuZCBpdGVyYXRvciBjYXNlcy5cbmZ1bmN0aW9uIGVhY2hPZkdlbmVyaWMoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuICgwLCBfZWFjaE9mTGltaXQyLmRlZmF1bHQpKGNvbGwsIEluZmluaXR5LCBpdGVyYXRlZSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIExpa2UgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9LCBleGNlcHQgdGhhdCBpdCBwYXNzZXMgdGhlIGtleSAob3IgaW5kZXgpIGFzIHRoZSBzZWNvbmQgYXJndW1lbnRcbiAqIHRvIHRoZSBpdGVyYXRlZS5cbiAqXG4gKiBAbmFtZSBlYWNoT2ZcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyBmb3JFYWNoT2ZcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH1cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaFxuICogaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgYGtleWAgaXMgdGhlIGl0ZW0ncyBrZXksIG9yIGluZGV4IGluIHRoZSBjYXNlIG9mIGFuIGFycmF5LlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gZGV2Lmpzb24gaXMgYSBmaWxlIGNvbnRhaW5pbmcgYSB2YWxpZCBqc29uIG9iamVjdCBjb25maWcgZm9yIGRldiBlbnZpcm9ubWVudFxuICogLy8gZGV2Lmpzb24gaXMgYSBmaWxlIGNvbnRhaW5pbmcgYSB2YWxpZCBqc29uIG9iamVjdCBjb25maWcgZm9yIHRlc3QgZW52aXJvbm1lbnRcbiAqIC8vIHByb2QuanNvbiBpcyBhIGZpbGUgY29udGFpbmluZyBhIHZhbGlkIGpzb24gb2JqZWN0IGNvbmZpZyBmb3IgcHJvZCBlbnZpcm9ubWVudFxuICogLy8gaW52YWxpZC5qc29uIGlzIGEgZmlsZSB3aXRoIGEgbWFsZm9ybWVkIGpzb24gb2JqZWN0XG4gKlxuICogbGV0IGNvbmZpZ3MgPSB7fTsgLy9nbG9iYWwgdmFyaWFibGVcbiAqIGxldCB2YWxpZENvbmZpZ0ZpbGVNYXAgPSB7ZGV2OiAnZGV2Lmpzb24nLCB0ZXN0OiAndGVzdC5qc29uJywgcHJvZDogJ3Byb2QuanNvbid9O1xuICogbGV0IGludmFsaWRDb25maWdGaWxlTWFwID0ge2RldjogJ2Rldi5qc29uJywgdGVzdDogJ3Rlc3QuanNvbicsIGludmFsaWQ6ICdpbnZhbGlkLmpzb24nfTtcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCByZWFkcyBhIGpzb24gZmlsZSBhbmQgcGFyc2VzIHRoZSBjb250ZW50cyBhcyBqc29uIG9iamVjdFxuICogZnVuY3Rpb24gcGFyc2VGaWxlKGZpbGUsIGtleSwgY2FsbGJhY2spIHtcbiAqICAgICBmcy5yZWFkRmlsZShmaWxlLCBcInV0ZjhcIiwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxiYWNrKGVycik7XG4gKiAgICAgICAgIHRyeSB7XG4gKiAgICAgICAgICAgICBjb25maWdzW2tleV0gPSBKU09OLnBhcnNlKGRhdGEpO1xuICogICAgICAgICB9IGNhdGNoIChlKSB7XG4gKiAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gKiAgICAgICAgIH1cbiAqICAgICAgICAgY2FsbGJhY2soKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqXG4gKiAvLyBVc2luZyBjYWxsYmFja3NcbiAqIGFzeW5jLmZvckVhY2hPZih2YWxpZENvbmZpZ0ZpbGVNYXAsIHBhcnNlRmlsZSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGlmIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGNvbmZpZ3MpO1xuICogICAgICAgICAvLyBjb25maWdzIGlzIG5vdyBhIG1hcCBvZiBKU09OIGRhdGEsIGUuZy5cbiAqICAgICAgICAgLy8geyBkZXY6IC8vcGFyc2VkIGRldi5qc29uLCB0ZXN0OiAvL3BhcnNlZCB0ZXN0Lmpzb24sIHByb2Q6IC8vcGFyc2VkIHByb2QuanNvbn1cbiAqICAgICB9XG4gKiB9KTtcbiAqXG4gKiAvL0Vycm9yIGhhbmRpbmdcbiAqIGFzeW5jLmZvckVhY2hPZihpbnZhbGlkQ29uZmlnRmlsZU1hcCwgcGFyc2VGaWxlLCBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgaWYgKGVycikge1xuICogICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gKiAgICAgICAgIC8vIEpTT04gcGFyc2UgZXJyb3IgZXhjZXB0aW9uXG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coY29uZmlncyk7XG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLmZvckVhY2hPZih2YWxpZENvbmZpZ0ZpbGVNYXAsIHBhcnNlRmlsZSlcbiAqIC50aGVuKCAoKSA9PiB7XG4gKiAgICAgY29uc29sZS5sb2coY29uZmlncyk7XG4gKiAgICAgLy8gY29uZmlncyBpcyBub3cgYSBtYXAgb2YgSlNPTiBkYXRhLCBlLmcuXG4gKiAgICAgLy8geyBkZXY6IC8vcGFyc2VkIGRldi5qc29uLCB0ZXN0OiAvL3BhcnNlZCB0ZXN0Lmpzb24sIHByb2Q6IC8vcGFyc2VkIHByb2QuanNvbn1cbiAqIH0pLmNhdGNoKCBlcnIgPT4ge1xuICogICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAqIH0pO1xuICpcbiAqIC8vRXJyb3IgaGFuZGluZ1xuICogYXN5bmMuZm9yRWFjaE9mKGludmFsaWRDb25maWdGaWxlTWFwLCBwYXJzZUZpbGUpXG4gKiAudGhlbiggKCkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKGNvbmZpZ3MpO1xuICogfSkuY2F0Y2goIGVyciA9PiB7XG4gKiAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICogICAgIC8vIEpTT04gcGFyc2UgZXJyb3IgZXhjZXB0aW9uXG4gKiB9KTtcbiAqXG4gKiAvLyBVc2luZyBhc3luYy9hd2FpdFxuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBhc3luYy5mb3JFYWNoT2YodmFsaWRDb25maWdGaWxlTWFwLCBwYXJzZUZpbGUpO1xuICogICAgICAgICBjb25zb2xlLmxvZyhjb25maWdzKTtcbiAqICAgICAgICAgLy8gY29uZmlncyBpcyBub3cgYSBtYXAgb2YgSlNPTiBkYXRhLCBlLmcuXG4gKiAgICAgICAgIC8vIHsgZGV2OiAvL3BhcnNlZCBkZXYuanNvbiwgdGVzdDogLy9wYXJzZWQgdGVzdC5qc29uLCBwcm9kOiAvL3BhcnNlZCBwcm9kLmpzb259XG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICB9XG4gKiB9XG4gKlxuICogLy9FcnJvciBoYW5kaW5nXG4gKiBhc3luYyAoKSA9PiB7XG4gKiAgICAgdHJ5IHtcbiAqICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGFzeW5jLmZvckVhY2hPZihpbnZhbGlkQ29uZmlnRmlsZU1hcCwgcGFyc2VGaWxlKTtcbiAqICAgICAgICAgY29uc29sZS5sb2coY29uZmlncyk7XG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgLy8gSlNPTiBwYXJzZSBlcnJvciBleGNlcHRpb25cbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBlYWNoT2YoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGVhY2hPZkltcGxlbWVudGF0aW9uID0gKDAsIF9pc0FycmF5TGlrZTIuZGVmYXVsdCkoY29sbCkgPyBlYWNoT2ZBcnJheUxpa2UgOiBlYWNoT2ZHZW5lcmljO1xuICAgIHJldHVybiBlYWNoT2ZJbXBsZW1lbnRhdGlvbihjb2xsLCAoMCwgX3dyYXBBc3luYzIuZGVmYXVsdCkoaXRlcmF0ZWUpLCBjYWxsYmFjayk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfYXdhaXRpZnkyLmRlZmF1bHQpKGVhY2hPZiwgMyk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsiLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IF93aXRob3V0SW5kZXg7XG5mdW5jdGlvbiBfd2l0aG91dEluZGV4KGl0ZXJhdGVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSwgaW5kZXgsIGNhbGxiYWNrKSA9PiBpdGVyYXRlZSh2YWx1ZSwgY2FsbGJhY2spO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IiwgIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2VhY2hPZiA9IHJlcXVpcmUoJy4vZWFjaE9mLmpzJyk7XG5cbnZhciBfZWFjaE9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2hPZik7XG5cbnZhciBfd2l0aG91dEluZGV4ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC93aXRob3V0SW5kZXguanMnKTtcblxudmFyIF93aXRob3V0SW5kZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2l0aG91dEluZGV4KTtcblxudmFyIF93cmFwQXN5bmMgPSByZXF1aXJlKCcuL2ludGVybmFsL3dyYXBBc3luYy5qcycpO1xuXG52YXIgX3dyYXBBc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93cmFwQXN5bmMpO1xuXG52YXIgX2F3YWl0aWZ5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9hd2FpdGlmeS5qcycpO1xuXG52YXIgX2F3YWl0aWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F3YWl0aWZ5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBmdW5jdGlvbiBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpbiBgY29sbGAsIGluIHBhcmFsbGVsLlxuICogVGhlIGBpdGVyYXRlZWAgaXMgY2FsbGVkIHdpdGggYW4gaXRlbSBmcm9tIHRoZSBsaXN0LCBhbmQgYSBjYWxsYmFjayBmb3Igd2hlblxuICogaXQgaGFzIGZpbmlzaGVkLiBJZiB0aGUgYGl0ZXJhdGVlYCBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGBjYWxsYmFja2AsIHRoZVxuICogbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlIGBlYWNoYCBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlXG4gKiBlcnJvci5cbiAqXG4gKiBOb3RlLCB0aGF0IHNpbmNlIHRoaXMgZnVuY3Rpb24gYXBwbGllcyBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpbiBwYXJhbGxlbCxcbiAqIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZSBpbiBvcmRlci5cbiAqXG4gKiBAbmFtZSBlYWNoXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAYWxpYXMgZm9yRWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvXG4gKiBlYWNoIGl0ZW0gaW4gYGNvbGxgLiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIFRoZSBhcnJheSBpbmRleCBpcyBub3QgcGFzc2VkIHRvIHRoZSBpdGVyYXRlZS5cbiAqIElmIHlvdSBuZWVkIHRoZSBpbmRleCwgdXNlIGBlYWNoT2ZgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBkaXIxIGlzIGEgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgZmlsZTEudHh0LCBmaWxlMi50eHRcbiAqIC8vIGRpcjIgaXMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBmaWxlMy50eHQsIGZpbGU0LnR4dFxuICogLy8gZGlyMyBpcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGZpbGU1LnR4dFxuICogLy8gZGlyNCBkb2VzIG5vdCBleGlzdFxuICpcbiAqIGNvbnN0IGZpbGVMaXN0ID0gWyAnZGlyMS9maWxlMi50eHQnLCAnZGlyMi9maWxlMy50eHQnLCAnZGlyL2ZpbGU1LnR4dCddO1xuICogY29uc3Qgd2l0aE1pc3NpbmdGaWxlTGlzdCA9IFsnZGlyMS9maWxlMS50eHQnLCAnZGlyNC9maWxlMi50eHQnXTtcbiAqXG4gKiAvLyBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBkZWxldGVzIGEgZmlsZVxuICogY29uc3QgZGVsZXRlRmlsZSA9IGZ1bmN0aW9uKGZpbGUsIGNhbGxiYWNrKSB7XG4gKiAgICAgZnMudW5saW5rKGZpbGUsIGNhbGxiYWNrKTtcbiAqIH07XG4gKlxuICogLy8gVXNpbmcgY2FsbGJhY2tzXG4gKiBhc3luYy5lYWNoKGZpbGVMaXN0LCBkZWxldGVGaWxlLCBmdW5jdGlvbihlcnIpIHtcbiAqICAgICBpZiggZXJyICkge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdBbGwgZmlsZXMgaGF2ZSBiZWVuIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gKiAgICAgfVxuICogfSk7XG4gKlxuICogLy8gRXJyb3IgSGFuZGxpbmdcbiAqIGFzeW5jLmVhY2god2l0aE1pc3NpbmdGaWxlTGlzdCwgZGVsZXRlRmlsZSwgZnVuY3Rpb24oZXJyKXtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiAgICAgLy8gc2luY2UgZGlyNC9maWxlMi50eHQgZG9lcyBub3QgZXhpc3RcbiAqICAgICAvLyBkaXIxL2ZpbGUxLnR4dCBjb3VsZCBoYXZlIGJlZW4gZGVsZXRlZFxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgUHJvbWlzZXNcbiAqIGFzeW5jLmVhY2goZmlsZUxpc3QsIGRlbGV0ZUZpbGUpXG4gKiAudGhlbiggKCkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKCdBbGwgZmlsZXMgaGF2ZSBiZWVuIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gKiB9KS5jYXRjaCggZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogfSk7XG4gKlxuICogLy8gRXJyb3IgSGFuZGxpbmdcbiAqIGFzeW5jLmVhY2goZmlsZUxpc3QsIGRlbGV0ZUZpbGUpXG4gKiAudGhlbiggKCkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKCdBbGwgZmlsZXMgaGF2ZSBiZWVuIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gKiB9KS5jYXRjaCggZXJyID0+IHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIC8vIFsgRXJyb3I6IEVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBdXG4gKiAgICAgLy8gc2luY2UgZGlyNC9maWxlMi50eHQgZG9lcyBub3QgZXhpc3RcbiAqICAgICAvLyBkaXIxL2ZpbGUxLnR4dCBjb3VsZCBoYXZlIGJlZW4gZGVsZXRlZFxuICogfSk7XG4gKlxuICogLy8gVXNpbmcgYXN5bmMvYXdhaXRcbiAqIGFzeW5jICgpID0+IHtcbiAqICAgICB0cnkge1xuICogICAgICAgICBhd2FpdCBhc3luYy5lYWNoKGZpbGVzLCBkZWxldGVGaWxlKTtcbiAqICAgICB9XG4gKiAgICAgY2F0Y2ggKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqIH1cbiAqXG4gKiAvLyBFcnJvciBIYW5kbGluZ1xuICogYXN5bmMgKCkgPT4ge1xuICogICAgIHRyeSB7XG4gKiAgICAgICAgIGF3YWl0IGFzeW5jLmVhY2god2l0aE1pc3NpbmdGaWxlTGlzdCwgZGVsZXRlRmlsZSk7XG4gKiAgICAgfVxuICogICAgIGNhdGNoIChlcnIpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAqICAgICAgICAgLy8gWyBFcnJvcjogRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IF1cbiAqICAgICAgICAgLy8gc2luY2UgZGlyNC9maWxlMi50eHQgZG9lcyBub3QgZXhpc3RcbiAqICAgICAgICAgLy8gZGlyMS9maWxlMS50eHQgY291bGQgaGF2ZSBiZWVuIGRlbGV0ZWRcbiAqICAgICB9XG4gKiB9XG4gKlxuICovXG5mdW5jdGlvbiBlYWNoTGltaXQoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuICgwLCBfZWFjaE9mMi5kZWZhdWx0KShjb2xsLCAoMCwgX3dpdGhvdXRJbmRleDIuZGVmYXVsdCkoKDAsIF93cmFwQXN5bmMyLmRlZmF1bHQpKGl0ZXJhdGVlKSksIGNhbGxiYWNrKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9hd2FpdGlmeTIuZGVmYXVsdCkoZWFjaExpbWl0LCAzKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyIsICIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRXh0cmFjdCBuYW1lcyBmcm9tIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gd2hvJ3MgbmFtZSB3ZSBuZWVkIHRvIGV4dHJhY3QuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24uXG4gKiBAcHVibGljXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbmFtZShmbikge1xuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBmbi5kaXNwbGF5TmFtZSAmJiBmbi5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgcmV0dXJuIGZuLmRpc3BsYXlOYW1lO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgZm4ubmFtZSAmJiBmbi5uYW1lKSB7XG4gICAgcmV0dXJuIGZuLm5hbWU7XG4gIH1cblxuICAvL1xuICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIGNvbnN0cnVjdG9yIGhhcyBhIG5hbWUuXG4gIC8vXG4gIGlmIChcbiAgICAgICAnb2JqZWN0JyA9PT0gdHlwZW9mIGZuXG4gICAgJiYgZm4uY29uc3RydWN0b3JcbiAgICAmJiAnc3RyaW5nJyA9PT0gdHlwZW9mIGZuLmNvbnN0cnVjdG9yLm5hbWVcbiAgKSByZXR1cm4gZm4uY29uc3RydWN0b3IubmFtZTtcblxuICAvL1xuICAvLyB0b1N0cmluZyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYW5kIGF0dGVtcHQgdG8gcGFyc2UgaXQgb3V0IG9mIGl0LCBvciBkZXRlcm1pbmVcbiAgLy8gdGhlIGNsYXNzLlxuICAvL1xuICB2YXIgbmFtZWQgPSBmbi50b1N0cmluZygpXG4gICAgLCB0eXBlID0gdG9TdHJpbmcuY2FsbChmbikuc2xpY2UoOCwgLTEpO1xuXG4gIGlmICgnRnVuY3Rpb24nID09PSB0eXBlKSB7XG4gICAgbmFtZWQgPSBuYW1lZC5zdWJzdHJpbmcobmFtZWQuaW5kZXhPZignKCcpICsgMSwgbmFtZWQuaW5kZXhPZignKScpKTtcbiAgfSBlbHNlIHtcbiAgICBuYW1lZCA9IHR5cGU7XG4gIH1cblxuICByZXR1cm4gbmFtZWQgfHwgJ2Fub255bW91cyc7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIG5hbWUgPSByZXF1aXJlKCdmbi5uYW1lJyk7XG5cbi8qKlxuICogV3JhcCBjYWxsYmFja3MgdG8gcHJldmVudCBkb3VibGUgZXhlY3V0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRoYXQgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uY2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgd3JhcHBlZCBjYWxsYmFjayB3aGljaCBwcmV2ZW50cyBtdWx0aXBsZSBleGVjdXRpb25zLlxuICogQHB1YmxpY1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG9uZShmbikge1xuICB2YXIgY2FsbGVkID0gMFxuICAgICwgdmFsdWU7XG5cbiAgLyoqXG4gICAqIFRoZSBmdW5jdGlvbiB0aGF0IHByZXZlbnRzIGRvdWJsZSBleGVjdXRpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBvbmV0aW1lKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybiB2YWx1ZTtcblxuICAgIGNhbGxlZCA9IDE7XG4gICAgdmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZuID0gbnVsbDtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8vXG4gIC8vIFRvIG1ha2UgZGVidWdnaW5nIG1vcmUgZWFzeSB3ZSB3YW50IHRvIHVzZSB0aGUgbmFtZSBvZiB0aGUgc3VwcGxpZWRcbiAgLy8gZnVuY3Rpb24uIFNvIHdoZW4geW91IGxvb2sgYXQgdGhlIGZ1bmN0aW9ucyB0aGF0IGFyZSBhc3NpZ25lZCB0byBldmVudFxuICAvLyBsaXN0ZW5lcnMgeW91IGRvbid0IHNlZSBhIGxvYWQgb2YgYG9uZXRpbWVgIGZ1bmN0aW9ucyBidXQgYWN0dWFsbHkgdGhlXG4gIC8vIG5hbWVzIG9mIHRoZSBmdW5jdGlvbnMgdGhhdCB0aGlzIG1vZHVsZSB3aWxsIGNhbGwuXG4gIC8vXG4gIC8vIE5PVEU6IFdlIGNhbm5vdCBvdmVycmlkZSB0aGUgYG5hbWVgIHByb3BlcnR5LCBhcyB0aGF0IGlzIGByZWFkT25seWBcbiAgLy8gcHJvcGVydHksIHNvIGRpc3BsYXlOYW1lIHdpbGwgaGF2ZSB0byBkby5cbiAgLy9cbiAgb25ldGltZS5kaXNwbGF5TmFtZSA9IG5hbWUoZm4pO1xuICByZXR1cm4gb25ldGltZTtcbn07XG4iLCAiZXhwb3J0cy5nZXQgPSBmdW5jdGlvbihiZWxvd0ZuKSB7XG4gIHZhciBvbGRMaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gSW5maW5pdHk7XG5cbiAgdmFyIGR1bW15T2JqZWN0ID0ge307XG5cbiAgdmFyIHY4SGFuZGxlciA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IGZ1bmN0aW9uKGR1bW15T2JqZWN0LCB2OFN0YWNrVHJhY2UpIHtcbiAgICByZXR1cm4gdjhTdGFja1RyYWNlO1xuICB9O1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShkdW1teU9iamVjdCwgYmVsb3dGbiB8fCBleHBvcnRzLmdldCk7XG5cbiAgdmFyIHY4U3RhY2tUcmFjZSA9IGR1bW15T2JqZWN0LnN0YWNrO1xuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHY4SGFuZGxlcjtcbiAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gb2xkTGltaXQ7XG5cbiAgcmV0dXJuIHY4U3RhY2tUcmFjZTtcbn07XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKCFlcnIuc3RhY2spIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsaW5lcyA9IGVyci5zdGFjay5zcGxpdCgnXFxuJykuc2xpY2UoMSk7XG5cbiAgcmV0dXJuIGxpbmVzXG4gICAgLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICBpZiAobGluZS5tYXRjaCgvXlxccypbLV17NCx9JC8pKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9jcmVhdGVQYXJzZWRDYWxsU2l0ZSh7XG4gICAgICAgICAgZmlsZU5hbWU6IGxpbmUsXG4gICAgICAgICAgbGluZU51bWJlcjogbnVsbCxcbiAgICAgICAgICBmdW5jdGlvbk5hbWU6IG51bGwsXG4gICAgICAgICAgdHlwZU5hbWU6IG51bGwsXG4gICAgICAgICAgbWV0aG9kTmFtZTogbnVsbCxcbiAgICAgICAgICBjb2x1bW5OdW1iZXI6IG51bGwsXG4gICAgICAgICAgJ25hdGl2ZSc6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGluZU1hdGNoID0gbGluZS5tYXRjaCgvYXQgKD86KC4rKVxccytcXCgpPyg/OiguKz8pOihcXGQrKSg/OjooXFxkKykpP3woW14pXSspKVxcKT8vKTtcbiAgICAgIGlmICghbGluZU1hdGNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9iamVjdCA9IG51bGw7XG4gICAgICB2YXIgbWV0aG9kID0gbnVsbDtcbiAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBudWxsO1xuICAgICAgdmFyIHR5cGVOYW1lID0gbnVsbDtcbiAgICAgIHZhciBtZXRob2ROYW1lID0gbnVsbDtcbiAgICAgIHZhciBpc05hdGl2ZSA9IChsaW5lTWF0Y2hbNV0gPT09ICduYXRpdmUnKTtcblxuICAgICAgaWYgKGxpbmVNYXRjaFsxXSkge1xuICAgICAgICBmdW5jdGlvbk5hbWUgPSBsaW5lTWF0Y2hbMV07XG4gICAgICAgIHZhciBtZXRob2RTdGFydCA9IGZ1bmN0aW9uTmFtZS5sYXN0SW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZnVuY3Rpb25OYW1lW21ldGhvZFN0YXJ0LTFdID09ICcuJylcbiAgICAgICAgICBtZXRob2RTdGFydC0tO1xuICAgICAgICBpZiAobWV0aG9kU3RhcnQgPiAwKSB7XG4gICAgICAgICAgb2JqZWN0ID0gZnVuY3Rpb25OYW1lLnN1YnN0cigwLCBtZXRob2RTdGFydCk7XG4gICAgICAgICAgbWV0aG9kID0gZnVuY3Rpb25OYW1lLnN1YnN0cihtZXRob2RTdGFydCArIDEpO1xuICAgICAgICAgIHZhciBvYmplY3RFbmQgPSBvYmplY3QuaW5kZXhPZignLk1vZHVsZScpO1xuICAgICAgICAgIGlmIChvYmplY3RFbmQgPiAwKSB7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbk5hbWUuc3Vic3RyKG9iamVjdEVuZCArIDEpO1xuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnN1YnN0cigwLCBvYmplY3RFbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0eXBlTmFtZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgdHlwZU5hbWUgPSBvYmplY3Q7XG4gICAgICAgIG1ldGhvZE5hbWUgPSBtZXRob2Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZXRob2QgPT09ICc8YW5vbnltb3VzPicpIHtcbiAgICAgICAgbWV0aG9kTmFtZSA9IG51bGw7XG4gICAgICAgIGZ1bmN0aW9uTmFtZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBmaWxlTmFtZTogbGluZU1hdGNoWzJdIHx8IG51bGwsXG4gICAgICAgIGxpbmVOdW1iZXI6IHBhcnNlSW50KGxpbmVNYXRjaFszXSwgMTApIHx8IG51bGwsXG4gICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICB0eXBlTmFtZTogdHlwZU5hbWUsXG4gICAgICAgIG1ldGhvZE5hbWU6IG1ldGhvZE5hbWUsXG4gICAgICAgIGNvbHVtbk51bWJlcjogcGFyc2VJbnQobGluZU1hdGNoWzRdLCAxMCkgfHwgbnVsbCxcbiAgICAgICAgJ25hdGl2ZSc6IGlzTmF0aXZlLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHNlbGYuX2NyZWF0ZVBhcnNlZENhbGxTaXRlKHByb3BlcnRpZXMpO1xuICAgIH0pXG4gICAgLmZpbHRlcihmdW5jdGlvbihjYWxsU2l0ZSkge1xuICAgICAgcmV0dXJuICEhY2FsbFNpdGU7XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBDYWxsU2l0ZShwcm9wZXJ0aWVzKSB7XG4gIGZvciAodmFyIHByb3BlcnR5IGluIHByb3BlcnRpZXMpIHtcbiAgICB0aGlzW3Byb3BlcnR5XSA9IHByb3BlcnRpZXNbcHJvcGVydHldO1xuICB9XG59XG5cbnZhciBzdHJQcm9wZXJ0aWVzID0gW1xuICAndGhpcycsXG4gICd0eXBlTmFtZScsXG4gICdmdW5jdGlvbk5hbWUnLFxuICAnbWV0aG9kTmFtZScsXG4gICdmaWxlTmFtZScsXG4gICdsaW5lTnVtYmVyJyxcbiAgJ2NvbHVtbk51bWJlcicsXG4gICdmdW5jdGlvbicsXG4gICdldmFsT3JpZ2luJ1xuXTtcbnZhciBib29sUHJvcGVydGllcyA9IFtcbiAgJ3RvcExldmVsJyxcbiAgJ2V2YWwnLFxuICAnbmF0aXZlJyxcbiAgJ2NvbnN0cnVjdG9yJ1xuXTtcbnN0clByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgQ2FsbFNpdGUucHJvdG90eXBlW3Byb3BlcnR5XSA9IG51bGw7XG4gIENhbGxTaXRlLnByb3RvdHlwZVsnZ2V0JyArIHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zdWJzdHIoMSldID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzW3Byb3BlcnR5XTtcbiAgfVxufSk7XG5ib29sUHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICBDYWxsU2l0ZS5wcm90b3R5cGVbcHJvcGVydHldID0gZmFsc2U7XG4gIENhbGxTaXRlLnByb3RvdHlwZVsnaXMnICsgcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnN1YnN0cigxKV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbcHJvcGVydHldO1xuICB9XG59KTtcblxuZXhwb3J0cy5fY3JlYXRlUGFyc2VkQ2FsbFNpdGUgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBuZXcgQ2FsbFNpdGUocHJvcGVydGllcyk7XG59O1xuIiwgIi8qKlxuICogZXhjZXB0aW9uLXN0cmVhbS5qczogVE9ETzogYWRkIGZpbGUgaGVhZGVyIGhhbmRsZXIuXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJyk7XG5cbi8qKlxuICogVE9ETzogYWRkIGNsYXNzIGRlc2NyaXB0aW9uLlxuICogQHR5cGUge0V4Y2VwdGlvblN0cmVhbX1cbiAqIEBleHRlbmRzIHtXcml0YWJsZX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBFeGNlcHRpb25TdHJlYW0gZXh0ZW5kcyBXcml0YWJsZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIEV4Y2VwdGlvblN0cmVhbSByZXNwb25zaWJsZSBmb3Igd3JhcHBpbmcgYVxuICAgKiBUcmFuc3BvcnRTdHJlYW07IG9ubHkgYWxsb3dpbmcgd3JpdGVzIG9mIGBpbmZvYCBvYmplY3RzIHdpdGhcbiAgICogYGluZm8uZXhjZXB0aW9uYCBzZXQgdG8gdHJ1ZS5cbiAgICogQHBhcmFtIHshVHJhbnNwb3J0U3RyZWFtfSB0cmFuc3BvcnQgLSBTdHJlYW0gdG8gZmlsdGVyIHRvIGV4Y2VwdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcblxuICAgIGlmICghdHJhbnNwb3J0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4Y2VwdGlvblN0cmVhbSByZXF1aXJlcyBhIFRyYW5zcG9ydFN0cmVhbSBpbnN0YW5jZS4nKTtcbiAgICB9XG5cbiAgICAvLyBSZW1hcmsgKGluZGV4emVybyk6IHdlIHNldCBgaGFuZGxlRXhjZXB0aW9uc2AgaGVyZSBiZWNhdXNlIGl0J3MgdGhlXG4gICAgLy8gcHJlZGljYXRlIGNoZWNrZWQgaW4gRXhjZXB0aW9uSGFuZGxlci5wcm90b3R5cGUuX19nZXRFeGNlcHRpb25IYW5kbGVyc1xuICAgIHRoaXMuaGFuZGxlRXhjZXB0aW9ucyA9IHRydWU7XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIHRoZSBpbmZvIG9iamVjdCB0byBvdXIgdHJhbnNwb3J0IGluc3RhbmNlIGlmIChhbmQgb25seSBpZikgdGhlXG4gICAqIGBleGNlcHRpb25gIHByb3BlcnR5IGlzIHNldCBvbiB0aGUgaW5mby5cbiAgICogQHBhcmFtIHttaXhlZH0gaW5mbyAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHttaXhlZH0gZW5jIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge21peGVkfSBjYWxsYmFjayAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd3JpdGUoaW5mbywgZW5jLCBjYWxsYmFjaykge1xuICAgIGlmIChpbmZvLmV4Y2VwdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmxvZyhpbmZvLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2soKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsICIvKipcbiAqIGV4Y2VwdGlvbi1oYW5kbGVyLmpzOiBPYmplY3QgZm9yIGhhbmRsaW5nIHVuY2F1Z2h0RXhjZXB0aW9uIGV2ZW50cy5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBhc3luY0ZvckVhY2ggPSByZXF1aXJlKCdhc3luYy9mb3JFYWNoJyk7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ0BkYWJoL2RpYWdub3N0aWNzJykoJ3dpbnN0b246ZXhjZXB0aW9uJyk7XG5jb25zdCBvbmNlID0gcmVxdWlyZSgnb25lLXRpbWUnKTtcbmNvbnN0IHN0YWNrVHJhY2UgPSByZXF1aXJlKCdzdGFjay10cmFjZScpO1xuY29uc3QgRXhjZXB0aW9uU3RyZWFtID0gcmVxdWlyZSgnLi9leGNlcHRpb24tc3RyZWFtJyk7XG5cbi8qKlxuICogT2JqZWN0IGZvciBoYW5kbGluZyB1bmNhdWdodEV4Y2VwdGlvbiBldmVudHMuXG4gKiBAdHlwZSB7RXhjZXB0aW9uSGFuZGxlcn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBFeGNlcHRpb25IYW5kbGVyIHtcbiAgLyoqXG4gICAqIFRPRE86IGFkZCBjb250cnVjdG9yIGRlc2NyaXB0aW9uXG4gICAqIEBwYXJhbSB7IUxvZ2dlcn0gbG9nZ2VyIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dnZXIgaXMgcmVxdWlyZWQgdG8gaGFuZGxlIGV4Y2VwdGlvbnMnKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYHVuY2F1Z2h0RXhjZXB0aW9uYCBldmVudHMgZm9yIHRoZSBjdXJyZW50IHByb2Nlc3MgYnkgYWRkaW5nIGFueVxuICAgKiBoYW5kbGVycyBwYXNzZWQgaW4uXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBoYW5kbGUoLi4uYXJncykge1xuICAgIGFyZ3MuZm9yRWFjaChhcmcgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICByZXR1cm4gYXJnLmZvckVhY2goaGFuZGxlciA9PiB0aGlzLl9hZGRIYW5kbGVyKGhhbmRsZXIpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWRkSGFuZGxlcihhcmcpO1xuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLmNhdGNoZXIpIHtcbiAgICAgIHRoaXMuY2F0Y2hlciA9IHRoaXMuX3VuY2F1Z2h0RXhjZXB0aW9uLmJpbmQodGhpcyk7XG4gICAgICBwcm9jZXNzLm9uKCd1bmNhdWdodEV4Y2VwdGlvbicsIHRoaXMuY2F0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW55IGhhbmRsZXJzIHRvIGB1bmNhdWdodEV4Y2VwdGlvbmAgZXZlbnRzIGZvciB0aGUgY3VycmVudFxuICAgKiBwcm9jZXNzLiBUaGlzIGRvZXMgbm90IG1vZGlmeSB0aGUgc3RhdGUgb2YgdGhlIGB0aGlzLmhhbmRsZXJzYCBzZXQuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICB1bmhhbmRsZSgpIHtcbiAgICBpZiAodGhpcy5jYXRjaGVyKSB7XG4gICAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKCd1bmNhdWdodEV4Y2VwdGlvbicsIHRoaXMuY2F0Y2hlcik7XG4gICAgICB0aGlzLmNhdGNoZXIgPSBmYWxzZTtcblxuICAgICAgQXJyYXkuZnJvbSh0aGlzLmhhbmRsZXJzLnZhbHVlcygpKVxuICAgICAgICAuZm9yRWFjaCh3cmFwcGVyID0+IHRoaXMubG9nZ2VyLnVucGlwZSh3cmFwcGVyKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRPRE86IGFkZCBtZXRob2QgZGVzY3JpcHRpb25cbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgdG8gZ2V0IGluZm9ybWF0aW9uIGFib3V0LlxuICAgKiBAcmV0dXJucyB7bWl4ZWR9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICovXG4gIGdldEFsbEluZm8oZXJyKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBudWxsO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIG1lc3NhZ2UgPSB0eXBlb2YgZXJyID09PSAnc3RyaW5nJyA/IGVyciA6IGVyci5tZXNzYWdlO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogZXJyLFxuICAgICAgLy8gVE9ETyAoaW5kZXh6ZXJvKTogaG93IGRvIHdlIGNvbmZpZ3VyZSB0aGlzP1xuICAgICAgbGV2ZWw6ICdlcnJvcicsXG4gICAgICBtZXNzYWdlOiBbXG4gICAgICAgIGB1bmNhdWdodEV4Y2VwdGlvbjogJHsobWVzc2FnZSB8fCAnKG5vIGVycm9yIG1lc3NhZ2UpJyl9YCxcbiAgICAgICAgZXJyICYmIGVyci5zdGFjayB8fCAnICBObyBzdGFjayB0cmFjZSdcbiAgICAgIF0uam9pbignXFxuJyksXG4gICAgICBzdGFjazogZXJyICYmIGVyci5zdGFjayxcbiAgICAgIGV4Y2VwdGlvbjogdHJ1ZSxcbiAgICAgIGRhdGU6IG5ldyBEYXRlKCkudG9TdHJpbmcoKSxcbiAgICAgIHByb2Nlc3M6IHRoaXMuZ2V0UHJvY2Vzc0luZm8oKSxcbiAgICAgIG9zOiB0aGlzLmdldE9zSW5mbygpLFxuICAgICAgdHJhY2U6IHRoaXMuZ2V0VHJhY2UoZXJyKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgcmVsZXZhbnQgcHJvY2VzcyBpbmZvcm1hdGlvbiBmb3IgdGhlIGN1cnJlbnRseSBydW5uaW5nIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgZ2V0UHJvY2Vzc0luZm8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBpZDogcHJvY2Vzcy5waWQsXG4gICAgICB1aWQ6IHByb2Nlc3MuZ2V0dWlkID8gcHJvY2Vzcy5nZXR1aWQoKSA6IG51bGwsXG4gICAgICBnaWQ6IHByb2Nlc3MuZ2V0Z2lkID8gcHJvY2Vzcy5nZXRnaWQoKSA6IG51bGwsXG4gICAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgICBleGVjUGF0aDogcHJvY2Vzcy5leGVjUGF0aCxcbiAgICAgIHZlcnNpb246IHByb2Nlc3MudmVyc2lvbixcbiAgICAgIGFyZ3Y6IHByb2Nlc3MuYXJndixcbiAgICAgIG1lbW9yeVVzYWdlOiBwcm9jZXNzLm1lbW9yeVVzYWdlKClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIHJlbGV2YW50IE9TIGluZm9ybWF0aW9uIGZvciB0aGUgY3VycmVudGx5IHJ1bm5pbmcgcHJvY2Vzcy5cbiAgICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBnZXRPc0luZm8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRhdmc6IG9zLmxvYWRhdmcoKSxcbiAgICAgIHVwdGltZTogb3MudXB0aW1lKClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBzdGFjayB0cmFjZSBmb3IgdGhlIHNwZWNpZmllZCBlcnJvci5cbiAgICogQHBhcmFtIHttaXhlZH0gZXJyIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7bWl4ZWR9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICovXG4gIGdldFRyYWNlKGVycikge1xuICAgIGNvbnN0IHRyYWNlID0gZXJyID8gc3RhY2tUcmFjZS5wYXJzZShlcnIpIDogc3RhY2tUcmFjZS5nZXQoKTtcbiAgICByZXR1cm4gdHJhY2UubWFwKHNpdGUgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29sdW1uOiBzaXRlLmdldENvbHVtbk51bWJlcigpLFxuICAgICAgICBmaWxlOiBzaXRlLmdldEZpbGVOYW1lKCksXG4gICAgICAgIGZ1bmN0aW9uOiBzaXRlLmdldEZ1bmN0aW9uTmFtZSgpLFxuICAgICAgICBsaW5lOiBzaXRlLmdldExpbmVOdW1iZXIoKSxcbiAgICAgICAgbWV0aG9kOiBzaXRlLmdldE1ldGhvZE5hbWUoKSxcbiAgICAgICAgbmF0aXZlOiBzaXRlLmlzTmF0aXZlKClcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byBhZGQgYSB0cmFuc3BvcnQgYXMgYW4gZXhjZXB0aW9uIGhhbmRsZXIuXG4gICAqIEBwYXJhbSB7VHJhbnNwb3J0fSBoYW5kbGVyIC0gVGhlIHRyYW5zcG9ydCB0byBhZGQgYXMgYW4gZXhjZXB0aW9uIGhhbmRsZXIuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX2FkZEhhbmRsZXIoaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5oYW5kbGVycy5oYXMoaGFuZGxlcikpIHtcbiAgICAgIGhhbmRsZXIuaGFuZGxlRXhjZXB0aW9ucyA9IHRydWU7XG4gICAgICBjb25zdCB3cmFwcGVyID0gbmV3IEV4Y2VwdGlvblN0cmVhbShoYW5kbGVyKTtcbiAgICAgIHRoaXMuaGFuZGxlcnMuc2V0KGhhbmRsZXIsIHdyYXBwZXIpO1xuICAgICAgdGhpcy5sb2dnZXIucGlwZSh3cmFwcGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBhbGwgcmVsZXZhbnQgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBgZXJyYCBhbmQgZXhpdHMgdGhlIGN1cnJlbnRcbiAgICogcHJvY2Vzcy5cbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgdG8gaGFuZGxlXG4gICAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VuY2F1Z2h0RXhjZXB0aW9uKGVycikge1xuICAgIGNvbnN0IGluZm8gPSB0aGlzLmdldEFsbEluZm8oZXJyKTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuX2dldEV4Y2VwdGlvbkhhbmRsZXJzKCk7XG4gICAgLy8gQ2FsY3VsYXRlIGlmIHdlIHNob3VsZCBleGl0IG9uIHRoaXMgZXJyb3JcbiAgICBsZXQgZG9FeGl0ID0gdHlwZW9mIHRoaXMubG9nZ2VyLmV4aXRPbkVycm9yID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHRoaXMubG9nZ2VyLmV4aXRPbkVycm9yKGVycilcbiAgICAgIDogdGhpcy5sb2dnZXIuZXhpdE9uRXJyb3I7XG4gICAgbGV0IHRpbWVvdXQ7XG5cbiAgICBpZiAoIWhhbmRsZXJzLmxlbmd0aCAmJiBkb0V4aXQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oJ3dpbnN0b246IGV4aXRPbkVycm9yIGNhbm5vdCBiZSB0cnVlIHdpdGggbm8gZXhjZXB0aW9uIGhhbmRsZXJzLicpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2Fybignd2luc3Rvbjogbm90IGV4aXRpbmcgcHJvY2Vzcy4nKTtcbiAgICAgIGRvRXhpdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdyYWNlZnVsRXhpdCgpIHtcbiAgICAgIGRlYnVnKCdkb0V4aXQnLCBkb0V4aXQpO1xuICAgICAgZGVidWcoJ3Byb2Nlc3MuX2V4aXRpbmcnLCBwcm9jZXNzLl9leGl0aW5nKTtcblxuICAgICAgaWYgKGRvRXhpdCAmJiAhcHJvY2Vzcy5fZXhpdGluZykge1xuICAgICAgICAvLyBSZW1hcms6IEN1cnJlbnRseSBpZ25vcmluZyBhbnkgZXhjZXB0aW9ucyBmcm9tIHRyYW5zcG9ydHMgd2hlblxuICAgICAgICAvLyBjYXRjaGluZyB1bmNhdWdodCBleGNlcHRpb25zLlxuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1leGl0XG4gICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWhhbmRsZXJzIHx8IGhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZ3JhY2VmdWxFeGl0KTtcbiAgICB9XG5cbiAgICAvLyBMb2cgdG8gYWxsIHRyYW5zcG9ydHMgYXR0ZW1wdGluZyB0byBsaXN0ZW4gZm9yIHdoZW4gdGhleSBhcmUgY29tcGxldGVkLlxuICAgIGFzeW5jRm9yRWFjaChoYW5kbGVycywgKGhhbmRsZXIsIG5leHQpID0+IHtcbiAgICAgIGNvbnN0IGRvbmUgPSBvbmNlKG5leHQpO1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gaGFuZGxlci50cmFuc3BvcnQgfHwgaGFuZGxlcjtcblxuICAgICAgLy8gRGVidWcgd3JhcHBpbmcgc28gdGhhdCB3ZSBjYW4gaW5zcGVjdCB3aGF0J3MgZ29pbmcgb24gdW5kZXIgdGhlIGNvdmVycy5cbiAgICAgIGZ1bmN0aW9uIG9uRG9uZShldmVudCkge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGRlYnVnKGV2ZW50KTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRyYW5zcG9ydC5fZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRyYW5zcG9ydC5vbmNlKCdmaW5pc2gnLCBvbkRvbmUoJ2ZpbmlzaGVkJykpO1xuICAgICAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25Eb25lKCdlcnJvcicpKTtcbiAgICB9LCAoKSA9PiBkb0V4aXQgJiYgZ3JhY2VmdWxFeGl0KCkpO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKGluZm8pO1xuXG4gICAgLy8gSWYgZXhpdE9uRXJyb3IgaXMgdHJ1ZSwgdGhlbiBvbmx5IGFsbG93IHRoZSBsb2dnaW5nIG9mIGV4Y2VwdGlvbnMgdG9cbiAgICAvLyB0YWtlIHVwIHRvIGAzMDAwbXNgLlxuICAgIGlmIChkb0V4aXQpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGdyYWNlZnVsRXhpdCwgMzAwMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgdHJhbnNwb3J0cyBhbmQgZXhjZXB0aW9uSGFuZGxlcnMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gLSBMaXN0IG9mIHRyYW5zcG9ydHMgYW5kIGV4Y2VwdGlvbkhhbmRsZXJzIGZvciB0aGlzXG4gICAqIGluc3RhbmNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEV4Y2VwdGlvbkhhbmRsZXJzKCkge1xuICAgIC8vIFJlbWFyayAoaW5kZXh6ZXJvKTogc2luY2UgYGxvZ2dlci50cmFuc3BvcnRzYCByZXR1cm5zIGFsbCBvZiB0aGUgcGlwZXNcbiAgICAvLyBmcm9tIHRoZSBfcmVhZGFibGVTdGF0ZSBvZiB0aGUgc3RyZWFtIHdlIGFjdHVhbGx5IGdldCB0aGUgam9pbiBvZiB0aGVcbiAgICAvLyBleHBsaWNpdCBoYW5kbGVycyBhbmQgdGhlIGltcGxpY2l0IHRyYW5zcG9ydHMgd2l0aFxuICAgIC8vIGBoYW5kbGVFeGNlcHRpb25zOiB0cnVlYFxuICAgIHJldHVybiB0aGlzLmxvZ2dlci50cmFuc3BvcnRzLmZpbHRlcih3cmFwID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHdyYXAudHJhbnNwb3J0IHx8IHdyYXA7XG4gICAgICByZXR1cm4gdHJhbnNwb3J0LmhhbmRsZUV4Y2VwdGlvbnM7XG4gICAgfSk7XG4gIH1cbn07XG4iLCAiLyoqXG4gKiBleGNlcHRpb24taGFuZGxlci5qczogT2JqZWN0IGZvciBoYW5kbGluZyB1bmNhdWdodEV4Y2VwdGlvbiBldmVudHMuXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgYXN5bmNGb3JFYWNoID0gcmVxdWlyZSgnYXN5bmMvZm9yRWFjaCcpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdAZGFiaC9kaWFnbm9zdGljcycpKCd3aW5zdG9uOnJlamVjdGlvbicpO1xuY29uc3Qgb25jZSA9IHJlcXVpcmUoJ29uZS10aW1lJyk7XG5jb25zdCBzdGFja1RyYWNlID0gcmVxdWlyZSgnc3RhY2stdHJhY2UnKTtcbmNvbnN0IEV4Y2VwdGlvblN0cmVhbSA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uLXN0cmVhbScpO1xuXG4vKipcbiAqIE9iamVjdCBmb3IgaGFuZGxpbmcgdW5oYW5kbGVkUmVqZWN0aW9uIGV2ZW50cy5cbiAqIEB0eXBlIHtSZWplY3Rpb25IYW5kbGVyfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFJlamVjdGlvbkhhbmRsZXIge1xuICAvKipcbiAgICogVE9ETzogYWRkIGNvbnRydWN0b3IgZGVzY3JpcHRpb25cbiAgICogQHBhcmFtIHshTG9nZ2VyfSBsb2dnZXIgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvZ2dlciBpcyByZXF1aXJlZCB0byBoYW5kbGUgcmVqZWN0aW9ucycpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMuaGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBgdW5oYW5kbGVkUmVqZWN0aW9uYCBldmVudHMgZm9yIHRoZSBjdXJyZW50IHByb2Nlc3MgYnkgYWRkaW5nIGFueVxuICAgKiBoYW5kbGVycyBwYXNzZWQgaW4uXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBoYW5kbGUoLi4uYXJncykge1xuICAgIGFyZ3MuZm9yRWFjaChhcmcgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICByZXR1cm4gYXJnLmZvckVhY2goaGFuZGxlciA9PiB0aGlzLl9hZGRIYW5kbGVyKGhhbmRsZXIpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWRkSGFuZGxlcihhcmcpO1xuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLmNhdGNoZXIpIHtcbiAgICAgIHRoaXMuY2F0Y2hlciA9IHRoaXMuX3VuaGFuZGxlZFJlamVjdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgcHJvY2Vzcy5vbigndW5oYW5kbGVkUmVqZWN0aW9uJywgdGhpcy5jYXRjaGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbnkgaGFuZGxlcnMgdG8gYHVuaGFuZGxlZFJlamVjdGlvbmAgZXZlbnRzIGZvciB0aGUgY3VycmVudFxuICAgKiBwcm9jZXNzLiBUaGlzIGRvZXMgbm90IG1vZGlmeSB0aGUgc3RhdGUgb2YgdGhlIGB0aGlzLmhhbmRsZXJzYCBzZXQuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICB1bmhhbmRsZSgpIHtcbiAgICBpZiAodGhpcy5jYXRjaGVyKSB7XG4gICAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKCd1bmhhbmRsZWRSZWplY3Rpb24nLCB0aGlzLmNhdGNoZXIpO1xuICAgICAgdGhpcy5jYXRjaGVyID0gZmFsc2U7XG5cbiAgICAgIEFycmF5LmZyb20odGhpcy5oYW5kbGVycy52YWx1ZXMoKSkuZm9yRWFjaCh3cmFwcGVyID0+XG4gICAgICAgIHRoaXMubG9nZ2VyLnVucGlwZSh3cmFwcGVyKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVE9ETzogYWRkIG1ldGhvZCBkZXNjcmlwdGlvblxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciB0byBnZXQgaW5mb3JtYXRpb24gYWJvdXQuXG4gICAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgZ2V0QWxsSW5mbyhlcnIpIHtcbiAgICBsZXQgbWVzc2FnZSA9IG51bGw7XG4gICAgaWYgKGVycikge1xuICAgICAgbWVzc2FnZSA9IHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnID8gZXJyIDogZXJyLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBlcnIsXG4gICAgICAvLyBUT0RPIChpbmRleHplcm8pOiBob3cgZG8gd2UgY29uZmlndXJlIHRoaXM/XG4gICAgICBsZXZlbDogJ2Vycm9yJyxcbiAgICAgIG1lc3NhZ2U6IFtcbiAgICAgICAgYHVuaGFuZGxlZFJlamVjdGlvbjogJHttZXNzYWdlIHx8ICcobm8gZXJyb3IgbWVzc2FnZSknfWAsXG4gICAgICAgIGVyciAmJiBlcnIuc3RhY2sgfHwgJyAgTm8gc3RhY2sgdHJhY2UnXG4gICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgc3RhY2s6IGVyciAmJiBlcnIuc3RhY2ssXG4gICAgICBleGNlcHRpb246IHRydWUsXG4gICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvU3RyaW5nKCksXG4gICAgICBwcm9jZXNzOiB0aGlzLmdldFByb2Nlc3NJbmZvKCksXG4gICAgICBvczogdGhpcy5nZXRPc0luZm8oKSxcbiAgICAgIHRyYWNlOiB0aGlzLmdldFRyYWNlKGVycilcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIHJlbGV2YW50IHByb2Nlc3MgaW5mb3JtYXRpb24gZm9yIHRoZSBjdXJyZW50bHkgcnVubmluZyBwcm9jZXNzLlxuICAgKiBAcmV0dXJucyB7bWl4ZWR9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICovXG4gIGdldFByb2Nlc3NJbmZvKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwaWQ6IHByb2Nlc3MucGlkLFxuICAgICAgdWlkOiBwcm9jZXNzLmdldHVpZCA/IHByb2Nlc3MuZ2V0dWlkKCkgOiBudWxsLFxuICAgICAgZ2lkOiBwcm9jZXNzLmdldGdpZCA/IHByb2Nlc3MuZ2V0Z2lkKCkgOiBudWxsLFxuICAgICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgICAgZXhlY1BhdGg6IHByb2Nlc3MuZXhlY1BhdGgsXG4gICAgICB2ZXJzaW9uOiBwcm9jZXNzLnZlcnNpb24sXG4gICAgICBhcmd2OiBwcm9jZXNzLmFyZ3YsXG4gICAgICBtZW1vcnlVc2FnZTogcHJvY2Vzcy5tZW1vcnlVc2FnZSgpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFsbCByZWxldmFudCBPUyBpbmZvcm1hdGlvbiBmb3IgdGhlIGN1cnJlbnRseSBydW5uaW5nIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgZ2V0T3NJbmZvKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2FkYXZnOiBvcy5sb2FkYXZnKCksXG4gICAgICB1cHRpbWU6IG9zLnVwdGltZSgpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgc3RhY2sgdHJhY2UgZm9yIHRoZSBzcGVjaWZpZWQgZXJyb3IuXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGVyciAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBnZXRUcmFjZShlcnIpIHtcbiAgICBjb25zdCB0cmFjZSA9IGVyciA/IHN0YWNrVHJhY2UucGFyc2UoZXJyKSA6IHN0YWNrVHJhY2UuZ2V0KCk7XG4gICAgcmV0dXJuIHRyYWNlLm1hcChzaXRlID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbHVtbjogc2l0ZS5nZXRDb2x1bW5OdW1iZXIoKSxcbiAgICAgICAgZmlsZTogc2l0ZS5nZXRGaWxlTmFtZSgpLFxuICAgICAgICBmdW5jdGlvbjogc2l0ZS5nZXRGdW5jdGlvbk5hbWUoKSxcbiAgICAgICAgbGluZTogc2l0ZS5nZXRMaW5lTnVtYmVyKCksXG4gICAgICAgIG1ldGhvZDogc2l0ZS5nZXRNZXRob2ROYW1lKCksXG4gICAgICAgIG5hdGl2ZTogc2l0ZS5pc05hdGl2ZSgpXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gYWRkIGEgdHJhbnNwb3J0IGFzIGFuIGV4Y2VwdGlvbiBoYW5kbGVyLlxuICAgKiBAcGFyYW0ge1RyYW5zcG9ydH0gaGFuZGxlciAtIFRoZSB0cmFuc3BvcnQgdG8gYWRkIGFzIGFuIGV4Y2VwdGlvbiBoYW5kbGVyLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9hZGRIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuaGFuZGxlcnMuaGFzKGhhbmRsZXIpKSB7XG4gICAgICBoYW5kbGVyLmhhbmRsZVJlamVjdGlvbnMgPSB0cnVlO1xuICAgICAgY29uc3Qgd3JhcHBlciA9IG5ldyBFeGNlcHRpb25TdHJlYW0oaGFuZGxlcik7XG4gICAgICB0aGlzLmhhbmRsZXJzLnNldChoYW5kbGVyLCB3cmFwcGVyKTtcbiAgICAgIHRoaXMubG9nZ2VyLnBpcGUod3JhcHBlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgYWxsIHJlbGV2YW50IGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgYGVycmAgYW5kIGV4aXRzIHRoZSBjdXJyZW50XG4gICAqIHByb2Nlc3MuXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIHRvIGhhbmRsZVxuICAgKiBAcmV0dXJucyB7bWl4ZWR9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91bmhhbmRsZWRSZWplY3Rpb24oZXJyKSB7XG4gICAgY29uc3QgaW5mbyA9IHRoaXMuZ2V0QWxsSW5mbyhlcnIpO1xuICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5fZ2V0UmVqZWN0aW9uSGFuZGxlcnMoKTtcbiAgICAvLyBDYWxjdWxhdGUgaWYgd2Ugc2hvdWxkIGV4aXQgb24gdGhpcyBlcnJvclxuICAgIGxldCBkb0V4aXQgPVxuICAgICAgdHlwZW9mIHRoaXMubG9nZ2VyLmV4aXRPbkVycm9yID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdGhpcy5sb2dnZXIuZXhpdE9uRXJyb3IoZXJyKVxuICAgICAgICA6IHRoaXMubG9nZ2VyLmV4aXRPbkVycm9yO1xuICAgIGxldCB0aW1lb3V0O1xuXG4gICAgaWYgKCFoYW5kbGVycy5sZW5ndGggJiYgZG9FeGl0KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKCd3aW5zdG9uOiBleGl0T25FcnJvciBjYW5ub3QgYmUgdHJ1ZSB3aXRoIG5vIHJlamVjdGlvbiBoYW5kbGVycy4nKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oJ3dpbnN0b246IG5vdCBleGl0aW5nIHByb2Nlc3MuJyk7XG4gICAgICBkb0V4aXQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBncmFjZWZ1bEV4aXQoKSB7XG4gICAgICBkZWJ1ZygnZG9FeGl0JywgZG9FeGl0KTtcbiAgICAgIGRlYnVnKCdwcm9jZXNzLl9leGl0aW5nJywgcHJvY2Vzcy5fZXhpdGluZyk7XG5cbiAgICAgIGlmIChkb0V4aXQgJiYgIXByb2Nlc3MuX2V4aXRpbmcpIHtcbiAgICAgICAgLy8gUmVtYXJrOiBDdXJyZW50bHkgaWdub3JpbmcgYW55IHJlamVjdGlvbnMgZnJvbSB0cmFuc3BvcnRzIHdoZW5cbiAgICAgICAgLy8gY2F0Y2hpbmcgdW5oYW5kbGVkIHJlamVjdGlvbnMuXG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWV4aXRcbiAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaGFuZGxlcnMgfHwgaGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhncmFjZWZ1bEV4aXQpO1xuICAgIH1cblxuICAgIC8vIExvZyB0byBhbGwgdHJhbnNwb3J0cyBhdHRlbXB0aW5nIHRvIGxpc3RlbiBmb3Igd2hlbiB0aGV5IGFyZSBjb21wbGV0ZWQuXG4gICAgYXN5bmNGb3JFYWNoKFxuICAgICAgaGFuZGxlcnMsXG4gICAgICAoaGFuZGxlciwgbmV4dCkgPT4ge1xuICAgICAgICBjb25zdCBkb25lID0gb25jZShuZXh0KTtcbiAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gaGFuZGxlci50cmFuc3BvcnQgfHwgaGFuZGxlcjtcblxuICAgICAgICAvLyBEZWJ1ZyB3cmFwcGluZyBzbyB0aGF0IHdlIGNhbiBpbnNwZWN0IHdoYXQncyBnb2luZyBvbiB1bmRlciB0aGUgY292ZXJzLlxuICAgICAgICBmdW5jdGlvbiBvbkRvbmUoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoZXZlbnQpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc3BvcnQuX2VuZGluZyA9IHRydWU7XG4gICAgICAgIHRyYW5zcG9ydC5vbmNlKCdmaW5pc2gnLCBvbkRvbmUoJ2ZpbmlzaGVkJykpO1xuICAgICAgICB0cmFuc3BvcnQub25jZSgnZXJyb3InLCBvbkRvbmUoJ2Vycm9yJykpO1xuICAgICAgfSxcbiAgICAgICgpID0+IGRvRXhpdCAmJiBncmFjZWZ1bEV4aXQoKVxuICAgICk7XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coaW5mbyk7XG5cbiAgICAvLyBJZiBleGl0T25FcnJvciBpcyB0cnVlLCB0aGVuIG9ubHkgYWxsb3cgdGhlIGxvZ2dpbmcgb2YgZXhjZXB0aW9ucyB0b1xuICAgIC8vIHRha2UgdXAgdG8gYDMwMDBtc2AuXG4gICAgaWYgKGRvRXhpdCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZ3JhY2VmdWxFeGl0LCAzMDAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlzdCBvZiB0cmFuc3BvcnRzIGFuZCBleGNlcHRpb25IYW5kbGVycyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge0FycmF5fSAtIExpc3Qgb2YgdHJhbnNwb3J0cyBhbmQgZXhjZXB0aW9uSGFuZGxlcnMgZm9yIHRoaXNcbiAgICogaW5zdGFuY2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0UmVqZWN0aW9uSGFuZGxlcnMoKSB7XG4gICAgLy8gUmVtYXJrIChpbmRleHplcm8pOiBzaW5jZSBgbG9nZ2VyLnRyYW5zcG9ydHNgIHJldHVybnMgYWxsIG9mIHRoZSBwaXBlc1xuICAgIC8vIGZyb20gdGhlIF9yZWFkYWJsZVN0YXRlIG9mIHRoZSBzdHJlYW0gd2UgYWN0dWFsbHkgZ2V0IHRoZSBqb2luIG9mIHRoZVxuICAgIC8vIGV4cGxpY2l0IGhhbmRsZXJzIGFuZCB0aGUgaW1wbGljaXQgdHJhbnNwb3J0cyB3aXRoXG4gICAgLy8gYGhhbmRsZVJlamVjdGlvbnM6IHRydWVgXG4gICAgcmV0dXJuIHRoaXMubG9nZ2VyLnRyYW5zcG9ydHMuZmlsdGVyKHdyYXAgPT4ge1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gd3JhcC50cmFuc3BvcnQgfHwgd3JhcDtcbiAgICAgIHJldHVybiB0cmFuc3BvcnQuaGFuZGxlUmVqZWN0aW9ucztcbiAgICB9KTtcbiAgfVxufTtcbiIsICIvKipcbiAqIHByb2ZpbGVyLmpzOiBUT0RPOiBhZGQgZmlsZSBoZWFkZXIgZGVzY3JpcHRpb24uXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0Jztcbi8qKlxuICogVE9ETzogYWRkIGNsYXNzIGRlc2NyaXB0aW9uLlxuICogQHR5cGUge1Byb2ZpbGVyfVxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUHJvZmlsZXIge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBQcm9maWxlciBpbnN0YW5jZSB1c2VkIGJ5XG4gICAqIGBMb2dnZXIucHJvdG90eXBlLnN0YXJ0VGltZXJgLiBXaGVuIGRvbmUgaXMgY2FsbGVkIHRoZSB0aW1lciB3aWxsIGZpbmlzaFxuICAgKiBhbmQgbG9nIHRoZSBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHshTG9nZ2VyfSBsb2dnZXIgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICBjb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuICAgIGlmICh0eXBlb2YgbG9nZ2VyICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KGxvZ2dlcikgfHwgIShsb2dnZXIgaW5zdGFuY2VvZiBMb2dnZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvZ2dlciBpcyByZXF1aXJlZCBmb3IgcHJvZmlsaW5nJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgdGhpcy5zdGFydCA9IERhdGUubm93KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVuZHMgdGhlIGN1cnJlbnQgdGltZXIgKGkuZS4gUHJvZmlsZXIpIGluc3RhbmNlIGFuZCBsb2dzIHRoZSBgbXNnYCBhbG9uZ1xuICAgKiB3aXRoIHRoZSBkdXJhdGlvbiBzaW5jZSBjcmVhdGlvbi5cbiAgICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkb25lKC4uLmFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybignQ2FsbGJhY2sgZnVuY3Rpb24gbm8gbG9uZ2VyIHN1cHBvcnRlZCBhcyBvZiB3aW5zdG9uQDMuMC4wJyk7XG4gICAgICBhcmdzLnBvcCgpO1xuICAgIH1cblxuICAgIGNvbnN0IGluZm8gPSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnb2JqZWN0JyA/IGFyZ3MucG9wKCkgOiB7fTtcbiAgICBpbmZvLmxldmVsID0gaW5mby5sZXZlbCB8fCAnaW5mbyc7XG4gICAgaW5mby5kdXJhdGlvbk1zID0gKERhdGUubm93KCkpIC0gdGhpcy5zdGFydDtcblxuICAgIHJldHVybiB0aGlzLmxvZ2dlci53cml0ZShpbmZvKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9maWxlcjtcbiIsICIvKipcbiAqIGxvZ2dlci5qczogVE9ETzogYWRkIGZpbGUgaGVhZGVyIGRlc2NyaXB0aW9uLlxuICpcbiAqIChDKSAyMDEwIENoYXJsaWUgUm9iYmluc1xuICogTUlUIExJQ0VOQ0VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgU3RyZWFtLCBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpO1xuY29uc3QgYXN5bmNGb3JFYWNoID0gcmVxdWlyZSgnYXN5bmMvZm9yRWFjaCcpO1xuY29uc3QgeyBMRVZFTCwgU1BMQVQgfSA9IHJlcXVpcmUoJ3RyaXBsZS1iZWFtJyk7XG5jb25zdCBpc1N0cmVhbSA9IHJlcXVpcmUoJ2lzLXN0cmVhbScpO1xuY29uc3QgRXhjZXB0aW9uSGFuZGxlciA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uLWhhbmRsZXInKTtcbmNvbnN0IFJlamVjdGlvbkhhbmRsZXIgPSByZXF1aXJlKCcuL3JlamVjdGlvbi1oYW5kbGVyJyk7XG5jb25zdCBMZWdhY3lUcmFuc3BvcnRTdHJlYW0gPSByZXF1aXJlKCd3aW5zdG9uLXRyYW5zcG9ydC9sZWdhY3knKTtcbmNvbnN0IFByb2ZpbGVyID0gcmVxdWlyZSgnLi9wcm9maWxlcicpO1xuY29uc3QgeyB3YXJuIH0gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxuLyoqXG4gKiBDYXB0dXJlcyB0aGUgbnVtYmVyIG9mIGZvcm1hdCAoaS5lLiAlcyBzdHJpbmdzKSBpbiBhIGdpdmVuIHN0cmluZy5cbiAqIEJhc2VkIG9uIGB1dGlsLmZvcm1hdGAsIHNlZSBOb2RlLmpzIHNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2IxYzhmMTVjNWYxNjllMDIxZjdjNDZlYjdiMjE5ZGU5NWZlOTc2MDMvbGliL3V0aWwuanMjTDIwMS1MMjMwXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5jb25zdCBmb3JtYXRSZWdFeHAgPSAvJVtzY2RqaWZvTyVdL2c7XG5cbi8qKlxuICogVE9ETzogYWRkIGNsYXNzIGRlc2NyaXB0aW9uLlxuICogQHR5cGUge0xvZ2dlcn1cbiAqIEBleHRlbmRzIHtUcmFuc2Zvcm19XG4gKi9cbmNsYXNzIExvZ2dlciBleHRlbmRzIFRyYW5zZm9ybSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIExvZ2dlciBvYmplY3QgcmVzcG9uc2libGUgZm9yIHBlcnNpc3RpbmcgbG9nXG4gICAqIG1lc3NhZ2VzIGFuZCBtZXRhZGF0YSB0byBvbmUgb3IgbW9yZSB0cmFuc3BvcnRzLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IG9wdGlvbnMgLSBmb29cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgdGhpcy5jb25maWd1cmUob3B0aW9ucyk7XG4gIH1cblxuICBjaGlsZChkZWZhdWx0UmVxdWVzdE1ldGFkYXRhKSB7XG4gICAgY29uc3QgbG9nZ2VyID0gdGhpcztcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShsb2dnZXIsIHtcbiAgICAgIHdyaXRlOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAgIGNvbnN0IGluZm9DbG9uZSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIGRlZmF1bHRSZXF1ZXN0TWV0YWRhdGEsXG4gICAgICAgICAgICBpbmZvXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIE9iamVjdC5hc3NpZ24gZG9lc24ndCBjb3B5IGluaGVyaXRlZCBFcnJvclxuICAgICAgICAgIC8vIHByb3BlcnRpZXMgc28gd2UgaGF2ZSB0byBkbyB0aGF0IGV4cGxpY2l0bHlcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFJlbWFyayAoaW5kZXh6ZXJvKTogd2Ugc2hvdWxkIHJlbW92ZSB0aGlzXG4gICAgICAgICAgLy8gc2luY2UgdGhlIGVycm9ycyBmb3JtYXQgd2lsbCBoYW5kbGUgdGhpcyBjYXNlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgaWYgKGluZm8gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgaW5mb0Nsb25lLnN0YWNrID0gaW5mby5zdGFjaztcbiAgICAgICAgICAgIGluZm9DbG9uZS5tZXNzYWdlID0gaW5mby5tZXNzYWdlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxvZ2dlci53cml0ZShpbmZvQ2xvbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyB3aWxsIHdob2xlc2FsZSByZWNvbmZpZ3VyZSB0aGlzIGluc3RhbmNlIGJ5OlxuICAgKiAxLiBSZXNldHRpbmcgYWxsIHRyYW5zcG9ydHMuIE9sZGVyIHRyYW5zcG9ydHMgd2lsbCBiZSByZW1vdmVkIGltcGxpY2l0bHkuXG4gICAqIDIuIFNldCBhbGwgb3RoZXIgb3B0aW9ucyBpbmNsdWRpbmcgbGV2ZWxzLCBjb2xvcnMsIHJld3JpdGVycywgZmlsdGVycyxcbiAgICogICAgZXhjZXB0aW9uSGFuZGxlcnMsIGV0Yy5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBvcHRpb25zIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgY29uZmlndXJlKHtcbiAgICBzaWxlbnQsXG4gICAgZm9ybWF0LFxuICAgIGRlZmF1bHRNZXRhLFxuICAgIGxldmVscyxcbiAgICBsZXZlbCA9ICdpbmZvJyxcbiAgICBleGl0T25FcnJvciA9IHRydWUsXG4gICAgdHJhbnNwb3J0cyxcbiAgICBjb2xvcnMsXG4gICAgZW1pdEVycnMsXG4gICAgZm9ybWF0dGVycyxcbiAgICBwYWRMZXZlbHMsXG4gICAgcmV3cml0ZXJzLFxuICAgIHN0cmlwQ29sb3JzLFxuICAgIGV4Y2VwdGlvbkhhbmRsZXJzLFxuICAgIHJlamVjdGlvbkhhbmRsZXJzXG4gIH0gPSB7fSkge1xuICAgIC8vIFJlc2V0IHRyYW5zcG9ydHMgaWYgd2UgYWxyZWFkeSBoYXZlIHRoZW1cbiAgICBpZiAodGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH1cblxuICAgIHRoaXMuc2lsZW50ID0gc2lsZW50O1xuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0IHx8IHRoaXMuZm9ybWF0IHx8IHJlcXVpcmUoJ2xvZ2Zvcm0vanNvbicpKCk7XG5cbiAgICB0aGlzLmRlZmF1bHRNZXRhID0gZGVmYXVsdE1ldGEgfHwgbnVsbDtcbiAgICAvLyBIb2lzdCBvdGhlciBvcHRpb25zIG9udG8gdGhpcyBpbnN0YW5jZS5cbiAgICB0aGlzLmxldmVscyA9IGxldmVscyB8fCB0aGlzLmxldmVscyB8fCBjb25maWcubnBtLmxldmVscztcbiAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgaWYgKHRoaXMuZXhjZXB0aW9ucykge1xuICAgICAgdGhpcy5leGNlcHRpb25zLnVuaGFuZGxlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlamVjdGlvbnMpIHtcbiAgICAgIHRoaXMucmVqZWN0aW9ucy51bmhhbmRsZSgpO1xuICAgIH1cbiAgICB0aGlzLmV4Y2VwdGlvbnMgPSBuZXcgRXhjZXB0aW9uSGFuZGxlcih0aGlzKTtcbiAgICB0aGlzLnJlamVjdGlvbnMgPSBuZXcgUmVqZWN0aW9uSGFuZGxlcih0aGlzKTtcbiAgICB0aGlzLnByb2ZpbGVycyA9IHt9O1xuICAgIHRoaXMuZXhpdE9uRXJyb3IgPSBleGl0T25FcnJvcjtcblxuICAgIC8vIEFkZCBhbGwgdHJhbnNwb3J0cyB3ZSBoYXZlIGJlZW4gcHJvdmlkZWQuXG4gICAgaWYgKHRyYW5zcG9ydHMpIHtcbiAgICAgIHRyYW5zcG9ydHMgPSBBcnJheS5pc0FycmF5KHRyYW5zcG9ydHMpID8gdHJhbnNwb3J0cyA6IFt0cmFuc3BvcnRzXTtcbiAgICAgIHRyYW5zcG9ydHMuZm9yRWFjaCh0cmFuc3BvcnQgPT4gdGhpcy5hZGQodHJhbnNwb3J0KSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgY29sb3JzIHx8XG4gICAgICBlbWl0RXJycyB8fFxuICAgICAgZm9ybWF0dGVycyB8fFxuICAgICAgcGFkTGV2ZWxzIHx8XG4gICAgICByZXdyaXRlcnMgfHxcbiAgICAgIHN0cmlwQ29sb3JzXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFtcbiAgICAgICAgICAneyBjb2xvcnMsIGVtaXRFcnJzLCBmb3JtYXR0ZXJzLCBwYWRMZXZlbHMsIHJld3JpdGVycywgc3RyaXBDb2xvcnMgfSB3ZXJlIHJlbW92ZWQgaW4gd2luc3RvbkAzLjAuMC4nLFxuICAgICAgICAgICdVc2UgYSBjdXN0b20gd2luc3Rvbi5mb3JtYXQoZnVuY3Rpb24pIGluc3RlYWQuJyxcbiAgICAgICAgICAnU2VlOiBodHRwczovL2dpdGh1Yi5jb20vd2luc3RvbmpzL3dpbnN0b24vdHJlZS9tYXN0ZXIvVVBHUkFERS0zLjAubWQnXG4gICAgICAgIF0uam9pbignXFxuJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGV4Y2VwdGlvbkhhbmRsZXJzKSB7XG4gICAgICB0aGlzLmV4Y2VwdGlvbnMuaGFuZGxlKGV4Y2VwdGlvbkhhbmRsZXJzKTtcbiAgICB9XG4gICAgaWYgKHJlamVjdGlvbkhhbmRsZXJzKSB7XG4gICAgICB0aGlzLnJlamVjdGlvbnMuaGFuZGxlKHJlamVjdGlvbkhhbmRsZXJzKTtcbiAgICB9XG4gIH1cblxuICBpc0xldmVsRW5hYmxlZChsZXZlbCkge1xuICAgIGNvbnN0IGdpdmVuTGV2ZWxWYWx1ZSA9IGdldExldmVsVmFsdWUodGhpcy5sZXZlbHMsIGxldmVsKTtcbiAgICBpZiAoZ2l2ZW5MZXZlbFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgY29uZmlndXJlZExldmVsVmFsdWUgPSBnZXRMZXZlbFZhbHVlKHRoaXMubGV2ZWxzLCB0aGlzLmxldmVsKTtcbiAgICBpZiAoY29uZmlndXJlZExldmVsVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudHJhbnNwb3J0cyB8fCB0aGlzLnRyYW5zcG9ydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJlZExldmVsVmFsdWUgPj0gZ2l2ZW5MZXZlbFZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy50cmFuc3BvcnRzLmZpbmRJbmRleCh0cmFuc3BvcnQgPT4ge1xuICAgICAgbGV0IHRyYW5zcG9ydExldmVsVmFsdWUgPSBnZXRMZXZlbFZhbHVlKHRoaXMubGV2ZWxzLCB0cmFuc3BvcnQubGV2ZWwpO1xuICAgICAgaWYgKHRyYW5zcG9ydExldmVsVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdHJhbnNwb3J0TGV2ZWxWYWx1ZSA9IGNvbmZpZ3VyZWRMZXZlbFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zcG9ydExldmVsVmFsdWUgPj0gZ2l2ZW5MZXZlbFZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBpbmRleCAhPT0gLTE7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuICAvKipcbiAgICogRW5zdXJlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggYSBgbG9nYCBtZXRob2RcbiAgICogQHBhcmFtIHttaXhlZH0gbGV2ZWwgLSBMZXZlbCB0aGUgbG9nIG1lc3NhZ2UgaXMgd3JpdHRlbiBhdC5cbiAgICogQHBhcmFtIHttaXhlZH0gbXNnIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge21peGVkfSBtZXRhIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7TG9nZ2VyfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgIC8vIFN1cHBvcnRzIHRoZSBleGlzdGluZyBBUEk6XG4gICAqICAgIGxvZ2dlci5sb2coJ2luZm8nLCAnSGVsbG8gd29ybGQnLCB7IGN1c3RvbTogdHJ1ZSB9KTtcbiAgICogICAgbG9nZ2VyLmxvZygnaW5mbycsIG5ldyBFcnJvcignWW8sIGl0XFwncyBvbiBmaXJlJykpO1xuICAgKlxuICAgKiAgICAvLyBSZXF1aXJlcyB3aW5zdG9uLmZvcm1hdC5zcGxhdCgpXG4gICAqICAgIGxvZ2dlci5sb2coJ2luZm8nLCAnJXMgJWQlJScsICdBIHN0cmluZycsIDUwLCB7IHRoaXNJc01ldGE6IHRydWUgfSk7XG4gICAqXG4gICAqICAgIC8vIEFuZCB0aGUgbmV3IEFQSSB3aXRoIGEgc2luZ2xlIEpTT04gbGl0ZXJhbDpcbiAgICogICAgbG9nZ2VyLmxvZyh7IGxldmVsOiAnaW5mbycsIG1lc3NhZ2U6ICdIZWxsbyB3b3JsZCcsIGN1c3RvbTogdHJ1ZSB9KTtcbiAgICogICAgbG9nZ2VyLmxvZyh7IGxldmVsOiAnaW5mbycsIG1lc3NhZ2U6IG5ldyBFcnJvcignWW8sIGl0XFwncyBvbiBmaXJlJykgfSk7XG4gICAqXG4gICAqICAgIC8vIEFsc28gcmVxdWlyZXMgd2luc3Rvbi5mb3JtYXQuc3BsYXQoKVxuICAgKiAgICBsb2dnZXIubG9nKHtcbiAgICogICAgICBsZXZlbDogJ2luZm8nLFxuICAgKiAgICAgIG1lc3NhZ2U6ICclcyAlZCUlJyxcbiAgICogICAgICBbU1BMQVRdOiBbJ0Egc3RyaW5nJywgNTBdLFxuICAgKiAgICAgIG1ldGE6IHsgdGhpc0lzTWV0YTogdHJ1ZSB9XG4gICAqICAgIH0pO1xuICAgKlxuICAgKi9cbiAgLyogZXNsaW50LWVuYWJsZSB2YWxpZC1qc2RvYyAqL1xuICBsb2cobGV2ZWwsIG1zZywgLi4uc3BsYXQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1wYXJhbXNcbiAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGhvdHBhdGggb2YgbG9nZ2luZyBKU09OIGxpdGVyYWxzXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIFlvIGRhd2csIEkgaGVhcmQgeW91IGxpa2UgbGV2ZWxzIC4uLiBzZXJpb3VzbHkgLi4uXG4gICAgICAvLyBJbiB0aGlzIGNvbnRleHQgdGhlIExIUyBgbGV2ZWxgIGhlcmUgaXMgYWN0dWFsbHkgdGhlIGBpbmZvYCBzbyByZWFkXG4gICAgICAvLyB0aGlzIGFzOiBpbmZvW0xFVkVMXSA9IGluZm8ubGV2ZWw7XG4gICAgICBsZXZlbFtMRVZFTF0gPSBsZXZlbC5sZXZlbDtcbiAgICAgIHRoaXMuX2FkZERlZmF1bHRNZXRhKGxldmVsKTtcbiAgICAgIHRoaXMud3JpdGUobGV2ZWwpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gU2xpZ2h0bHkgbGVzcyBob3RwYXRoLCBidXQgd29ydGggb3B0aW1pemluZyBmb3IuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGlmIChtc2cgJiYgdHlwZW9mIG1zZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbXNnW0xFVkVMXSA9IG1zZy5sZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLl9hZGREZWZhdWx0TWV0YShtc2cpO1xuICAgICAgICB0aGlzLndyaXRlKG1zZyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBtc2cgPSB7IFtMRVZFTF06IGxldmVsLCBsZXZlbCwgbWVzc2FnZTogbXNnIH07XG4gICAgICB0aGlzLl9hZGREZWZhdWx0TWV0YShtc2cpO1xuICAgICAgdGhpcy53cml0ZShtc2cpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgW21ldGFdID0gc3BsYXQ7XG4gICAgaWYgKHR5cGVvZiBtZXRhID09PSAnb2JqZWN0JyAmJiBtZXRhICE9PSBudWxsKSB7XG4gICAgICAvLyBFeHRyYWN0IHRva2VucywgaWYgbm9uZSBhdmFpbGFibGUgZGVmYXVsdCB0byBlbXB0eSBhcnJheSB0b1xuICAgICAgLy8gZW5zdXJlIGNvbnNpc3RhbmN5IGluIGV4cGVjdGVkIHJlc3VsdHNcbiAgICAgIGNvbnN0IHRva2VucyA9IG1zZyAmJiBtc2cubWF0Y2ggJiYgbXNnLm1hdGNoKGZvcm1hdFJlZ0V4cCk7XG5cbiAgICAgIGlmICghdG9rZW5zKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRNZXRhLCBtZXRhLCB7XG4gICAgICAgICAgW0xFVkVMXTogbGV2ZWwsXG4gICAgICAgICAgW1NQTEFUXTogc3BsYXQsXG4gICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgbWVzc2FnZTogbXNnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtZXRhLm1lc3NhZ2UpIGluZm8ubWVzc2FnZSA9IGAke2luZm8ubWVzc2FnZX0gJHttZXRhLm1lc3NhZ2V9YDtcbiAgICAgICAgaWYgKG1ldGEuc3RhY2spIGluZm8uc3RhY2sgPSBtZXRhLnN0YWNrO1xuXG4gICAgICAgIHRoaXMud3JpdGUoaW5mbyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMud3JpdGUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0TWV0YSwge1xuICAgICAgW0xFVkVMXTogbGV2ZWwsXG4gICAgICBbU1BMQVRdOiBzcGxhdCxcbiAgICAgIGxldmVsLFxuICAgICAgbWVzc2FnZTogbXNnXG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUHVzaGVzIGRhdGEgc28gdGhhdCBpdCBjYW4gYmUgcGlja2VkIHVwIGJ5IGFsbCBvZiBvdXIgcGlwZSB0YXJnZXRzLlxuICAgKiBAcGFyYW0ge21peGVkfSBpbmZvIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge21peGVkfSBlbmMgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGNhbGxiYWNrIC0gQ29udGludWVzIHN0cmVhbSBwcm9jZXNzaW5nLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyYW5zZm9ybShpbmZvLCBlbmMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuc2lsZW50KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICAvLyBbTEVWRUxdIGlzIG9ubHkgc29mdCBndWFyYW50ZWVkIHRvIGJlIHNldCBoZXJlIHNpbmNlIHdlIGFyZSBhIHByb3BlclxuICAgIC8vIHN0cmVhbS4gSXQgaXMgbGlrZWx5IHRoYXQgYGluZm9gIGNhbWUgaW4gdGhyb3VnaCBgLmxvZyhpbmZvKWAgb3JcbiAgICAvLyBgLmluZm8oaW5mbylgLiBJZiBpdCBpcyBub3QgZGVmaW5lZCwgaG93ZXZlciwgZGVmaW5lIGl0LlxuICAgIC8vIFRoaXMgTEVWRUwgc3ltYm9sIGlzIHByb3ZpZGVkIGJ5IGB0cmlwbGUtYmVhbWAgYW5kIGFsc28gdXNlZCBpbjpcbiAgICAvLyAtIGxvZ2Zvcm1cbiAgICAvLyAtIHdpbnN0b24tdHJhbnNwb3J0XG4gICAgLy8gLSBhYnN0cmFjdC13aW5zdG9uLXRyYW5zcG9ydFxuICAgIGlmICghaW5mb1tMRVZFTF0pIHtcbiAgICAgIGluZm9bTEVWRUxdID0gaW5mby5sZXZlbDtcbiAgICB9XG5cbiAgICAvLyBSZW1hcms6IHJlYWxseSBub3Qgc3VyZSB3aGF0IHRvIGRvIGhlcmUsIGJ1dCB0aGlzIGhhcyBiZWVuIHJlcG9ydGVkIGFzXG4gICAgLy8gdmVyeSBjb25mdXNpbmcgYnkgcHJlIHdpbnN0b25AMi4wLjAgdXNlcnMgYXMgcXVpdGUgY29uZnVzaW5nIHdoZW4gdXNpbmdcbiAgICAvLyBjdXN0b20gbGV2ZWxzLlxuICAgIGlmICghdGhpcy5sZXZlbHNbaW5mb1tMRVZFTF1dICYmIHRoaXMubGV2ZWxzW2luZm9bTEVWRUxdXSAhPT0gMCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1t3aW5zdG9uXSBVbmtub3duIGxvZ2dlciBsZXZlbDogJXMnLCBpbmZvW0xFVkVMXSk7XG4gICAgfVxuXG4gICAgLy8gUmVtYXJrOiBub3Qgc3VyZSBpZiB3ZSBzaG91bGQgc2ltcGx5IGVycm9yIGhlcmUuXG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlLnBpcGVzKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ1t3aW5zdG9uXSBBdHRlbXB0IHRvIHdyaXRlIGxvZ3Mgd2l0aCBubyB0cmFuc3BvcnRzLCB3aGljaCBjYW4gaW5jcmVhc2UgbWVtb3J5IHVzYWdlOiAlaicsXG4gICAgICAgIGluZm9cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gSGVyZSB3ZSB3cml0ZSB0byB0aGUgYGZvcm1hdGAgcGlwZS1jaGFpbiwgd2hpY2ggb24gYHJlYWRhYmxlYCBhYm92ZSB3aWxsXG4gICAgLy8gcHVzaCB0aGUgZm9ybWF0dGVkIGBpbmZvYCBPYmplY3Qgb250byB0aGUgYnVmZmVyIGZvciB0aGlzIGluc3RhbmNlLiBXZSB0cmFwXG4gICAgLy8gKGFuZCByZS10aHJvdykgYW55IGVycm9ycyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXItcHJvdmlkZWQgZm9ybWF0LCBidXQgYWxzb1xuICAgIC8vIGd1YXJhbnRlZSB0aGF0IHRoZSBzdHJlYW1zIGNhbGxiYWNrIGlzIGludm9rZWQgc28gdGhhdCB3ZSBjYW4gY29udGludWUgZmxvd2luZy5cbiAgICB0cnkge1xuICAgICAgdGhpcy5wdXNoKHRoaXMuZm9ybWF0LnRyYW5zZm9ybShpbmZvLCB0aGlzLmZvcm1hdC5vcHRpb25zKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbGxiYWNrLXJldHVyblxuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsYXlzIHRoZSAnZmluaXNoJyBldmVudCB1bnRpbCBhbGwgdHJhbnNwb3J0IHBpcGUgdGFyZ2V0cyBoYXZlXG4gICAqIGFsc28gZW1pdHRlZCAnZmluaXNoJyBvciBhcmUgYWxyZWFkeSBmaW5pc2hlZC5cbiAgICogQHBhcmFtIHttaXhlZH0gY2FsbGJhY2sgLSBDb250aW51ZXMgc3RyZWFtIHByb2Nlc3NpbmcuXG4gICAqL1xuICBfZmluYWwoY2FsbGJhY2spIHtcbiAgICBjb25zdCB0cmFuc3BvcnRzID0gdGhpcy50cmFuc3BvcnRzLnNsaWNlKCk7XG4gICAgYXN5bmNGb3JFYWNoKFxuICAgICAgdHJhbnNwb3J0cyxcbiAgICAgICh0cmFuc3BvcnQsIG5leHQpID0+IHtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQgfHwgdHJhbnNwb3J0LmZpbmlzaGVkKSByZXR1cm4gc2V0SW1tZWRpYXRlKG5leHQpO1xuICAgICAgICB0cmFuc3BvcnQub25jZSgnZmluaXNoJywgbmV4dCk7XG4gICAgICAgIHRyYW5zcG9ydC5lbmQoKTtcbiAgICAgIH0sXG4gICAgICBjYWxsYmFja1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgdHJhbnNwb3J0IHRvIHRoaXMgbG9nZ2VyIGluc3RhbmNlIGJ5IHBpcGluZyB0byBpdC5cbiAgICogQHBhcmFtIHttaXhlZH0gdHJhbnNwb3J0IC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7TG9nZ2VyfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBhZGQodHJhbnNwb3J0KSB7XG4gICAgLy8gU3VwcG9ydCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGFsbCBleGlzdGluZyBgd2luc3RvbiA8IDMueC54YFxuICAgIC8vIHRyYW5zcG9ydHMgd2hpY2ggbWVldCBvbmUgb2YgdHdvIGNyaXRlcmlhOlxuICAgIC8vIDEuIFRoZXkgaW5oZXJpdCBmcm9tIHdpbnN0b24uVHJhbnNwb3J0IGluICA8IDMueC54IHdoaWNoIGlzIE5PVCBhIHN0cmVhbS5cbiAgICAvLyAyLiBUaGV5IGV4cG9zZSBhIGxvZyBtZXRob2Qgd2hpY2ggaGFzIGEgbGVuZ3RoIGdyZWF0ZXIgdGhhbiAyIChpLmUuIG1vcmUgdGhlblxuICAgIC8vICAgIGp1c3QgYGxvZyhpbmZvLCBjYWxsYmFjaylgLlxuICAgIGNvbnN0IHRhcmdldCA9XG4gICAgICAhaXNTdHJlYW0odHJhbnNwb3J0KSB8fCB0cmFuc3BvcnQubG9nLmxlbmd0aCA+IDJcbiAgICAgICAgPyBuZXcgTGVnYWN5VHJhbnNwb3J0U3RyZWFtKHsgdHJhbnNwb3J0IH0pXG4gICAgICAgIDogdHJhbnNwb3J0O1xuXG4gICAgaWYgKCF0YXJnZXQuX3dyaXRhYmxlU3RhdGUgfHwgIXRhcmdldC5fd3JpdGFibGVTdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUcmFuc3BvcnRzIG11c3QgV3JpdGFibGVTdHJlYW1zIGluIG9iamVjdE1vZGUuIFNldCB7IG9iamVjdE1vZGU6IHRydWUgfS4nXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIExpc3RlbiBmb3IgdGhlIGBlcnJvcmAgZXZlbnQgYW5kIHRoZSBgd2FybmAgZXZlbnQgb24gdGhlIG5ldyBUcmFuc3BvcnQuXG4gICAgdGhpcy5fb25FdmVudCgnZXJyb3InLCB0YXJnZXQpO1xuICAgIHRoaXMuX29uRXZlbnQoJ3dhcm4nLCB0YXJnZXQpO1xuICAgIHRoaXMucGlwZSh0YXJnZXQpO1xuXG4gICAgaWYgKHRyYW5zcG9ydC5oYW5kbGVFeGNlcHRpb25zKSB7XG4gICAgICB0aGlzLmV4Y2VwdGlvbnMuaGFuZGxlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zcG9ydC5oYW5kbGVSZWplY3Rpb25zKSB7XG4gICAgICB0aGlzLnJlamVjdGlvbnMuaGFuZGxlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgdHJhbnNwb3J0IGZyb20gdGhpcyBsb2dnZXIgaW5zdGFuY2UgYnkgdW5waXBpbmcgZnJvbSBpdC5cbiAgICogQHBhcmFtIHttaXhlZH0gdHJhbnNwb3J0IC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7TG9nZ2VyfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICByZW1vdmUodHJhbnNwb3J0KSB7XG4gICAgaWYgKCF0cmFuc3BvcnQpIHJldHVybiB0aGlzO1xuICAgIGxldCB0YXJnZXQgPSB0cmFuc3BvcnQ7XG4gICAgaWYgKCFpc1N0cmVhbSh0cmFuc3BvcnQpIHx8IHRyYW5zcG9ydC5sb2cubGVuZ3RoID4gMikge1xuICAgICAgdGFyZ2V0ID0gdGhpcy50cmFuc3BvcnRzLmZpbHRlcihcbiAgICAgICAgbWF0Y2ggPT4gbWF0Y2gudHJhbnNwb3J0ID09PSB0cmFuc3BvcnRcbiAgICAgIClbMF07XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy51bnBpcGUodGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgdHJhbnNwb3J0cyBmcm9tIHRoaXMgbG9nZ2VyIGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyB7TG9nZ2VyfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLnVucGlwZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCByZXNvdXJjZXMgKHN0cmVhbXMsIGV2ZW50IGxpc3RlbmVycykgZm9yIGFsbCB0cmFuc3BvcnRzXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluc3RhbmNlIChpZiBuZWNlc3NhcnkpLlxuICAgKiBAcmV0dXJucyB7TG9nZ2VyfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB0aGlzLmV4Y2VwdGlvbnMudW5oYW5kbGUoKTtcbiAgICB0aGlzLnJlamVjdGlvbnMudW5oYW5kbGUoKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGB0YXJnZXRgIGxldmVscyBzcGVjaWZpZWQgb24gdGhpcyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFRhcmdldCBsZXZlbHMgdG8gdXNlIG9uIHRoaXMgaW5zdGFuY2UuXG4gICAqL1xuICBzZXRMZXZlbHMoKSB7XG4gICAgd2Fybi5kZXByZWNhdGVkKCdzZXRMZXZlbHMnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyaWVzIHRoZSBhbGwgdHJhbnNwb3J0cyBmb3IgdGhpcyBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgYG9wdGlvbnNgLlxuICAgKiBUaGlzIHdpbGwgYWdncmVnYXRlIGVhY2ggdHJhbnNwb3J0J3MgcmVzdWx0cyBpbnRvIG9uZSBvYmplY3QgY29udGFpbmluZ1xuICAgKiBhIHByb3BlcnR5IHBlciB0cmFuc3BvcnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUXVlcnkgb3B0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDb250aW51YXRpb24gdG8gcmVzcG9uZCB0byB3aGVuIGNvbXBsZXRlLlxuICAgKi9cbiAgcXVlcnkob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCByZXN1bHRzID0ge307XG4gICAgY29uc3QgcXVlcnlPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnF1ZXJ5IHx8IHt9KTtcblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBxdWVyeSBhIHNpbmdsZSB0cmFuc3BvcnRcbiAgICBmdW5jdGlvbiBxdWVyeVRyYW5zcG9ydCh0cmFuc3BvcnQsIG5leHQpIHtcbiAgICAgIGlmIChvcHRpb25zLnF1ZXJ5ICYmIHR5cGVvZiB0cmFuc3BvcnQuZm9ybWF0UXVlcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0aW9ucy5xdWVyeSA9IHRyYW5zcG9ydC5mb3JtYXRRdWVyeShxdWVyeU9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIHRyYW5zcG9ydC5xdWVyeShvcHRpb25zLCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zcG9ydC5mb3JtYXRSZXN1bHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmVzID0gdHJhbnNwb3J0LmZvcm1hdFJlc3VsdHMocmVzLCBvcHRpb25zLmZvcm1hdCk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KG51bGwsIHJlcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gYWNjdW11bGF0ZSB0aGUgcmVzdWx0cyBmcm9tIGBxdWVyeVRyYW5zcG9ydGAgaW50b1xuICAgIC8vIHRoZSBgcmVzdWx0c2AuXG4gICAgZnVuY3Rpb24gYWRkUmVzdWx0cyh0cmFuc3BvcnQsIG5leHQpIHtcbiAgICAgIHF1ZXJ5VHJhbnNwb3J0KHRyYW5zcG9ydCwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIC8vIHF1ZXJ5VHJhbnNwb3J0IGNvdWxkIHBvdGVudGlhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgLy8gc2luY2UgVHJhbnNwb3J0IGNvZGUgY2FuIGJlIHVucHJlZGljdGFibGUuXG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gZXJyIHx8IHJlc3VsdDtcbiAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHRzW3RyYW5zcG9ydC5uYW1lXSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRyYW5zcG9ydHMgaW4gcGFyYWxsZWwgc2V0dGluZyB0aGUgYXBwcm9wcmlhdGUga2V5IGluXG4gICAgLy8gdGhlIGByZXN1bHRzYC5cbiAgICBhc3luY0ZvckVhY2goXG4gICAgICB0aGlzLnRyYW5zcG9ydHMuZmlsdGVyKHRyYW5zcG9ydCA9PiAhIXRyYW5zcG9ydC5xdWVyeSksXG4gICAgICBhZGRSZXN1bHRzLFxuICAgICAgKCkgPT4gY2FsbGJhY2sobnVsbCwgcmVzdWx0cylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2cgc3RyZWFtIGZvciBhbGwgdHJhbnNwb3J0cy4gT3B0aW9ucyBvYmplY3QgaXMgb3B0aW9uYWwuXG4gICAqIEBwYXJhbXtPYmplY3R9IG9wdGlvbnM9e30gLSBTdHJlYW0gb3B0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge1N0cmVhbX0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgc3RyZWFtKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG91dCA9IG5ldyBTdHJlYW0oKTtcbiAgICBjb25zdCBzdHJlYW1zID0gW107XG5cbiAgICBvdXQuX3N0cmVhbXMgPSBzdHJlYW1zO1xuICAgIG91dC5kZXN0cm95ID0gKCkgPT4ge1xuICAgICAgbGV0IGkgPSBzdHJlYW1zLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgc3RyZWFtc1tpXS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBhIGxpc3Qgb2YgYWxsIHRyYW5zcG9ydHMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgdGhpcy50cmFuc3BvcnRzXG4gICAgICAuZmlsdGVyKHRyYW5zcG9ydCA9PiAhIXRyYW5zcG9ydC5zdHJlYW0pXG4gICAgICAuZm9yRWFjaCh0cmFuc3BvcnQgPT4ge1xuICAgICAgICBjb25zdCBzdHIgPSB0cmFuc3BvcnQuc3RyZWFtKG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXN0cikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmVhbXMucHVzaChzdHIpO1xuXG4gICAgICAgIHN0ci5vbignbG9nJywgbG9nID0+IHtcbiAgICAgICAgICBsb2cudHJhbnNwb3J0ID0gbG9nLnRyYW5zcG9ydCB8fCBbXTtcbiAgICAgICAgICBsb2cudHJhbnNwb3J0LnB1c2godHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICAgIG91dC5lbWl0KCdsb2cnLCBsb2cpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzdHIub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICBlcnIudHJhbnNwb3J0ID0gZXJyLnRyYW5zcG9ydCB8fCBbXTtcbiAgICAgICAgICBlcnIudHJhbnNwb3J0LnB1c2godHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICAgIG91dC5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gYSBzcGVjaWZpYyB0aW1pbmcuIFdoZW4gZG9uZSBpcyBjYWxsZWRcbiAgICogdGhlIHRpbWVyIHdpbGwgZmluaXNoIGFuZCBsb2cgdGhlIGR1cmF0aW9uLiBlLmcuOlxuICAgKiBAcmV0dXJucyB7UHJvZmlsZX0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKiAgICBjb25zdCB0aW1lciA9IHdpbnN0b24uc3RhcnRUaW1lcigpXG4gICAqICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgKiAgICAgIHRpbWVyLmRvbmUoe1xuICAgKiAgICAgICAgbWVzc2FnZTogJ0xvZ2dpbmcgbWVzc2FnZSdcbiAgICogICAgICB9KTtcbiAgICogICAgfSwgMTAwMCk7XG4gICAqL1xuICBzdGFydFRpbWVyKCkge1xuICAgIHJldHVybiBuZXcgUHJvZmlsZXIodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVHJhY2tzIHRoZSB0aW1lIGluYmV0d2VlbiBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoaXMgbWV0aG9kIHdpdGggdGhlIHNhbWVcbiAgICogYGlkYCBwYXJhbWV0ZXIuIFRoZSBzZWNvbmQgY2FsbCB0byB0aGlzIG1ldGhvZCB3aWxsIGxvZyB0aGUgZGlmZmVyZW5jZSBpblxuICAgKiBtaWxsaXNlY29uZHMgYWxvbmcgd2l0aCB0aGUgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuaXF1ZSBpZCBvZiB0aGUgcHJvZmlsZXJcbiAgICogQHJldHVybnMge0xvZ2dlcn0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgcHJvZmlsZShpZCwgLi4uYXJncykge1xuICAgIGNvbnN0IHRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGlmICh0aGlzLnByb2ZpbGVyc1tpZF0pIHtcbiAgICAgIGNvbnN0IHRpbWVFbmQgPSB0aGlzLnByb2ZpbGVyc1tpZF07XG4gICAgICBkZWxldGUgdGhpcy5wcm9maWxlcnNbaWRdO1xuXG4gICAgICAvLyBBdHRlbXB0IHRvIGJlIGtpbmQgdG8gdXNlcnMgaWYgdGhleSBhcmUgc3RpbGwgdXNpbmcgb2xkZXIgQVBJcy5cbiAgICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnQ2FsbGJhY2sgZnVuY3Rpb24gbm8gbG9uZ2VyIHN1cHBvcnRlZCBhcyBvZiB3aW5zdG9uQDMuMC4wJ1xuICAgICAgICApO1xuICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIGR1cmF0aW9uIHByb3BlcnR5IG9mIHRoZSBtZXRhZGF0YVxuICAgICAgY29uc3QgaW5mbyA9IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdvYmplY3QnID8gYXJncy5wb3AoKSA6IHt9O1xuICAgICAgaW5mby5sZXZlbCA9IGluZm8ubGV2ZWwgfHwgJ2luZm8nO1xuICAgICAgaW5mby5kdXJhdGlvbk1zID0gdGltZSAtIHRpbWVFbmQ7XG4gICAgICBpbmZvLm1lc3NhZ2UgPSBpbmZvLm1lc3NhZ2UgfHwgaWQ7XG4gICAgICByZXR1cm4gdGhpcy53cml0ZShpbmZvKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2ZpbGVyc1tpZF0gPSB0aW1lO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHRvIGBleGNlcHRpb25zLmhhbmRsZWAgaW4gd2luc3RvbiA8IDMuMC4wLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgaGFuZGxlRXhjZXB0aW9ucyguLi5hcmdzKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnRGVwcmVjYXRlZDogLmhhbmRsZUV4Y2VwdGlvbnMoKSB3aWxsIGJlIHJlbW92ZWQgaW4gd2luc3RvbkA0LiBVc2UgLmV4Y2VwdGlvbnMuaGFuZGxlKCknXG4gICAgKTtcbiAgICB0aGlzLmV4Y2VwdGlvbnMuaGFuZGxlKC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHRvIGBleGNlcHRpb25zLmhhbmRsZWAgaW4gd2luc3RvbiA8IDMuMC4wLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgdW5oYW5kbGVFeGNlcHRpb25zKC4uLmFyZ3MpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdEZXByZWNhdGVkOiAudW5oYW5kbGVFeGNlcHRpb25zKCkgd2lsbCBiZSByZW1vdmVkIGluIHdpbnN0b25ANC4gVXNlIC5leGNlcHRpb25zLnVuaGFuZGxlKCknXG4gICAgKTtcbiAgICB0aGlzLmV4Y2VwdGlvbnMudW5oYW5kbGUoLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogVGhyb3cgYSBtb3JlIG1lYW5pbmdmdWwgZGVwcmVjYXRpb24gbm90aWNlXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFRPRE86IGFkZCB0aHJvd3MgZGVzY3JpcHRpb24uXG4gICAqL1xuICBjbGkoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgW1xuICAgICAgICAnTG9nZ2VyLmNsaSgpIHdhcyByZW1vdmVkIGluIHdpbnN0b25AMy4wLjAnLFxuICAgICAgICAnVXNlIGEgY3VzdG9tIHdpbnN0b24uZm9ybWF0cy5jbGkoKSBpbnN0ZWFkLicsXG4gICAgICAgICdTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS93aW5zdG9uanMvd2luc3Rvbi90cmVlL21hc3Rlci9VUEdSQURFLTMuMC5tZCdcbiAgICAgIF0uam9pbignXFxuJylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1YmJsZXMgdGhlIGBldmVudGAgdGhhdCBvY2N1cmVkIG9uIHRoZSBzcGVjaWZpZWQgYHRyYW5zcG9ydGAgdXBcbiAgICogZnJvbSB0aGlzIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgdGhhdCBvY2N1cmVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc3BvcnQgLSBUcmFuc3BvcnQgb24gd2hpY2ggdGhlIGV2ZW50IG9jY3VyZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkV2ZW50KGV2ZW50LCB0cmFuc3BvcnQpIHtcbiAgICBmdW5jdGlvbiB0cmFuc3BvcnRFdmVudChlcnIpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93aW5zdG9uanMvd2luc3Rvbi9pc3N1ZXMvMTM2NFxuICAgICAgaWYgKGV2ZW50ID09PSAnZXJyb3InICYmICF0aGlzLnRyYW5zcG9ydHMuaW5jbHVkZXModHJhbnNwb3J0KSkge1xuICAgICAgICB0aGlzLmFkZCh0cmFuc3BvcnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KGV2ZW50LCBlcnIsIHRyYW5zcG9ydCk7XG4gICAgfVxuXG4gICAgaWYgKCF0cmFuc3BvcnRbJ19fd2luc3RvbicgKyBldmVudF0pIHtcbiAgICAgIHRyYW5zcG9ydFsnX193aW5zdG9uJyArIGV2ZW50XSA9IHRyYW5zcG9ydEV2ZW50LmJpbmQodGhpcyk7XG4gICAgICB0cmFuc3BvcnQub24oZXZlbnQsIHRyYW5zcG9ydFsnX193aW5zdG9uJyArIGV2ZW50XSk7XG4gICAgfVxuICB9XG5cbiAgX2FkZERlZmF1bHRNZXRhKG1zZykge1xuICAgIGlmICh0aGlzLmRlZmF1bHRNZXRhKSB7XG4gICAgICBPYmplY3QuYXNzaWduKG1zZywgdGhpcy5kZWZhdWx0TWV0YSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldExldmVsVmFsdWUobGV2ZWxzLCBsZXZlbCkge1xuICBjb25zdCB2YWx1ZSA9IGxldmVsc1tsZXZlbF07XG4gIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY3VycmVudCByZWFkYWJsZVN0YXRlIHBpcGUgdGFyZ2V0cyBmb3IgdGhpcyBMb2dnZXIgaW5zdGFuY2UuXG4gKiBAdHlwZSB7QXJyYXl8T2JqZWN0fVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nZ2VyLnByb3RvdHlwZSwgJ3RyYW5zcG9ydHMnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldCgpIHtcbiAgICBjb25zdCB7IHBpcGVzIH0gPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIHJldHVybiAhQXJyYXkuaXNBcnJheShwaXBlcykgPyBbcGlwZXNdLmZpbHRlcihCb29sZWFuKSA6IHBpcGVzO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2dnZXI7XG4iLCAiLyoqXG4gKiBjcmVhdGUtbG9nZ2VyLmpzOiBMb2dnZXIgZmFjdG9yeSBmb3Igd2luc3RvbiBsb2dnZXIgaW5zdGFuY2VzLlxuICpcbiAqIChDKSAyMDEwIENoYXJsaWUgUm9iYmluc1xuICogTUlUIExJQ0VOQ0VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgTEVWRUwgfSA9IHJlcXVpcmUoJ3RyaXBsZS1iZWFtJyk7XG5jb25zdCBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnQGRhYmgvZGlhZ25vc3RpY3MnKSgnd2luc3RvbjpjcmVhdGUtbG9nZ2VyJyk7XG5cbmZ1bmN0aW9uIGlzTGV2ZWxFbmFibGVkRnVuY3Rpb25OYW1lKGxldmVsKSB7XG4gIHJldHVybiAnaXMnICsgbGV2ZWwuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBsZXZlbC5zbGljZSgxKSArICdFbmFibGVkJztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYSB3aW5zdG9uIExvZ2dlci4gQ3JlYXRlcyBhIG5ld1xuICogcHJvdG90eXBlIGZvciBlYWNoIGluc3RhbmNlLlxuICogQHBhcmFtIHshT2JqZWN0fSBvcHRzIC0gT3B0aW9ucyBmb3IgdGhlIGNyZWF0ZWQgbG9nZ2VyLlxuICogQHJldHVybnMge0xvZ2dlcn0gLSBBIG5ld2x5IGNyZWF0ZWQgbG9nZ2VyIGluc3RhbmNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzID0ge30pIHtcbiAgLy9cbiAgLy8gRGVmYXVsdCBsZXZlbHM6IG5wbVxuICAvL1xuICBvcHRzLmxldmVscyA9IG9wdHMubGV2ZWxzIHx8IGNvbmZpZy5ucG0ubGV2ZWxzO1xuXG4gIC8qKlxuICAgKiBEZXJpdmVkTG9nZ2VyIHRvIGF0dGFjaCB0aGUgbG9ncyBsZXZlbCBtZXRob2RzLlxuICAgKiBAdHlwZSB7RGVyaXZlZExvZ2dlcn1cbiAgICogQGV4dGVuZHMge0xvZ2dlcn1cbiAgICovXG4gIGNsYXNzIERlcml2ZWRMb2dnZXIgZXh0ZW5kcyBMb2dnZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBjbGFzcyBkZXJpdmVkIGxvZ2dlciBmb3Igd2hpY2ggdGhlIGxldmVscyBjYW4gYmUgYXR0YWNoZWQgdG9cbiAgICAgKiB0aGUgcHJvdG90eXBlIG9mLiBUaGlzIGlzIGEgVjggb3B0aW1pemF0aW9uIHRoYXQgaXMgd2VsbCBrbm93IHRvIGluY3JlYXNlXG4gICAgICogcGVyZm9ybWFuY2Ugb2YgcHJvdG90eXBlIGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgY3JlYXRlZCBsb2dnZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbG9nZ2VyID0gbmV3IERlcml2ZWRMb2dnZXIob3B0cyk7XG5cbiAgLy9cbiAgLy8gQ3JlYXRlIHRoZSBsb2cgbGV2ZWwgbWV0aG9kcyBmb3IgdGhlIGRlcml2ZWQgbG9nZ2VyLlxuICAvL1xuICBPYmplY3Qua2V5cyhvcHRzLmxldmVscykuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICBkZWJ1ZygnRGVmaW5lIHByb3RvdHlwZSBtZXRob2QgZm9yIFwiJXNcIicsIGxldmVsKTtcbiAgICBpZiAobGV2ZWwgPT09ICdsb2cnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKCdMZXZlbCBcImxvZ1wiIG5vdCBkZWZpbmVkOiBjb25mbGljdHMgd2l0aCB0aGUgbWV0aG9kIFwibG9nXCIuIFVzZSBhIGRpZmZlcmVudCBsZXZlbCBuYW1lLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gRGVmaW5lIHByb3RvdHlwZSBtZXRob2RzIGZvciBlYWNoIGxvZyBsZXZlbCBlLmcuOlxuICAgIC8vIGxvZ2dlci5sb2coJ2luZm8nLCBtc2cpIGltcGxpZXMgdGhlc2UgbWV0aG9kcyBhcmUgZGVmaW5lZDpcbiAgICAvLyAtIGxvZ2dlci5pbmZvKG1zZylcbiAgICAvLyAtIGxvZ2dlci5pc0luZm9FbmFibGVkKClcbiAgICAvL1xuICAgIC8vIFJlbWFyazogdG8gc3VwcG9ydCBsb2dnZXIuY2hpbGQgdGhpcyAqKk1VU1QqKiBiZSBhIGZ1bmN0aW9uXG4gICAgLy8gc28gaXQnbGwgYWx3YXlzIGJlIGNhbGxlZCBvbiB0aGUgaW5zdGFuY2UgaW5zdGVhZCBvZiBhIGZpeGVkXG4gICAgLy8gcGxhY2UgaW4gdGhlIHByb3RvdHlwZSBjaGFpbi5cbiAgICAvL1xuICAgIERlcml2ZWRMb2dnZXIucHJvdG90eXBlW2xldmVsXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAvLyBQcmVmZXIgYW55IGluc3RhbmNlIHNjb3BlLCBidXQgZGVmYXVsdCB0byBcInJvb3RcIiBsb2dnZXJcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzIHx8IGxvZ2dlcjtcblxuICAgICAgLy8gT3B0aW1pemUgdGhlIGhvdC1wYXRoIHdoaWNoIGlzIHRoZSBzaW5nbGUgb2JqZWN0LlxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IFttc2ddID0gYXJncztcbiAgICAgICAgY29uc3QgaW5mbyA9IG1zZyAmJiBtc2cubWVzc2FnZSAmJiBtc2cgfHwgeyBtZXNzYWdlOiBtc2cgfTtcbiAgICAgICAgaW5mby5sZXZlbCA9IGluZm9bTEVWRUxdID0gbGV2ZWw7XG4gICAgICAgIHNlbGYuX2FkZERlZmF1bHRNZXRhKGluZm8pO1xuICAgICAgICBzZWxmLndyaXRlKGluZm8pO1xuICAgICAgICByZXR1cm4gKHRoaXMgfHwgbG9nZ2VyKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2hlbiBwcm92aWRlZCBub3RoaW5nIGFzc3VtZSB0aGUgZW1wdHkgc3RyaW5nXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi5sb2cobGV2ZWwsICcnKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSBidWlsZCBhcmd1bWVudCBsaXN0IHdoaWNoIGNvdWxkIHBvdGVudGlhbGx5IGNvbmZvcm0gdG9cbiAgICAgIC8vIGVpdGhlcjpcbiAgICAgIC8vIC4gdjMgQVBJOiBsb2cob2JqKVxuICAgICAgLy8gMi4gdjEvdjIgQVBJOiBsb2cobGV2ZWwsIG1zZywgLi4uIFtzdHJpbmcgaW50ZXJwb2xhdGVdLCBbe21ldGFkYXRhfV0sIFtjYWxsYmFja10pXG4gICAgICByZXR1cm4gc2VsZi5sb2cobGV2ZWwsIC4uLmFyZ3MpO1xuICAgIH07XG5cbiAgICBEZXJpdmVkTG9nZ2VyLnByb3RvdHlwZVtpc0xldmVsRW5hYmxlZEZ1bmN0aW9uTmFtZShsZXZlbCldID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICh0aGlzIHx8IGxvZ2dlcikuaXNMZXZlbEVuYWJsZWQobGV2ZWwpO1xuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiBsb2dnZXI7XG59O1xuIiwgIi8qKlxuICogY29udGFpbmVyLmpzOiBJbnZlcnNpb24gb2YgY29udHJvbCBjb250YWluZXIgZm9yIHdpbnN0b24gbG9nZ2VyIGluc3RhbmNlcy5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjcmVhdGVMb2dnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZS1sb2dnZXInKTtcblxuLyoqXG4gKiBJbnZlcnNpb24gb2YgY29udHJvbCBjb250YWluZXIgZm9yIHdpbnN0b24gbG9nZ2VyIGluc3RhbmNlcy5cbiAqIEB0eXBlIHtDb250YWluZXJ9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ29udGFpbmVyIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgQ29udGFpbmVyIG9iamVjdCByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgYVxuICAgKiBzZXQgb2YgYHdpbnN0b24uTG9nZ2VyYCBpbnN0YW5jZXMgYmFzZWQgb24gc3RyaW5nIGlkcy5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBbb3B0aW9ucz17fV0gLSBEZWZhdWx0IHBhc3MtdGhydSBvcHRpb25zIGZvciBMb2dnZXJzLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5sb2dnZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgYHdpbnN0b24uTG9nZ2VyYCBpbnN0YW5jZSBmb3IgdGhlIHNwZWNpZmllZCBgaWRgLiBJZiBhblxuICAgKiBpbnN0YW5jZSBkb2VzIG5vdCBleGlzdCwgb25lIGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIExvZ2dlciB0byBnZXQuXG4gICAqIEBwYXJhbSB7P09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge0xvZ2dlcn0gLSBBIGNvbmZpZ3VyZWQgTG9nZ2VyIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpZWQgaWQuXG4gICAqL1xuICBhZGQoaWQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMubG9nZ2Vycy5oYXMoaWQpKSB7XG4gICAgICAvLyBSZW1hcms6IFNpbXBsZSBzaGFsbG93IGNsb25lIGZvciBjb25maWd1cmF0aW9uIG9wdGlvbnMgaW4gY2FzZSB3ZSBwYXNzXG4gICAgICAvLyBpbiBpbnN0YW50aWF0ZWQgcHJvdG95cGFsIG9iamVjdHNcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyk7XG4gICAgICBjb25zdCBleGlzdGluZyA9IG9wdGlvbnMudHJhbnNwb3J0cyB8fCB0aGlzLm9wdGlvbnMudHJhbnNwb3J0cztcblxuICAgICAgLy8gUmVtYXJrOiBNYWtlIHN1cmUgaWYgd2UgaGF2ZSBhbiBhcnJheSBvZiB0cmFuc3BvcnRzIHdlIHNsaWNlIGl0IHRvXG4gICAgICAvLyBtYWtlIGNvcGllcyBvZiB0aG9zZSByZWZlcmVuY2VzLlxuICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNwb3J0cyA9IEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpID8gZXhpc3Rpbmcuc2xpY2UoKSA6IFtleGlzdGluZ107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnRyYW5zcG9ydHMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKG9wdGlvbnMpO1xuICAgICAgbG9nZ2VyLm9uKCdjbG9zZScsICgpID0+IHRoaXMuX2RlbGV0ZShpZCkpO1xuICAgICAgdGhpcy5sb2dnZXJzLnNldChpZCwgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sb2dnZXJzLmdldChpZCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmVpdmVzIGEgYHdpbnN0b24uTG9nZ2VyYCBpbnN0YW5jZSBmb3IgdGhlIHNwZWNpZmllZCBgaWRgLiBJZlxuICAgKiBhbiBpbnN0YW5jZSBkb2VzIG5vdCBleGlzdCwgb25lIGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIExvZ2dlciB0byBnZXQuXG4gICAqIEBwYXJhbSB7P09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge0xvZ2dlcn0gLSBBIGNvbmZpZ3VyZWQgTG9nZ2VyIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpZWQgaWQuXG4gICAqL1xuICBnZXQoaWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5hZGQoaWQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBjb250YWluZXIgaGFzIGEgbG9nZ2VyIHdpdGggdGhlIGlkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGlkIC0gVGhlIGlkIG9mIHRoZSBMb2dnZXIgaW5zdGFuY2UgdG8gZmluZC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gQm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoaXMgaW5zdGFuY2UgaGFzIGFcbiAgICogbG9nZ2VyIHdpdGggdGhlIHNwZWNpZmllZCBgaWRgLlxuICAgKi9cbiAgaGFzKGlkKSB7XG4gICAgcmV0dXJuICEhdGhpcy5sb2dnZXJzLmhhcyhpZCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIGEgYExvZ2dlcmAgaW5zdGFuY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIGBpZGAgaWYgaXQgZXhpc3RzLlxuICAgKiBJZiBubyBgaWRgIGlzIHN1cHBsaWVkIHRoZW4gYWxsIExvZ2dlcnMgYXJlIGNsb3NlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBpZCAtIFRoZSBpZCBvZiB0aGUgTG9nZ2VyIGluc3RhbmNlIHRvIGNsb3NlLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgY2xvc2UoaWQpIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVMb2dnZXIoaWQpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2Vycy5mb3JFYWNoKCh2YWwsIGtleSkgPT4gdGhpcy5fcmVtb3ZlTG9nZ2VyKGtleSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGxvZ2dlciBiYXNlZCBvbiB0aGUgaWQuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIGxvZ2dlciB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVtb3ZlTG9nZ2VyKGlkKSB7XG4gICAgaWYgKCF0aGlzLmxvZ2dlcnMuaGFzKGlkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGxvZ2dlciA9IHRoaXMubG9nZ2Vycy5nZXQoaWQpO1xuICAgIGxvZ2dlci5jbG9zZSgpO1xuICAgIHRoaXMuX2RlbGV0ZShpZCk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhIGBMb2dnZXJgIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBgaWRgLlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGlkIC0gVGhlIGlkIG9mIHRoZSBMb2dnZXIgaW5zdGFuY2UgdG8gZGVsZXRlIGZyb21cbiAgICogY29udGFpbmVyLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlbGV0ZShpZCkge1xuICAgIHRoaXMubG9nZ2Vycy5kZWxldGUoaWQpO1xuICB9XG59O1xuIiwgIi8qKlxuICogd2luc3Rvbi5qczogVG9wLWxldmVsIGluY2x1ZGUgZGVmaW5pbmcgV2luc3Rvbi5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBsb2dmb3JtID0gcmVxdWlyZSgnbG9nZm9ybScpO1xuY29uc3QgeyB3YXJuIH0gPSByZXF1aXJlKCcuL3dpbnN0b24vY29tbW9uJyk7XG5cbi8qKlxuICogRXhwb3NlIHZlcnNpb24uIFVzZSBgcmVxdWlyZWAgbWV0aG9kIGZvciBgd2VicGFja2Agc3VwcG9ydC5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMudmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4vKipcbiAqIEluY2x1ZGUgdHJhbnNwb3J0cyBkZWZpbmVkIGJ5IGRlZmF1bHQgYnkgd2luc3RvblxuICogQHR5cGUge0FycmF5fVxuICovXG5leHBvcnRzLnRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3dpbnN0b24vdHJhbnNwb3J0cycpO1xuLyoqXG4gKiBFeHBvc2UgdXRpbGl0eSBtZXRob2RzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLmNvbmZpZyA9IHJlcXVpcmUoJy4vd2luc3Rvbi9jb25maWcnKTtcbi8qKlxuICogSG9pc3QgZm9ybWF0LXJlbGF0ZWQgZnVuY3Rpb25hbGl0eSBmcm9tIGxvZ2Zvcm0uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLmFkZENvbG9ycyA9IGxvZ2Zvcm0ubGV2ZWxzO1xuLyoqXG4gKiBIb2lzdCBmb3JtYXQtcmVsYXRlZCBmdW5jdGlvbmFsaXR5IGZyb20gbG9nZm9ybS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZm9ybWF0ID0gbG9nZm9ybS5mb3JtYXQ7XG4vKipcbiAqIEV4cG9zZSBjb3JlIExvZ2dpbmctcmVsYXRlZCBwcm90b3R5cGVzLlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICovXG5leHBvcnRzLmNyZWF0ZUxvZ2dlciA9IHJlcXVpcmUoJy4vd2luc3Rvbi9jcmVhdGUtbG9nZ2VyJyk7XG4vKipcbiAqIEV4cG9zZSBjb3JlIExvZ2dpbmctcmVsYXRlZCBwcm90b3R5cGVzLlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICovXG5leHBvcnRzLkxvZ2dlciA9IHJlcXVpcmUoJy4vd2luc3Rvbi9sb2dnZXInKTtcbi8qKlxuICogRXhwb3NlIGNvcmUgTG9nZ2luZy1yZWxhdGVkIHByb3RvdHlwZXMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLkV4Y2VwdGlvbkhhbmRsZXIgPSByZXF1aXJlKCcuL3dpbnN0b24vZXhjZXB0aW9uLWhhbmRsZXInKTtcbi8qKlxuICogRXhwb3NlIGNvcmUgTG9nZ2luZy1yZWxhdGVkIHByb3RvdHlwZXMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLlJlamVjdGlvbkhhbmRsZXIgPSByZXF1aXJlKCcuL3dpbnN0b24vcmVqZWN0aW9uLWhhbmRsZXInKTtcbi8qKlxuICogRXhwb3NlIGNvcmUgTG9nZ2luZy1yZWxhdGVkIHByb3RvdHlwZXMuXG4gKiBAdHlwZSB7Q29udGFpbmVyfVxuICovXG5leHBvcnRzLkNvbnRhaW5lciA9IHJlcXVpcmUoJy4vd2luc3Rvbi9jb250YWluZXInKTtcbi8qKlxuICogRXhwb3NlIGNvcmUgTG9nZ2luZy1yZWxhdGVkIHByb3RvdHlwZXMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLlRyYW5zcG9ydCA9IHJlcXVpcmUoJ3dpbnN0b24tdHJhbnNwb3J0Jyk7XG4vKipcbiAqIFdlIGNyZWF0ZSBhbmQgZXhwb3NlIGEgZGVmYXVsdCBgQ29udGFpbmVyYCB0byBgd2luc3Rvbi5sb2dnZXJzYCBzbyB0aGF0IHRoZVxuICogcHJvZ3JhbW1lciBtYXkgbWFuYWdlIG11bHRpcGxlIGB3aW5zdG9uLkxvZ2dlcmAgaW5zdGFuY2VzIHdpdGhvdXQgYW55XG4gKiBhZGRpdGlvbmFsIG92ZXJoZWFkLlxuICogQGV4YW1wbGVcbiAqICAgLy8gc29tZS1maWxlMS5qc1xuICogICBjb25zdCBsb2dnZXIgPSByZXF1aXJlKCd3aW5zdG9uJykubG9nZ2Vycy5nZXQoJ3NvbWV0aGluZycpO1xuICpcbiAqICAgLy8gc29tZS1maWxlMi5qc1xuICogICBjb25zdCBsb2dnZXIgPSByZXF1aXJlKCd3aW5zdG9uJykubG9nZ2Vycy5nZXQoJ3NvbWV0aGluZycpO1xuICovXG5leHBvcnRzLmxvZ2dlcnMgPSBuZXcgZXhwb3J0cy5Db250YWluZXIoKTtcblxuLyoqXG4gKiBXZSBjcmVhdGUgYW5kIGV4cG9zZSBhICdkZWZhdWx0TG9nZ2VyJyBzbyB0aGF0IHRoZSBwcm9ncmFtbWVyIG1heSBkbyB0aGVcbiAqIGZvbGxvd2luZyB3aXRob3V0IHRoZSBuZWVkIHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB3aW5zdG9uLkxvZ2dlciBkaXJlY3RseTpcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IHdpbnN0b24gPSByZXF1aXJlKCd3aW5zdG9uJyk7XG4gKiAgIHdpbnN0b24ubG9nKCdpbmZvJywgJ3NvbWUgbWVzc2FnZScpO1xuICogICB3aW5zdG9uLmVycm9yKCdzb21lIGVycm9yJyk7XG4gKi9cbmNvbnN0IGRlZmF1bHRMb2dnZXIgPSBleHBvcnRzLmNyZWF0ZUxvZ2dlcigpO1xuXG4vLyBQYXNzIHRocm91Z2ggdGhlIHRhcmdldCBtZXRob2RzIG9udG8gYHdpbnN0b24uXG5PYmplY3Qua2V5cyhleHBvcnRzLmNvbmZpZy5ucG0ubGV2ZWxzKVxuICAuY29uY2F0KFtcbiAgICAnbG9nJyxcbiAgICAncXVlcnknLFxuICAgICdzdHJlYW0nLFxuICAgICdhZGQnLFxuICAgICdyZW1vdmUnLFxuICAgICdjbGVhcicsXG4gICAgJ3Byb2ZpbGUnLFxuICAgICdzdGFydFRpbWVyJyxcbiAgICAnaGFuZGxlRXhjZXB0aW9ucycsXG4gICAgJ3VuaGFuZGxlRXhjZXB0aW9ucycsXG4gICAgJ2hhbmRsZVJlamVjdGlvbnMnLFxuICAgICd1bmhhbmRsZVJlamVjdGlvbnMnLFxuICAgICdjb25maWd1cmUnLFxuICAgICdjaGlsZCdcbiAgXSlcbiAgLmZvckVhY2goXG4gICAgbWV0aG9kID0+IChleHBvcnRzW21ldGhvZF0gPSAoLi4uYXJncykgPT4gZGVmYXVsdExvZ2dlclttZXRob2RdKC4uLmFyZ3MpKVxuICApO1xuXG4vKipcbiAqIERlZmluZSBnZXR0ZXIgLyBzZXR0ZXIgZm9yIHRoZSBkZWZhdWx0IGxvZ2dlciBsZXZlbCB3aGljaCBuZWVkIHRvIGJlIGV4cG9zZWRcbiAqIGJ5IHdpbnN0b24uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2xldmVsJywge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXIubGV2ZWw7XG4gIH0sXG4gIHNldCh2YWwpIHtcbiAgICBkZWZhdWx0TG9nZ2VyLmxldmVsID0gdmFsO1xuICB9XG59KTtcblxuLyoqXG4gKiBEZWZpbmUgZ2V0dGVyIGZvciBgZXhjZXB0aW9uc2Agd2hpY2ggcmVwbGFjZXMgYGhhbmRsZUV4Y2VwdGlvbnNgIGFuZFxuICogYHVuaGFuZGxlRXhjZXB0aW9uc2AuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2V4Y2VwdGlvbnMnLCB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlci5leGNlcHRpb25zO1xuICB9XG59KTtcblxuLyoqXG4gKiBEZWZpbmUgZ2V0dGVycyAvIHNldHRlcnMgZm9yIGFwcHJvcHJpYXRlIHByb3BlcnRpZXMgb2YgdGhlIGRlZmF1bHQgbG9nZ2VyXG4gKiB3aGljaCBuZWVkIHRvIGJlIGV4cG9zZWQgYnkgd2luc3Rvbi5cbiAqIEB0eXBlIHtMb2dnZXJ9XG4gKi9cblsnZXhpdE9uRXJyb3InXS5mb3JFYWNoKHByb3AgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgcHJvcCwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyW3Byb3BdO1xuICAgIH0sXG4gICAgc2V0KHZhbCkge1xuICAgICAgZGVmYXVsdExvZ2dlcltwcm9wXSA9IHZhbDtcbiAgICB9XG4gIH0pO1xufSk7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgdHJhbnNwb3J0cyBhbmQgZXhjZXB0aW9uSGFuZGxlcnMgZm9yIHRoZSBkZWZhdWx0IHdpbnN0b24gbG9nZ2VyLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0Jywge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4Y2VwdGlvbkhhbmRsZXJzOiBkZWZhdWx0TG9nZ2VyLmV4Y2VwdGlvbkhhbmRsZXJzLFxuICAgICAgcmVqZWN0aW9uSGFuZGxlcnM6IGRlZmF1bHRMb2dnZXIucmVqZWN0aW9uSGFuZGxlcnMsXG4gICAgICB0cmFuc3BvcnRzOiBkZWZhdWx0TG9nZ2VyLnRyYW5zcG9ydHNcbiAgICB9O1xuICB9XG59KTtcblxuLy8gSGF2ZSBmcmllbmRsaWVyIGJyZWFrYWdlIG5vdGljZXMgZm9yIHByb3BlcnRpZXMgdGhhdCB3ZXJlIGV4cG9zZWQgYnkgZGVmYXVsdFxuLy8gb24gd2luc3RvbiA8IDMuMC5cbndhcm4uZGVwcmVjYXRlZChleHBvcnRzLCAnc2V0TGV2ZWxzJyk7XG53YXJuLmZvckZ1bmN0aW9ucyhleHBvcnRzLCAndXNlRm9ybWF0JywgWydjbGknXSk7XG53YXJuLmZvclByb3BlcnRpZXMoZXhwb3J0cywgJ3VzZUZvcm1hdCcsIFsncGFkTGV2ZWxzJywgJ3N0cmlwQ29sb3JzJ10pO1xud2Fybi5mb3JGdW5jdGlvbnMoZXhwb3J0cywgJ2RlcHJlY2F0ZWQnLCBbXG4gICdhZGRSZXdyaXRlcicsXG4gICdhZGRGaWx0ZXInLFxuICAnY2xvbmUnLFxuICAnZXh0ZW5kJ1xuXSk7XG53YXJuLmZvclByb3BlcnRpZXMoZXhwb3J0cywgJ2RlcHJlY2F0ZWQnLCBbJ2VtaXRFcnJzJywgJ2xldmVsTGVuZ3RoJ10pO1xuXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0TG9nZ2VyID0gdm9pZCAwO1xuY29uc3Qgd2luc3RvbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwid2luc3RvblwiKSk7XG5jb25zdCBub2RlX3V0aWxfMSA9IHJlcXVpcmUoXCJub2RlOnV0aWxcIik7XG5jb25zdCBsZXZlbCA9IHByb2Nlc3MuZW52Lk5WSU1fTk9ERV9MT0dfTEVWRUwgfHwgJ2RlYnVnJztcbmZ1bmN0aW9uIGdldEZvcm1hdChjb2xvcml6ZSkge1xuICAgIHJldHVybiB3aW5zdG9uLmZvcm1hdC5jb21iaW5lKHdpbnN0b24uZm9ybWF0LnNwbGF0KCksIHdpbnN0b24uZm9ybWF0LnRpbWVzdGFtcCh7XG4gICAgICAgIGZvcm1hdDogJ1lZWVktTU0tREQgSEg6bW06c3MnLFxuICAgIH0pLCB3aW5zdG9uLmZvcm1hdC5wcmludGYoaW5mbyA9PiB7XG4gICAgICAgIGxldCBtc2c7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtc2cgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBpbmZvLm1lc3NhZ2UgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgID8gKDAsIG5vZGVfdXRpbF8xLmluc3BlY3QpKGluZm8ubWVzc2FnZSwgZmFsc2UsIDIsIGNvbG9yaXplKVxuICAgICAgICAgICAgICAgICAgICA6IGluZm8ubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIG1zZyA9IGluZm8ubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsdmwgPSBpbmZvLmxldmVsID09PSAnZGVidWcnID8gJ0RCRycgOiBpbmZvLmxldmVsLnNsaWNlKDAsIDMpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBgJHtpbmZvLnRpbWVzdGFtcH0gJHtsdmx9ICR7bXNnfWA7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gc2V0dXBXaW5zdG9uTG9nZ2VyKCkge1xuICAgIGNvbnN0IGxvZ2dlciA9IHdpbnN0b24uY3JlYXRlTG9nZ2VyKHtcbiAgICAgICAgbGV2ZWwsXG4gICAgfSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5WSU1fTk9ERV9MT0dfRklMRSkge1xuICAgICAgICBsb2dnZXIuYWRkKG5ldyB3aW5zdG9uLnRyYW5zcG9ydHMuRmlsZSh7XG4gICAgICAgICAgICBmaWxlbmFtZTogcHJvY2Vzcy5lbnYuTlZJTV9OT0RFX0xPR19GSUxFLFxuICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICBmb3JtYXQ6IGdldEZvcm1hdChmYWxzZSksXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52LkFMTE9XX0NPTlNPTEUpIHtcbiAgICAgICAgbG9nZ2VyLmFkZChuZXcgd2luc3Rvbi50cmFuc3BvcnRzLkNvbnNvbGUoe1xuICAgICAgICAgICAgZm9ybWF0OiBnZXRGb3JtYXQodHJ1ZSksXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKCFwcm9jZXNzLmVudi5OVklNX05PREVfTE9HX0ZJTEUgJiYgIXByb2Nlc3MuZW52LkFMTE9XX0NPTlNPTEUpIHtcbiAgICAgICAgLy8gU2lsZW50IGxvZ2dlciBpcyBuZWNlc3NhcnkgdG8gYXZvaWQgJ0F0dGVtcHQgdG8gd3JpdGUgbG9ncyB3aXRoIG5vIHRyYW5zcG9ydHMnIGVycm9yXG4gICAgICAgIGxvZ2dlci5hZGQobmV3IHdpbnN0b24udHJhbnNwb3J0cy5Db25zb2xlKHsgc2lsZW50OiB0cnVlIH0pKTtcbiAgICB9XG4gICAgLy8gTW9ua2V5LXBhdGNoIGBjb25zb2xlYCBzbyB0aGF0IGl0IGRvZXMgbm90IHdyaXRlIHRvIHRoZSBSUEMgKHN0ZGlvKSBjaGFubmVsLlxuICAgIE9iamVjdC5rZXlzKGNvbnNvbGUpLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgY29uc29sZVtrXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgICAgICAgIGxvZ2dlcltrID09PSAnbG9nJyA/ICdpbmZvJyA6IGtdLmFwcGx5KGxvZ2dlciwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gbG9nZ2VyO1xufVxubGV0IF9sb2dnZXI7IC8vIHNpbmdsZXRvblxuZnVuY3Rpb24gZ2V0TG9nZ2VyKCkge1xuICAgIGlmICghX2xvZ2dlcikge1xuICAgICAgICBfbG9nZ2VyID0gc2V0dXBXaW5zdG9uTG9nZ2VyKCk7XG4gICAgfVxuICAgIHJldHVybiBfbG9nZ2VyO1xufVxuZXhwb3J0cy5nZXRMb2dnZXIgPSBnZXRMb2dnZXI7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZUFwaSA9IHZvaWQgMDtcbmNvbnN0IG5vZGVfZXZlbnRzXzEgPSByZXF1aXJlKFwibm9kZTpldmVudHNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvdXRpbFwiKTtcbmNvbnN0IGxvZ2dlcl8xID0gcmVxdWlyZShcIi4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IERPX1JFUVVFU1QgPSBTeW1ib2woJ0RPX1JFUVVFU1QnKTtcbi8vIFRPRE86XG4vLyBBUElzIHRoYXQgc2hvdWxkIG5vdCBiZSBhbGxvd2VkIHRvIGJlIGNhbGxlZCBkaXJlY3RseVxuLy8gYXR0YWNoL2RldGFjaCBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGUgQVBJIGNsaWVudCBpbnN0ZWFkIG9mIHRoZVxuLy8gdXNlciBkaXJlY3RseS5cbi8vXG4vLyBpLmUuIGEgcGx1Z2luIHRoYXQgZGV0YWNoZXMgd2lsbCBhZmZlY3QgYWxsIHBsdWdpbnMgcmVnaXN0ZXJlZCBvbiBob3N0XG4vLyBjb25zdCBFWENMVURFRCA9IFsnbnZpbV9idWZfYXR0YWNoJywgJ252aW1fYnVmX2RldGFjaCddO1xuLy8gSW5zdGVhZCBvZiBkZWFsaW5nIHdpdGggbXVsdGlwbGUgaW5oZXJpdGFuY2UgKG9yIGxhY2tvZiksIGp1c3QgZXh0ZW5kIEV2ZW50RW1pdHRlclxuLy8gT25seSB0aGUgTmVvdmltIEFQSSBjbGFzcyBzaG91bGQgdXNlIEV2ZW50RW1pdHRlciB0aG91Z2hcbmNsYXNzIEJhc2VBcGkgZXh0ZW5kcyBub2RlX2V2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoeyB0cmFuc3BvcnQsIGRhdGEsIGxvZ2dlciwgbWV0YWRhdGEsIGNsaWVudCwgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzW19hXSA9IChuYW1lLCBhcmdzID0gW10pID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnJlcXVlc3QobmFtZSwgYXJncywgKGVyciwgcmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9nZ2VyLmxldmVsID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIG5vaXN5IGxvZ2dpbmcgb2YgZW50aXJlIEJ1ZmZlci9XaW5kb3cvVGFicGFnZS5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGxvZ0RhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dEYXRhID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoMCwgdXRpbF8xLnBhcnRpYWxDbG9uZSkocmVzLCAyLCBbJ2xvZ2dlcicsICd0cmFuc3BvcnQnLCAnY2xpZW50J10sICdbT2JqZWN0XScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRGF0YSA9IFN0cmluZyhyZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKGByZXNwb25zZSAtPiAke25hbWV9OiAlT2AsIGxvZ0RhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYCR7bmFtZX06ICR7ZXJyWzFdfWApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyIHx8ICgwLCBsb2dnZXJfMS5nZXRMb2dnZXIpKCk7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWV0YWRhdGEnLCB7IHZhbHVlOiBtZXRhZGF0YSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRUcmFuc3BvcnQodHJhbnNwb3J0KSB7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodGhpcy5kYXRhKSA9PT0gU3RyaW5nKG90aGVyLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmNSZXF1ZXN0KG5hbWUsIGFyZ3MgPSBbXSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gYHRoaXMuX2lzUmVhZHlgIGlzIHVuZGVmaW5lZCBpbiBFeHRUeXBlIGNsYXNzZXMgKGkuZS4gQnVmZmVyLCBXaW5kb3csIFRhYnBhZ2UpXG4gICAgICAgICAgICAvLyBCdXQgdGhpcyBpcyBqdXN0IGZvciBOZW92aW0gQVBJLCBzaW5jZSBpdCdzIHBvc3NpYmxlIHRvIGNhbGwgdGhpcyBtZXRob2QgZnJvbSBOZW92aW0gY2xhc3NcbiAgICAgICAgICAgIC8vIGJlZm9yZSB0cmFuc3BvcnQgaXMgcmVhZHkuXG4gICAgICAgICAgICAvLyBOb3QgcG9zc2libGUgZm9yIEV4dFR5cGUgY2xhc3NlcyBzaW5jZSB0aGV5IGFyZSBvbmx5IGNyZWF0ZWQgYWZ0ZXIgdHJhbnNwb3J0IGlzIHJlYWR5XG4gICAgICAgICAgICB5aWVsZCB0aGlzLl9pc1JlYWR5O1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYHJlcXVlc3QgIC0+ICR7bmFtZX1gKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0RPX1JFUVVFU1RdKG5hbWUsIGFyZ3MpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgLy8gWFhYOiBHZXQgYSBgKi50cyBzdGFja3RyYWNlLiBJZiB3ZSByZS10aHJvdyBgZXJyYCB3ZSBnZXQgYSBgKi5qc2AgdHJhY2UuIHRzY29uZmlnIGlzc3VlP1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Vycm9yID0gbmV3IEVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihgZmFpbGVkIHJlcXVlc3QgdG8gXCIlc1wiOiAlczogJXNgLCBuYW1lLCBuZXdFcnJvci5uYW1lLCBuZXdFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXdFcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWVzdChuYW1lLCBhcmdzID0gW10pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmNSZXF1ZXN0KG5hbWUsIGFyZ3MpO1xuICAgIH1cbiAgICBfZ2V0QXJnc0J5UHJlZml4KC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgX2FyZ3MgPSBbXTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgY2xhc3MgaXMgTmVvdmltIGFuZCBpZiBzbywgc2hvdWxkIG5vdCBzZW5kIGB0aGlzYCBhcyBmaXJzdCBhcmdcbiAgICAgICAgaWYgKHRoaXMucHJlZml4ICE9PSAnbnZpbV8nKSB7XG4gICAgICAgICAgICBfYXJncy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfYXJncy5jb25jYXQoYXJncyk7XG4gICAgfVxuICAgIC8qKiBSZXRyaWV2ZXMgYSBzY29wZWQgdmFyaWFibGUgZGVwZW5kaW5nIG9uIHR5cGUgKHVzaW5nIGB0aGlzLnByZWZpeGApICovXG4gICAgZ2V0VmFyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9nZXRBcmdzQnlQcmVmaXgobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWdldF92YXJgLCBhcmdzKS50aGVuKHJlcyA9PiByZXMsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnbm90IGZvdW5kJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIFNldCBhIHNjb3BlZCB2YXJpYWJsZSAqL1xuICAgIHNldFZhcihuYW1lLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5fZ2V0QXJnc0J5UHJlZml4KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1zZXRfdmFyYCwgYXJncyk7XG4gICAgfVxuICAgIC8qKiBEZWxldGUgYSBzY29wZWQgdmFyaWFibGUgKi9cbiAgICBkZWxldGVWYXIobmFtZSkge1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5fZ2V0QXJnc0J5UHJlZml4KG5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWRlbF92YXJgLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqIFJldHJpZXZlcyBhIHNjb3BlZCBvcHRpb24gZGVwZW5kaW5nIG9uIHR5cGUgb2YgYHRoaXNgICovXG4gICAgZ2V0T3B0aW9uKG5hbWUpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2dldEFyZ3NCeVByZWZpeChuYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1nZXRfb3B0aW9uYCwgYXJncyk7XG4gICAgfVxuICAgIC8qKiBTZXQgc2NvcGVkIG9wdGlvbiAqL1xuICAgIHNldE9wdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5fZ2V0QXJnc0J5UHJlZml4KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1zZXRfb3B0aW9uYCwgYXJncyk7XG4gICAgfVxuICAgIC8vIFRPRE86IElzIHRoaXMgbmVjZXNzYXJ5P1xuICAgIC8qKiBgcmVxdWVzdGAgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGV4Y2VwdCB5b3UgY2FuIGNob29zZSB0byB3YWl0IGZvcnByb21pc2UgdG8gYmUgcmVzb2x2ZWQgKi9cbiAgICBub3RpZnkobmFtZSwgYXJncykge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1Zyhgbm90aWZ5IC0+ICR7bmFtZX1gKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQubm90aWZ5KG5hbWUsIGFyZ3MpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUFwaSA9IEJhc2VBcGk7XG5fYSA9IERPX1JFUVVFU1Q7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfYSwgX2I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJ1ZmZlciA9IGV4cG9ydHMuQVRUQUNIID0gZXhwb3J0cy5ERVRBQ0ggPSB2b2lkIDA7XG5jb25zdCBCYXNlXzEgPSByZXF1aXJlKFwiLi9CYXNlXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuZXhwb3J0cy5ERVRBQ0ggPSBTeW1ib2woJ2RldGFjaEJ1ZmZlcicpO1xuZXhwb3J0cy5BVFRBQ0ggPSBTeW1ib2woJ2F0dGFjaEJ1ZmZlcicpO1xuY2xhc3MgQnVmZmVyIGV4dGVuZHMgQmFzZV8xLkJhc2VBcGkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHR5cGVzXzEuTWV0YWRhdGFbdHlwZXNfMS5FeHRUeXBlLkJ1ZmZlcl0ucHJlZml4O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXR0YWNoIHRvIGJ1ZmZlciB0byBsaXN0ZW4gdG8gYnVmZmVyIGV2ZW50c1xuICAgICAgICAgKiBAcGFyYW0gc2VuZEJ1ZmZlciBTZXQgdG8gdHJ1ZSBpZiB0aGUgaW5pdGlhbCBub3RpZmljYXRpb24gc2hvdWxkIGNvbnRhaW5cbiAgICAgICAgICogICAgICAgIHRoZSB3aG9sZSBidWZmZXIuIElmIHNvLCB0aGUgZmlyc3Qgbm90aWZpY2F0aW9uIHdpbGwgYmUgYVxuICAgICAgICAgKiAgICAgICAgYG52aW1fYnVmX2xpbmVzX2V2ZW50YC4gT3RoZXJ3aXNlLCB0aGUgZmlyc3Qgbm90aWZpY2F0aW9uIHdpbGwgYmVcbiAgICAgICAgICogICAgICAgIGEgYG52aW1fYnVmX2NoYW5nZWR0aWNrX2V2ZW50YFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpc1tfYV0gPSAoc2VuZEJ1ZmZlciA9IGZhbHNlLCBvcHRpb25zID0ge30pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudC5pc0F0dGFjaGVkKHRoaXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1hdHRhY2hgLCBbdGhpcywgc2VuZEJ1ZmZlciwgb3B0aW9uc10pO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGFjaCBmcm9tIGJ1ZmZlciB0byBzdG9wIGxpc3RlbmluZyB0byBidWZmZXIgZXZlbnRzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzW19iXSA9ICgpID0+IHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1kZXRhY2hgLCBbdGhpc10pO1xuICAgIH1cbiAgICBnZXQgaXNBdHRhY2hlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmlzQXR0YWNoZWQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnVmbnIgb2YgQnVmZmVyXG4gICAgICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH1cbiAgICAvKiogVG90YWwgbnVtYmVyIG9mIGxpbmVzIGluIGJ1ZmZlciAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9bGluZV9jb3VudGAsIFt0aGlzXSk7XG4gICAgfVxuICAgIC8qKiBHZXQgbGluZXMgaW4gYnVmZmVyICovXG4gICAgZ2V0IGxpbmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lcygpO1xuICAgIH1cbiAgICAvKiogR2V0cyBhIGNoYW5nZWQgdGljayBvZiBhIGJ1ZmZlciAqL1xuICAgIGdldCBjaGFuZ2VkdGljaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1nZXRfY2hhbmdlZHRpY2tgLCBbdGhpc10pO1xuICAgIH1cbiAgICBnZXQgY29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbW1hbmRzKCk7XG4gICAgfVxuICAgIGdldENvbW1hbmRzKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWdldF9jb21tYW5kc2AsIFt0aGlzLCBvcHRpb25zXSk7XG4gICAgfVxuICAgIC8qKiBHZXQgc3BlY2lmaWMgbGluZXMgb2YgYnVmZmVyICovXG4gICAgZ2V0TGluZXMoeyBzdGFydCwgZW5kLCBzdHJpY3RJbmRleGluZyB9ID0geyBzdGFydDogMCwgZW5kOiAtMSwgc3RyaWN0SW5kZXhpbmc6IHRydWUgfSkge1xuICAgICAgICBjb25zdCBpbmRleGluZyA9IHR5cGVvZiBzdHJpY3RJbmRleGluZyA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogc3RyaWN0SW5kZXhpbmc7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Z2V0X2xpbmVzYCwgW1xuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgaW5kZXhpbmcsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKiogU2V0IGxpbmVzIG9mIGJ1ZmZlciBnaXZlbiBpbmRlY2VzICovXG4gICAgc2V0TGluZXMoX2xpbmVzLCB7IHN0YXJ0OiBfc3RhcnQsIGVuZDogX2VuZCwgc3RyaWN0SW5kZXhpbmcgfSA9IHtcbiAgICAgICAgc3RyaWN0SW5kZXhpbmc6IHRydWUsXG4gICAgfSkge1xuICAgICAgICAvLyBUT0RPOiBFcnJvciBjaGVja2luZ1xuICAgICAgICAvLyBpZiAodHlwZW9mIHN0YXJ0ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyB9XG4gICAgICAgIGNvbnN0IGluZGV4aW5nID0gdHlwZW9mIHN0cmljdEluZGV4aW5nID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBzdHJpY3RJbmRleGluZztcbiAgICAgICAgY29uc3QgbGluZXMgPSB0eXBlb2YgX2xpbmVzID09PSAnc3RyaW5nJyA/IFtfbGluZXNdIDogX2xpbmVzO1xuICAgICAgICBjb25zdCBlbmQgPSB0eXBlb2YgX2VuZCAhPT0gJ3VuZGVmaW5lZCcgPyBfZW5kIDogX3N0YXJ0ICsgMTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1zZXRfbGluZXNgLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgX3N0YXJ0LFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgaW5kZXhpbmcsXG4gICAgICAgICAgICBsaW5lcyxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKiBJbnNlcnQgbGluZXMgYXQgYHN0YXJ0YCBpbmRleCAqL1xuICAgIGluc2VydChsaW5lcywgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGluZXMobGluZXMsIHtcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydCxcbiAgICAgICAgICAgIHN0cmljdEluZGV4aW5nOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIFJlcGxhY2UgbGluZXMgc3RhcnRpbmcgYXQgYHN0YXJ0YCBpbmRleCAqL1xuICAgIHJlcGxhY2UoX2xpbmVzLCBzdGFydCkge1xuICAgICAgICBjb25zdCBsaW5lcyA9IHR5cGVvZiBfbGluZXMgPT09ICdzdHJpbmcnID8gW19saW5lc10gOiBfbGluZXM7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbmVzKGxpbmVzLCB7XG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnQgKyBsaW5lcy5sZW5ndGgsXG4gICAgICAgICAgICBzdHJpY3RJbmRleGluZzogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogUmVtb3ZlIGxpbmVzIGF0IGluZGV4ICovXG4gICAgcmVtb3ZlKHN0YXJ0LCBlbmQsIHN0cmljdEluZGV4aW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbmVzKFtdLCB7IHN0YXJ0LCBlbmQsIHN0cmljdEluZGV4aW5nIH0pO1xuICAgIH1cbiAgICAvKiogQXBwZW5kIGEgc3RyaW5nIG9yIGxpc3Qgb2YgbGluZXMgdG8gZW5kIG9mIGJ1ZmZlciAqL1xuICAgIGFwcGVuZChsaW5lcykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW5lcyhsaW5lcywge1xuICAgICAgICAgICAgc3RhcnQ6IC0xLFxuICAgICAgICAgICAgZW5kOiAtMSxcbiAgICAgICAgICAgIHN0cmljdEluZGV4aW5nOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBHZXQgYnVmZmVyIG5hbWUgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1nZXRfbmFtZWAsIFt0aGlzXSk7XG4gICAgfVxuICAgIC8qKiBTZXQgY3VycmVudCBidWZmZXIgbmFtZSAqL1xuICAgIHNldCBuYW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1zZXRfbmFtZWAsIFt0aGlzLCB2YWx1ZV0pO1xuICAgIH1cbiAgICAvKiogSXMgY3VycmVudCBidWZmZXIgdmFsaWQgKi9cbiAgICBnZXQgdmFsaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9aXNfdmFsaWRgLCBbdGhpc10pO1xuICAgIH1cbiAgICAvKiogR2V0IG1hcmsgcG9zaXRpb24gZ2l2ZW4gbWFyayBuYW1lICovXG4gICAgbWFyayhuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Z2V0X21hcmtgLCBbdGhpcywgbmFtZV0pO1xuICAgIH1cbiAgICAvLyByYW5nZShzdGFydCwgZW5kKSB7XG4gICAgLy8gXCJcIlwiUmV0dXJuIGEgYFJhbmdlYCBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgcGFydCBvZiB0aGUgQnVmZmVyLlwiXCJcIlxuICAgIC8vIHJldHVybiBSYW5nZSh0aGlzLCBzdGFydCwgZW5kKVxuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBidWZmZXItbG9jYWwgfG1hcHBpbmd8IGRlZmluaXRpb25zLlxuICAgICAqL1xuICAgIGdldEtleW1hcChtb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Z2V0X2tleW1hcGAsIFt0aGlzLCBtb2RlXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGJ1ZmZlciBpcyB2YWxpZCBhbmQgbG9hZGVkLiBTZWUgfGFwaS1idWZmZXJ8IGZvclxuICAgICAqIG1vcmUgaW5mbyBhYm91dCB1bmxvYWRlZCBidWZmZXJzLlxuICAgICAqL1xuICAgIGdldCBsb2FkZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9aXNfbG9hZGVkYCwgW3RoaXNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYnl0ZSBvZmZzZXQgZm9yIGEgbGluZS5cbiAgICAgKlxuICAgICAqIExpbmUgMSAoaW5kZXg9MCkgaGFzIG9mZnNldCAwLiBVVEYtOCBieXRlcyBhcmUgY291bnRlZC4gRU9MIGlzXG4gICAgICogb25lIGJ5dGUuICdmaWxlZm9ybWF0JyBhbmQgJ2ZpbGVlbmNvZGluZycgYXJlIGlnbm9yZWQuIFRoZVxuICAgICAqIGxpbmUgaW5kZXgganVzdCBhZnRlciB0aGUgbGFzdCBsaW5lIGdpdmVzIHRoZSB0b3RhbCBieXRlLWNvdW50XG4gICAgICogb2YgdGhlIGJ1ZmZlci4gQSBmaW5hbCBFT0wgYnl0ZSBpcyBjb3VudGVkIGlmIGl0IHdvdWxkIGJlXG4gICAgICogd3JpdHRlbiwgc2VlICdlb2wnLlxuICAgICAqXG4gICAgICogVW5saWtlIHxsaW5lMmJ5dGUoKXwsIHRocm93cyBlcnJvciBmb3Igb3V0LW9mLWJvdW5kcyBpbmRleGluZy5cbiAgICAgKiBSZXR1cm5zIC0xIGZvciB1bmxvYWRlZCBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEludGVnZXIgYnl0ZSBvZmZzZXQsIG9yIC0xIGZvciB1bmxvYWRlZCBidWZmZXIuXG4gICAgICovXG4gICAgZ2V0T2Zmc2V0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Z2V0X29mZnNldGAsIFt0aGlzLCBpbmRleF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgaGlnaGxpZ2h0IHRvIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIFVzZWZ1bCBmb3IgcGx1Z2lucyB0aGF0IGR5bmFtaWNhbGx5IGdlbmVyYXRlIGhpZ2hsaWdodHMgdG8gYVxuICAgICAqIGJ1ZmZlciAobGlrZSBhIHNlbWFudGljIGhpZ2hsaWdodGVyIG9yIGxpbnRlcikuIFRoZSBmdW5jdGlvblxuICAgICAqIGFkZHMgYSBzaW5nbGUgaGlnaGxpZ2h0IHRvIGEgYnVmZmVyLiBVbmxpa2UgfG1hdGNoYWRkcG9zKCl8XG4gICAgICogaGlnaGxpZ2h0cyBmb2xsb3cgY2hhbmdlcyB0byBsaW5lIG51bWJlcmluZyAoYXMgbGluZXMgYXJlXG4gICAgICogaW5zZXJ0ZWQvcmVtb3ZlZCBhYm92ZSB0aGUgaGlnaGxpZ2h0ZWQgbGluZSksIGxpa2Ugc2lnbnMgYW5kXG4gICAgICogbWFya3MgZG8uXG4gICAgICpcbiAgICAgKiBOYW1lc3BhY2VzIGFyZSB1c2VkIGZvciBiYXRjaCBkZWxldGlvbi91cGRhdGluZyBvZiBhIHNldCBvZlxuICAgICAqIGhpZ2hsaWdodHMuIFRvIGNyZWF0ZSBhIG5hbWVzcGFjZSwgdXNlIHxudmltX2NyZWF0ZV9uYW1lc3BhY2V8XG4gICAgICogd2hpY2ggcmV0dXJucyBhIG5hbWVzcGFjZSBpZC4gUGFzcyBpdCBpbiB0byB0aGlzIGZ1bmN0aW9uIGFzXG4gICAgICogYG5zX2lkYCB0byBhZGQgaGlnaGxpZ2h0cyB0byB0aGUgbmFtZXNwYWNlLiBBbGwgaGlnaGxpZ2h0cyBpblxuICAgICAqIHRoZSBzYW1lIG5hbWVzcGFjZSBjYW4gdGhlbiBiZSBjbGVhcmVkIHdpdGggc2luZ2xlIGNhbGwgdG9cbiAgICAgKiB8bnZpbV9idWZfY2xlYXJfbmFtZXNwYWNlfC4gSWYgdGhlIGhpZ2hsaWdodCBuZXZlciB3aWxsIGJlXG4gICAgICogZGVsZXRlZCBieSBhbiBBUEkgY2FsbCwgcGFzcyBgbnNfaWQgPSAtMWAuXG4gICAgICpcbiAgICAgKiBBcyBhIHNob3J0aGFuZCwgYG5zX2lkID0gMGAgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgbmV3XG4gICAgICogbmFtZXNwYWNlIGZvciB0aGUgaGlnaGxpZ2h0LCB0aGUgYWxsb2NhdGVkIGlkIGlzIHRoZW5cbiAgICAgKiByZXR1cm5lZC4gSWYgYGhsX2dyb3VwYCBpcyB0aGUgZW1wdHkgc3RyaW5nIG5vIGhpZ2hsaWdodCBpc1xuICAgICAqIGFkZGVkLCBidXQgYSBuZXcgYG5zX2lkYCBpcyBzdGlsbCByZXR1cm5lZC4gVGhpcyBpcyBzdXBwb3J0ZWRcbiAgICAgKiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIG5ldyBjb2RlIHNob3VsZCB1c2VcbiAgICAgKiB8bnZpbV9jcmVhdGVfbmFtZXNwYWNlfCB0byBjcmVhdGUgYSBuZXcgZW1wdHkgbmFtZXNwYWNlLlxuICAgICAqL1xuICAgIGFkZEhpZ2hsaWdodCh7IGhsR3JvdXA6IF9obEdyb3VwLCBsaW5lLCBjb2xTdGFydDogX3N0YXJ0LCBjb2xFbmQ6IF9lbmQsIHNyY0lkOiBfc3JjSWQsIH0pIHtcbiAgICAgICAgY29uc3QgaGxHcm91cCA9IHR5cGVvZiBfaGxHcm91cCAhPT0gJ3VuZGVmaW5lZCcgPyBfaGxHcm91cCA6ICcnO1xuICAgICAgICBjb25zdCBjb2xFbmQgPSB0eXBlb2YgX2VuZCAhPT0gJ3VuZGVmaW5lZCcgPyBfZW5kIDogLTE7XG4gICAgICAgIGNvbnN0IGNvbFN0YXJ0ID0gdHlwZW9mIF9zdGFydCAhPT0gJ3VuZGVmaW5lZCcgPyBfc3RhcnQgOiAtMDtcbiAgICAgICAgY29uc3Qgc3JjSWQgPSB0eXBlb2YgX3NyY0lkICE9PSAndW5kZWZpbmVkJyA/IF9zcmNJZCA6IC0xO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWFkZF9oaWdobGlnaHRgLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgc3JjSWQsXG4gICAgICAgICAgICBobEdyb3VwLFxuICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgIGNvbFN0YXJ0LFxuICAgICAgICAgICAgY29sRW5kLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGNsZWFySGlnaGxpZ2h0KGFyZ3MgPSB7fSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oJ2BjbGVhckhpZ2hsaWdodGAgaXMgZGVwcmVjYXRlZCwgdXNlIGBgY2xlYXJOYW1lc3BhY2UoKWAgaW5zdGVhZCcpO1xuICAgICAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIHNyY0lkOiAtMSxcbiAgICAgICAgICAgIGxpbmVTdGFydDogMCxcbiAgICAgICAgICAgIGxpbmVFbmQ6IC0xLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IHNyY0lkLCBsaW5lU3RhcnQsIGxpbmVFbmQgfSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMpLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1jbGVhcl9oaWdobGlnaHRgLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgc3JjSWQsXG4gICAgICAgICAgICBsaW5lU3RhcnQsXG4gICAgICAgICAgICBsaW5lRW5kLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIG5hbWVzcGFjZWQgb2JqZWN0cywgaGlnaGxpZ2h0cyBhbmQgdmlydHVhbCB0ZXh0LCBmcm9tIGEgbGluZSByYW5nZVxuICAgICAqXG4gICAgICogVG8gY2xlYXIgdGhlIG5hbWVzcGFjZSBpbiB0aGUgZW50aXJlIGJ1ZmZlciwgcGFzcyBpbiAwIGFuZCAtMSB0byBsaW5lX3N0YXJ0IGFuZCBsaW5lX2VuZCByZXNwZWN0aXZlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbnNJZCBOYW1lc3BhY2UgdG8gY2xlYXIsIG9yIC0xIHRvIGNsZWFyIGFsbCBuYW1lc3BhY2VzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVTdGFydCBTdGFydCBvZiByYW5nZSBvZiBsaW5lcyB0byBjbGVhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lRW5kIEVuZCBvZiByYW5nZSBvZiBsaW5lcyB0byBjbGVhciAoZXhjbHVzaXZlKSBvciAtMSB0byBjbGVhciB0byBlbmQgb2YgYnVmZmVyXG4gICAgICovXG4gICAgY2xlYXJOYW1lc3BhY2UoYXJncykge1xuICAgICAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIG5zSWQ6IC0xLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiAwLFxuICAgICAgICAgICAgbGluZUVuZDogLTEsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgbnNJZCwgbGluZVN0YXJ0LCBsaW5lRW5kIH0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzKSwgYXJncyk7XG4gICAgICAgIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1jbGVhcl9uYW1lc3BhY2VgLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgbnNJZCxcbiAgICAgICAgICAgIGxpbmVTdGFydCxcbiAgICAgICAgICAgIGxpbmVFbmQsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZpcnR1YWwgdGV4dCAoYW5ub3RhdGlvbikgZm9yIGEgYnVmZmVyIGxpbmUuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0IChhbmQgY3VycmVudGx5IHRoZSBvbmx5IG9wdGlvbikgdGhlIHRleHQgd2lsbCBiZVxuICAgICAqIHBsYWNlZCBhZnRlciB0aGUgYnVmZmVyIHRleHQuIFZpcnR1YWwgdGV4dCB3aWxsIG5ldmVyIGNhdXNlXG4gICAgICogcmVmbG93LCByYXRoZXIgdmlydHVhbCB0ZXh0IHdpbGwgYmUgdHJ1bmNhdGVkIGF0IHRoZSBlbmQgb2ZcbiAgICAgKiB0aGUgc2NyZWVuIGxpbmUuIFRoZSB2aXJ0dWFsIHRleHQgd2lsbCBiZWdpbiBvbmUgY2VsbFxuICAgICAqICh8bGNzLWVvbHwgb3Igc3BhY2UpIGFmdGVyIHRoZSBvcmRpbmFyeSB0ZXh0LlxuICAgICAqXG4gICAgICogTmFtZXNwYWNlcyBhcmUgdXNlZCB0byBzdXBwb3J0IGJhdGNoIGRlbGV0aW9uL3VwZGF0aW5nIG9mXG4gICAgICogdmlydHVhbCB0ZXh0LiBUbyBjcmVhdGUgYSBuYW1lc3BhY2UsIHVzZVxuICAgICAqIHxudmltX2NyZWF0ZV9uYW1lc3BhY2V8LiBWaXJ0dWFsIHRleHQgaXMgY2xlYXJlZCB1c2luZ1xuICAgICAqIHxudmltX2J1Zl9jbGVhcl9uYW1lc3BhY2V8LiBUaGUgc2FtZSBgbnNfaWRgIGNhbiBiZSB1c2VkIGZvclxuICAgICAqIGJvdGggdmlydHVhbCB0ZXh0IGFuZCBoaWdobGlnaHRzIGFkZGVkIGJ5XG4gICAgICogfG52aW1fYnVmX2FkZF9oaWdobGlnaHR8LCBib3RoIGNhbiB0aGVuIGJlIGNsZWFyZWQgd2l0aCBhXG4gICAgICogc2luZ2xlIGNhbGwgdG8gfG52aW1fYnVmX2NsZWFyX25hbWVzcGFjZXwuIElmIHRoZSB2aXJ0dWFsIHRleHRcbiAgICAgKiBuZXZlciB3aWxsIGJlIGNsZWFyZWQgYnkgYW4gQVBJIGNhbGwsIHBhc3MgYG5zX2lkID0gLTFgLlxuICAgICAqXG4gICAgICogQXMgYSBzaG9ydGhhbmQsIGBuc19pZCA9IDBgIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIG5ld1xuICAgICAqIG5hbWVzcGFjZSBmb3IgdGhlIHZpcnR1YWwgdGV4dCwgdGhlIGFsbG9jYXRlZCBpZCBpcyB0aGVuXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbnNJZCBOYW1lc3BhY2UgdG8gdXNlIG9yIDAgdG8gY3JlYXRlIGEgbmFtZXNwYWNlLCBvciAtMSBmb3IgYSB1bmdyb3VwZWQgYW5ub3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lIExpbmUgdG8gYW5ub3RhdGUgd2l0aCB2aXJ0dWFsIHRleHQgKHplcm8taW5kZXhlZClcbiAgICAgKiBAcGFyYW0ge1ZpcnR1YWxUZXh0Q2h1bmtbXX0gY2h1bmtzICBBIGxpc3Qgb2YgW3RleHQsIGhsX2dyb3VwXSBhcnJheXMsIGVhY2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwcmVzZW50aW5nIGEgdGV4dCBjaHVuayB3aXRoIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQuIGBobF9ncm91cGAgZWxlbWVudCBjYW4gYmUgb21pdHRlZCBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm8gaGlnaGxpZ2h0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIHBhcmFtZXRlcnMuIEN1cnJlbnRseSBub3QgdXNlZC5cbiAgICAgKi9cbiAgICBzZXRWaXJ0dWFsVGV4dChuc0lkLCBsaW5lLCBjaHVua3MsIG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fXNldF92aXJ0dWFsX3RleHRgLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgbnNJZCxcbiAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICBjaHVua3MsXG4gICAgICAgICAgICBvcHRzLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdGVucyB0byBidWZmZXIgZm9yIGV2ZW50c1xuICAgICAqL1xuICAgIGxpc3RlbihldmVudE5hbWUsIGNiKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICB0aGlzW2V4cG9ydHMuQVRUQUNIXSgpLnRoZW4oYXR0YWNoZWQgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghYXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmxpc3RlbihldmVudE5hbWUsIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaWVudC5hdHRhY2hCdWZmZXIodGhpcywgZXZlbnROYW1lLCBjYik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVubGlzdGVuKGV2ZW50TmFtZSwgY2IpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB1bmxpc3RlbihldmVudE5hbWUsIGNiKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzaG91bGREZXRhY2ggPSB0aGlzLmNsaWVudC5kZXRhY2hCdWZmZXIodGhpcywgZXZlbnROYW1lLCBjYik7XG4gICAgICAgIGlmICghc2hvdWxkRGV0YWNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzW2V4cG9ydHMuREVUQUNIXSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyO1xuX2EgPSBleHBvcnRzLkFUVEFDSCwgX2IgPSBleHBvcnRzLkRFVEFDSDtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQ2hhaW5hYmxlQXBpID0gdm9pZCAwO1xuY29uc3QgQmFzZV8xID0gcmVxdWlyZShcIi4uL0Jhc2VcIik7XG5jb25zdCBiYXNlUHJvcGVydGllcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKEJhc2VfMS5CYXNlQXBpLnByb3RvdHlwZSk7XG5mdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVBcGkobmFtZSwgVHlwZSwgcmVxdWVzdFByb21pc2UsIGNoYWluQ2FsbFByb21pc2UpIHtcbiAgICAvLyByZS11c2UgY3VycmVudCBwcm9taXNlIGlmIG5vdCByZXNvbHZlZCB5ZXRcbiAgICBpZiAodGhpc1tgJHtuYW1lfVByb21pc2VgXSAmJlxuICAgICAgICB0aGlzW2Ake25hbWV9UHJvbWlzZWBdLnN0YXR1cyA9PT0gMCAmJlxuICAgICAgICB0aGlzW2Ake25hbWV9UHJveHlgXSkge1xuICAgICAgICByZXR1cm4gdGhpc1tgJHtuYW1lfVByb3h5YF07XG4gICAgfVxuICAgIHRoaXNbYCR7bmFtZX1Qcm9taXNlYF0gPSByZXF1ZXN0UHJvbWlzZSgpO1xuICAgIC8vIFRPRE86IE9wdGltaXplIHRoaXNcbiAgICAvLyBEZWZpbmUgcHJvcGVydGllcyBvbiB0aGUgcHJvbWlzZSBmb3IgZGV2dG9vbHNcbiAgICBbLi4uYmFzZVByb3BlcnRpZXMsIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFR5cGUucHJvdG90eXBlKV0uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpc1tgJHtuYW1lfVByb21pc2VgXSwga2V5LCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHByb3h5SGFuZGxlciA9IHtcbiAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAvLyBYWFggd2hpY2ggdGFrZXMgcHJpb3JpdHk/XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBwcm9wZXJ0eSBpcyBwcm9wZXJ0eSBvZiBhbiBBUEkgb2JqZWN0IChXaW5kb3csIEJ1ZmZlciwgVGFicGFnZSwgZXRjKVxuICAgICAgICAgICAgLy8gSWYgaXQgaXMsIHRoZW4gd2UgcmV0dXJuIGEgcHJvbWlzZSBvZiByZXN1bHRzIG9mIHRoZSBjYWxsIG9uIHRoYXQgQVBJIG9iamVjdFxuICAgICAgICAgICAgLy8gaS5lLiBhd2FpdCB0aGlzLmJ1ZmZlci5uYW1lIHdpbGwgcmV0dXJuIGEgcHJvbWlzZSBvZiBidWZmZXIgbmFtZVxuICAgICAgICAgICAgY29uc3QgaXNPblByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChUeXBlLnByb3RvdHlwZSwgcHJvcCkgfHxcbiAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQmFzZV8xLkJhc2VBcGkucHJvdG90eXBlLCBwcm9wKTtcbiAgICAgICAgICAgIC8vIEluc3BlY3QgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gc2VlIGlmIGl0IGlzIGEgZ2V0dGVyIG9yIHNldHRlclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdoZW4gd2UgY2hlY2sgaWYgcHJvcGVydHkgaXMgYSBtZXRob2QsIGl0IHdpbGwgY2FsbCB0aGUgZ2V0dGVyXG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihUeXBlLnByb3RvdHlwZSwgcHJvcCkgfHxcbiAgICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEJhc2VfMS5CYXNlQXBpLnByb3RvdHlwZSwgcHJvcCk7XG4gICAgICAgICAgICBjb25zdCBpc0dldHRlciA9IGRlc2NyaXB0b3IgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIGRlc2NyaXB0b3IuZ2V0ICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZGVzY3JpcHRvci5zZXQgIT09ICd1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIC8vIFhYWDogdGhlIHByb21pc2UgY2FuIHBvdGVudGlhbGx5IGJlIHN0YWxlXG4gICAgICAgICAgICAvLyBDaGVjayBpZiByZXNvbHZlZCwgZWxzZSBkbyBhIHJlZnJlc2ggcmVxdWVzdCBmb3IgY3VycmVudCBidWZmZXI/XG4gICAgICAgICAgICBpZiAoVHlwZSAmJiBpc09uUHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT25Qcm90b3R5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzR2V0dGVyICYmXG4gICAgICAgICAgICAgICAgICAgICgocHJvcCBpbiBUeXBlLnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIFR5cGUucHJvdG90eXBlW3Byb3BdID09PSAnZnVuY3Rpb24nKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHByb3AgaW4gQmFzZV8xLkJhc2VBcGkucHJvdG90eXBlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIEJhc2VfMS5CYXNlQXBpLnByb3RvdHlwZVtwcm9wXSA9PT0gJ2Z1bmN0aW9uJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHByb3BlcnR5IGlzIGEgbWV0aG9kIG9uIFR5cGUsIHdlIG5lZWQgdG8gaW52b2tlIGl0IHdpdGggY2FwdHVyZWQgYXJnc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHRoaXNbYCR7bmFtZX1Qcm9taXNlYF0udGhlbigocmVzKSA9PiByZXNbcHJvcF0uY2FsbChyZXMsIC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHJldHVybiB0aGUgcHJvcGVydHkgcmVxdWVzdGVkIGFmdGVyIHByb21pc2UgaXMgcmVzb2x2ZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gKChjaGFpbkNhbGxQcm9taXNlICYmIGNoYWluQ2FsbFByb21pc2UoKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tgJHtuYW1lfVByb21pc2VgXS50aGVuKChyZXMpID0+IHJlc1twcm9wXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yd2FyZCByZXN0IG9mIHJlcXVlc3RzIHRvIFByb21pc2VcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtwcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdLmJpbmQodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6ICh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIgJiYgKHJlY2VpdmVyIGluc3RhbmNlb2YgUHJvbWlzZSB8fCAndGhlbicgaW4gcmVjZWl2ZXIpKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIudGhlbihvYmogPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFpbnRhaW4gZGVmYXVsdCBhc3NpZ25tZW50IGJlaGF2aW9yXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8vIFByb3h5IHRoZSBwcm9taXNlIHNvIHRoYXQgd2UgY2FuIGNoZWNrIGZvciBjaGFpbmVkIEFQSSBjYWxsc1xuICAgIHRoaXNbYCR7bmFtZX1Qcm94eWBdID0gbmV3IFByb3h5KHRoaXNbYCR7bmFtZX1Qcm9taXNlYF0sIHByb3h5SGFuZGxlcik7XG4gICAgcmV0dXJuIHRoaXNbYCR7bmFtZX1Qcm94eWBdO1xufVxuZXhwb3J0cy5jcmVhdGVDaGFpbmFibGVBcGkgPSBjcmVhdGVDaGFpbmFibGVBcGk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRhYnBhZ2UgPSB2b2lkIDA7XG5jb25zdCBCYXNlXzEgPSByZXF1aXJlKFwiLi9CYXNlXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgY3JlYXRlQ2hhaW5hYmxlQXBpXzEgPSByZXF1aXJlKFwiLi91dGlscy9jcmVhdGVDaGFpbmFibGVBcGlcIik7XG5jb25zdCBXaW5kb3dfMSA9IHJlcXVpcmUoXCIuL1dpbmRvd1wiKTtcbmNsYXNzIFRhYnBhZ2UgZXh0ZW5kcyBCYXNlXzEuQmFzZUFwaSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucHJlZml4ID0gdHlwZXNfMS5NZXRhZGF0YVt0eXBlc18xLkV4dFR5cGUuVGFicGFnZV0ucHJlZml4O1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhbGwgd2luZG93cyBvZiB0YWJwYWdlICovXG4gICAgZ2V0IHdpbmRvd3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9bGlzdF93aW5zYCwgW3RoaXNdKTtcbiAgICB9XG4gICAgLyoqIEdldHMgdGhlIGN1cnJlbnQgd2luZG93IG9mIHRhYnBhZ2UgKi9cbiAgICBnZXQgd2luZG93KCkge1xuICAgICAgICAvLyBSZXF1aXJlIGlzIGhlcmUgb3RoZXJ3aXNlIHdlIGdldCBjaXJjdWxhciByZWZzXG4gICAgICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVBcGlfMS5jcmVhdGVDaGFpbmFibGVBcGkuY2FsbCh0aGlzLCAnV2luZG93JywgV2luZG93XzEuV2luZG93LCAoKSA9PiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Z2V0X3dpbmAsIFt0aGlzXSkpO1xuICAgIH1cbiAgICAvKiogSXMgY3VycmVudCB0YWJwYWdlIHZhbGlkICovXG4gICAgZ2V0IHZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWlzX3ZhbGlkYCwgW3RoaXNdKTtcbiAgICB9XG4gICAgLyoqIFRhYnBhZ2UgbnVtYmVyICovXG4gICAgZ2V0IG51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1nZXRfbnVtYmVyYCwgW3RoaXNdKTtcbiAgICB9XG4gICAgLyoqIEludmFsaWQgKi9cbiAgICBnZXRPcHRpb24oKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdUYWJwYWdlIGRvZXMgbm90IGhhdmUgYGdldE9wdGlvbmAnKTtcbiAgICB9XG4gICAgLyoqIEludmFsaWQgKi9cbiAgICBzZXRPcHRpb24oKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdUYWJwYWdlIGRvZXMgbm90IGhhdmUgYHNldE9wdGlvbmAnKTtcbiAgICB9XG59XG5leHBvcnRzLlRhYnBhZ2UgPSBUYWJwYWdlO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XaW5kb3cgPSB2b2lkIDA7XG5jb25zdCBCYXNlXzEgPSByZXF1aXJlKFwiLi9CYXNlXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgY3JlYXRlQ2hhaW5hYmxlQXBpXzEgPSByZXF1aXJlKFwiLi91dGlscy9jcmVhdGVDaGFpbmFibGVBcGlcIik7XG5jb25zdCBUYWJwYWdlXzEgPSByZXF1aXJlKFwiLi9UYWJwYWdlXCIpO1xuY29uc3QgQnVmZmVyXzEgPSByZXF1aXJlKFwiLi9CdWZmZXJcIik7XG5jbGFzcyBXaW5kb3cgZXh0ZW5kcyBCYXNlXzEuQmFzZUFwaSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucHJlZml4ID0gdHlwZXNfMS5NZXRhZGF0YVt0eXBlc18xLkV4dFR5cGUuV2luZG93XS5wcmVmaXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB3aW5kb3dpZCB0aGF0IG5vdCBjaGFuZ2Ugd2l0aGluIGEgVmltIHNlc3Npb25cbiAgICAgKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfVxuICAgIC8qKiBHZXQgY3VycmVudCBidWZmZXIgb2Ygd2luZG93ICovXG4gICAgZ2V0IGJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZUFwaV8xLmNyZWF0ZUNoYWluYWJsZUFwaS5jYWxsKHRoaXMsICdCdWZmZXInLCBCdWZmZXJfMS5CdWZmZXIsICgpID0+IHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1nZXRfYnVmYCwgW3RoaXNdKSk7XG4gICAgfVxuICAgIC8qKiBHZXQgdGhlIFRhYnBhZ2UgdGhhdCBjb250YWlucyB0aGUgd2luZG93ICovXG4gICAgZ2V0IHRhYnBhZ2UoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVBcGlfMS5jcmVhdGVDaGFpbmFibGVBcGkuY2FsbCh0aGlzLCAnVGFicGFnZScsIFRhYnBhZ2VfMS5UYWJwYWdlLCAoKSA9PiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Z2V0X3RhYnBhZ2VgLCBbdGhpc10pKTtcbiAgICB9XG4gICAgLyoqIEdldCBjdXJzb3IgcG9zaXRpb24gKi9cbiAgICBnZXQgY3Vyc29yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWdldF9jdXJzb3JgLCBbdGhpc10pO1xuICAgIH1cbiAgICAvKiogU2V0IGN1cnNvciBwb3NpdGlvbiAqL1xuICAgIHNldCBjdXJzb3IocG9zKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1zZXRfY3Vyc29yYCwgW3RoaXMsIHBvc10pO1xuICAgIH1cbiAgICAvKiogR2V0IHdpbmRvdyBoZWlnaHQgYnkgbnVtYmVyIG9mIHJvd3MgKi9cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWdldF9oZWlnaHRgLCBbdGhpc10pO1xuICAgIH1cbiAgICAvKiogU2V0IHdpbmRvdyBoZWlnaHQgYnkgbnVtYmVyIG9mIHJvd3MgKi9cbiAgICBzZXQgaGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9c2V0X2hlaWdodGAsIFt0aGlzLCBoZWlnaHRdKTtcbiAgICB9XG4gICAgLyoqIEdldCB3aW5kb3cgd2lkdGggYnkgbnVtYmVyIG9mIGNvbHVtbnMgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Z2V0X3dpZHRoYCwgW3RoaXNdKTtcbiAgICB9XG4gICAgLyoqIFNldCB3aW5kb3cgd2lkdGggYnkgbnVtYmVyIG9mIGNvbHVtbnMgICovXG4gICAgc2V0IHdpZHRoKHdpZHRoKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1zZXRfd2lkdGhgLCBbdGhpcywgd2lkdGhdKTtcbiAgICB9XG4gICAgLyoqIEdldCB3aW5kb3cgcG9zaXRpb24gKi9cbiAgICBnZXQgcG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Z2V0X3Bvc2l0aW9uYCwgW3RoaXNdKTtcbiAgICB9XG4gICAgLyoqIDAtaW5kZXhlZCwgb24tc2NyZWVuIHdpbmRvdyBwb3NpdGlvbihyb3cpIGluIGRpc3BsYXkgY2VsbHMuICovXG4gICAgZ2V0IHJvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1nZXRfcG9zaXRpb25gLCBbdGhpc10pLnRoZW4ocG9zaXRpb24gPT4gcG9zaXRpb25bMF0pO1xuICAgIH1cbiAgICAvKiogMC1pbmRleGVkLCBvbi1zY3JlZW4gd2luZG93IHBvc2l0aW9uKGNvbCkgaW4gZGlzcGxheSBjZWxscy4gKi9cbiAgICBnZXQgY29sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWdldF9wb3NpdGlvbmAsIFt0aGlzXSkudGhlbihwb3NpdGlvbiA9PiBwb3NpdGlvblsxXSk7XG4gICAgfVxuICAgIC8qKiBJcyB3aW5kb3cgdmFsaWQgKi9cbiAgICBnZXQgdmFsaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9aXNfdmFsaWRgLCBbdGhpc10pO1xuICAgIH1cbiAgICAvKiogR2V0IHdpbmRvdyBudW1iZXIgKi9cbiAgICBnZXQgbnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWdldF9udW1iZXJgLCBbdGhpc10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgd2luZG93XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIEZvcmNlIGNsb3NlIHdpbmRvd1xuICAgICAqL1xuICAgIGNsb3NlKGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1jbG9zZWAsIFt0aGlzLCBmb3JjZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgd2luZG93IHBvc2l0aW9uLiBDdXJyZW50bHkgdGhpcyBpcyBvbmx5IHVzZWQgdG9cbiAgICAgKiBjb25maWd1cmUgZmxvYXRpbmcgYW5kIGV4dGVybmFsIHdpbmRvd3MgKGluY2x1ZGluZyBjaGFuZ2luZyBhXG4gICAgICogc3BsaXQgd2luZG93IHRvIHRoZXNlIHR5cGVzKS5cbiAgICAgKlxuICAgICAqIFNlZSBkb2N1bWVudGF0aW9uIGF0IHxudmltX29wZW5fd2luKCl8LCBmb3IgdGhlIG1lYW5pbmcgb2ZcbiAgICAgKiBwYXJhbWV0ZXJzLiBQYXNzIGluIC0xIGZvciAnd2l0ZGgnIGFuZCAnaGVpZ2h0JyB0byBrZWVwXG4gICAgICogZXhpdGluZyBzaXplLlxuICAgICAqXG4gICAgICogV2hlbiByZWNvbmZpZ3VyaW5nIGEgZmxvYXRpbmcgd2luZG93LCBhYnNlbnQgb3B0aW9uIGtleXMgd2lsbFxuICAgICAqIG5vdCBiZSBjaGFuZ2VkLiBUaGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uIGFwcGx5OiBgcm93YCwgYGNvbGBcbiAgICAgKiBhbmQgYHJlbGF0aXZlYCBtdXN0IGJlIHJlY29uZmlndXJlZCB0b2dldGhlci4gT25seSBjaGFuZ2luZyBhXG4gICAgICogc3Vic2V0IG9mIHRoZXNlIGlzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXaW5kb3d9ICB3aW5kb3cgV2luZG93IGhhbmRsZVxuICAgICAqIEBQYXJhbSB7T2JqZWN0fSAgb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGNvbmZpZyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1zZXRfY29uZmlnYCwgW3RoaXMsIG9wdGlvbnNdKTtcbiAgICB9XG59XG5leHBvcnRzLldpbmRvdyA9IFdpbmRvdztcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWV0YWRhdGEgPSBleHBvcnRzLkV4dFR5cGUgPSB2b2lkIDA7XG5jb25zdCBCdWZmZXJfMSA9IHJlcXVpcmUoXCIuL0J1ZmZlclwiKTtcbmNvbnN0IFdpbmRvd18xID0gcmVxdWlyZShcIi4vV2luZG93XCIpO1xuY29uc3QgVGFicGFnZV8xID0gcmVxdWlyZShcIi4vVGFicGFnZVwiKTtcbnZhciBFeHRUeXBlO1xuKGZ1bmN0aW9uIChFeHRUeXBlKSB7XG4gICAgRXh0VHlwZVtFeHRUeXBlW1wiQnVmZmVyXCJdID0gMF0gPSBcIkJ1ZmZlclwiO1xuICAgIEV4dFR5cGVbRXh0VHlwZVtcIldpbmRvd1wiXSA9IDFdID0gXCJXaW5kb3dcIjtcbiAgICBFeHRUeXBlW0V4dFR5cGVbXCJUYWJwYWdlXCJdID0gMl0gPSBcIlRhYnBhZ2VcIjtcbn0pKEV4dFR5cGUgfHwgKGV4cG9ydHMuRXh0VHlwZSA9IEV4dFR5cGUgPSB7fSkpO1xuZXhwb3J0cy5NZXRhZGF0YSA9IFtcbiAgICB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBCdWZmZXJfMS5CdWZmZXIsXG4gICAgICAgIG5hbWU6ICdCdWZmZXInLFxuICAgICAgICBwcmVmaXg6ICdudmltX2J1Zl8nLFxuICAgIH0sXG4gICAge1xuICAgICAgICBjb25zdHJ1Y3RvcjogV2luZG93XzEuV2luZG93LFxuICAgICAgICBuYW1lOiAnV2luZG93JyxcbiAgICAgICAgcHJlZml4OiAnbnZpbV93aW5fJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgY29uc3RydWN0b3I6IFRhYnBhZ2VfMS5UYWJwYWdlLFxuICAgICAgICBuYW1lOiAnVGFicGFnZScsXG4gICAgICAgIHByZWZpeDogJ252aW1fdGFicGFnZV8nLFxuICAgIH0sXG5dO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBTb21lIGNvZGUgYm9ycm93ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdGFycnVkYS9ub2RlLW1zZ3BhY2s1cnBjXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNwb3J0ID0gdm9pZCAwO1xuY29uc3Qgbm9kZV9ldmVudHNfMSA9IHJlcXVpcmUoXCJub2RlOmV2ZW50c1wiKTtcbmNvbnN0IG1zZ3BhY2tfMSA9IHJlcXVpcmUoXCJAbXNncGFjay9tc2dwYWNrXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi9hcGkvdHlwZXNcIik7XG5jbGFzcyBSZXNwb25zZSB7XG4gICAgY29uc3RydWN0b3IoZW5jb2RlciwgcmVxdWVzdElkKSB7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IGVuY29kZXI7XG4gICAgICAgIHRoaXMucmVxdWVzdElkID0gcmVxdWVzdElkO1xuICAgIH1cbiAgICBzZW5kKHJlc3AsIGlzRXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXNwb25zZSB0byBpZCAke3RoaXMucmVxdWVzdElkfSBhbHJlYWR5IHNlbnRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGVkID0gKDAsIG1zZ3BhY2tfMS5lbmNvZGUpKFtcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RJZCxcbiAgICAgICAgICAgIGlzRXJyb3IgPyByZXNwIDogbnVsbCxcbiAgICAgICAgICAgICFpc0Vycm9yID8gcmVzcCA6IG51bGwsXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmVuY29kZXIud3JpdGUoQnVmZmVyLmZyb20oZW5jb2RlZC5idWZmZXIsIGVuY29kZWQuYnl0ZU9mZnNldCwgZW5jb2RlZC5ieXRlTGVuZ3RoKSk7XG4gICAgICAgIHRoaXMuc2VudCA9IHRydWU7XG4gICAgfVxufVxuY2xhc3MgVHJhbnNwb3J0IGV4dGVuZHMgbm9kZV9ldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubmV4dFJlcXVlc3RJZCA9IDE7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uQ29kZWMgPSB0aGlzLmluaXRpYWxpemVFeHRlbnNpb25Db2RlYygpO1xuICAgIH1cbiAgICBpbml0aWFsaXplRXh0ZW5zaW9uQ29kZWMoKSB7XG4gICAgICAgIGNvbnN0IGNvZGVjID0gbmV3IG1zZ3BhY2tfMS5FeHRlbnNpb25Db2RlYygpO1xuICAgICAgICB0eXBlc18xLk1ldGFkYXRhLmZvckVhY2goKHsgY29uc3RydWN0b3IgfSwgaWQpID0+IHtcbiAgICAgICAgICAgIGNvZGVjLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBpZCxcbiAgICAgICAgICAgICAgICBlbmNvZGU6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBtc2dwYWNrXzEuZW5jb2RlKShpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlY29kZTogZGF0YSA9PiBuZXcgY29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6ICgwLCBtc2dwYWNrXzEuZGVjb2RlKShkYXRhKSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvZGVjO1xuICAgIH1cbiAgICBlbmNvZGVUb0J1ZmZlcih2YWx1ZSkge1xuICAgICAgICBjb25zdCBlbmNvZGVkID0gKDAsIG1zZ3BhY2tfMS5lbmNvZGUpKHZhbHVlLCB7IGV4dGVuc2lvbkNvZGVjOiB0aGlzLmV4dGVuc2lvbkNvZGVjIH0pO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oZW5jb2RlZC5idWZmZXIsIGVuY29kZWQuYnl0ZU9mZnNldCwgZW5jb2RlZC5ieXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgYXR0YWNoKHdyaXRlciwgcmVhZGVyLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy53cml0ZXIgPSB3cml0ZXI7XG4gICAgICAgIHRoaXMucmVhZGVyID0gcmVhZGVyO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5yZWFkZXIub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGV0YWNoJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhc3luY0RlY29kZUdlbmVyYXRvciA9ICgwLCBtc2dwYWNrXzEuZGVjb2RlTXVsdGlTdHJlYW0pKHRoaXMucmVhZGVyLCB7XG4gICAgICAgICAgICBleHRlbnNpb25Db2RlYzogdGhpcy5leHRlbnNpb25Db2RlYyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG5haXZlbHkgaXRlcmF0ZSBhc3luYyBnZW5lcmF0b3IgY3JlYXRlZCB2aWEgZGVjb2RlTXVsdGlTdHJlYW0uXG4gICAgICAgIC8vIHdoZW4gcnVudGltZSAvIHBvbHlmaWxsIGFsbG93cyByZXBsYWNlIHRvIGBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiBhc3luY0RlY29kZUdlbmVyYXRvcilgXG4gICAgICAgIC8vIHN5bnRheCBpbnN0ZWFkLlxuICAgICAgICBjb25zdCByZXNvbHZlR2VuZXJhdG9yUmVjdXJzaXZlbHkgPSAoaXRlcikgPT4ge1xuICAgICAgICAgICAgaXRlci5uZXh0KCkudGhlbihyZXNvbHZlZCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlZC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VNZXNzYWdlKHJlc29sdmVkLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVHZW5lcmF0b3JSZWN1cnNpdmVseShpdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlc29sdmVHZW5lcmF0b3JSZWN1cnNpdmVseShhc3luY0RlY29kZUdlbmVyYXRvcik7XG4gICAgfVxuICAgIHJlcXVlc3QobWV0aG9kLCBhcmdzLCBjYikge1xuICAgICAgICB0aGlzLm5leHRSZXF1ZXN0SWQgPSB0aGlzLm5leHRSZXF1ZXN0SWQgKyAxO1xuICAgICAgICB0aGlzLndyaXRlci53cml0ZSh0aGlzLmVuY29kZVRvQnVmZmVyKFswLCB0aGlzLm5leHRSZXF1ZXN0SWQsIG1ldGhvZCwgYXJnc10pKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nLnNldCh0aGlzLm5leHRSZXF1ZXN0SWQsIGNiKTtcbiAgICB9XG4gICAgbm90aWZ5KG1ldGhvZCwgYXJncykge1xuICAgICAgICB0aGlzLndyaXRlci53cml0ZSh0aGlzLmVuY29kZVRvQnVmZmVyKFsyLCBtZXRob2QsIGFyZ3NdKSk7XG4gICAgfVxuICAgIHBhcnNlTWVzc2FnZShtc2cpIHtcbiAgICAgICAgY29uc3QgbXNnVHlwZSA9IG1zZ1swXTtcbiAgICAgICAgaWYgKG1zZ1R5cGUgPT09IDApIHtcbiAgICAgICAgICAgIC8vIHJlcXVlc3RcbiAgICAgICAgICAgIC8vICAgLSBtc2dbMV06IGlkXG4gICAgICAgICAgICAvLyAgIC0gbXNnWzJdOiBtZXRob2QgbmFtZVxuICAgICAgICAgICAgLy8gICAtIG1zZ1szXTogYXJndW1lbnRzXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCBtc2dbMl0udG9TdHJpbmcoKSwgbXNnWzNdLCBuZXcgUmVzcG9uc2UodGhpcy53cml0ZXIsIG1zZ1sxXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1zZ1R5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHJlc3BvbnNlIHRvIGEgcHJldmlvdXMgcmVxdWVzdDpcbiAgICAgICAgICAgIC8vICAgLSBtc2dbMV06IHRoZSBpZFxuICAgICAgICAgICAgLy8gICAtIG1zZ1syXTogZXJyb3IoaWYgYW55KVxuICAgICAgICAgICAgLy8gICAtIG1zZ1szXTogcmVzdWx0KGlmIG5vdCBlcnJvcmVkKVxuICAgICAgICAgICAgY29uc3QgaWQgPSBtc2dbMV07XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5wZW5kaW5nLmdldChpZCk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmcuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIGhhbmRsZXIobXNnWzJdLCBtc2dbM10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1zZ1R5cGUgPT09IDIpIHtcbiAgICAgICAgICAgIC8vIG5vdGlmaWNhdGlvbi9ldmVudFxuICAgICAgICAgICAgLy8gICAtIG1zZ1sxXTogZXZlbnQgbmFtZVxuICAgICAgICAgICAgLy8gICAtIG1zZ1syXTogYXJndW1lbnRzXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ25vdGlmaWNhdGlvbicsIG1zZ1sxXS50b1N0cmluZygpLCBtc2dbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53cml0ZXIud3JpdGUodGhpcy5lbmNvZGVUb0J1ZmZlcihbMSwgMCwgJ0ludmFsaWQgbWVzc2FnZSB0eXBlJywgbnVsbF0pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVHJhbnNwb3J0ID0gVHJhbnNwb3J0O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OZW92aW0gPSB2b2lkIDA7XG5jb25zdCBCYXNlXzEgPSByZXF1aXJlKFwiLi9CYXNlXCIpO1xuY29uc3QgY3JlYXRlQ2hhaW5hYmxlQXBpXzEgPSByZXF1aXJlKFwiLi91dGlscy9jcmVhdGVDaGFpbmFibGVBcGlcIik7XG5jb25zdCBCdWZmZXJfMSA9IHJlcXVpcmUoXCIuL0J1ZmZlclwiKTtcbmNvbnN0IFRhYnBhZ2VfMSA9IHJlcXVpcmUoXCIuL1RhYnBhZ2VcIik7XG5jb25zdCBXaW5kb3dfMSA9IHJlcXVpcmUoXCIuL1dpbmRvd1wiKTtcbi8qKlxuICogTmVvdmltIEFQSVxuICovXG5jbGFzcyBOZW92aW0gZXh0ZW5kcyBCYXNlXzEuQmFzZUFwaSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucHJlZml4ID0gJ252aW1fJztcbiAgICAgICAgdGhpcy5CdWZmZXIgPSBCdWZmZXJfMS5CdWZmZXI7XG4gICAgICAgIHRoaXMuV2luZG93ID0gV2luZG93XzEuV2luZG93O1xuICAgICAgICB0aGlzLlRhYnBhZ2UgPSBUYWJwYWdlXzEuVGFicGFnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG52aW0gQVBJIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgZ2V0IGFwaUluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Z2V0X2FwaV9pbmZvYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgbGlzdCBvZiBidWZmZXIgaGFuZGxlc1xuICAgICAqXG4gICAgICogSW5jbHVkZXMgdW5saXN0ZWQgKHVubG9hZGVkL2RlbGV0ZWQpIGJ1ZmZlcnMsIGxpa2UgYGxzIWAuIFVzZSBgYnVmZmVyLmxvYWRlZGBcbiAgICAgKiB0byBjaGVjayBpZiBhIGJ1ZmZlciBpcyBsb2FkZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0J1ZmZlcltdfSBMaXN0IG9mIGJ1ZmZlciBoYW5kbGVzXG4gICAgICovXG4gICAgZ2V0IGJ1ZmZlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9bGlzdF9idWZzYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9IEJ1ZmZlciBoYW5kbGVcbiAgICAgKi9cbiAgICBnZXQgYnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlQXBpXzEuY3JlYXRlQ2hhaW5hYmxlQXBpLmNhbGwodGhpcywgJ0J1ZmZlcicsIEJ1ZmZlcl8xLkJ1ZmZlciwgKCkgPT4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWdldF9jdXJyZW50X2J1ZmApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBidWZmZXJcbiAgICAgKi9cbiAgICBzZXQgYnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9c2V0X2N1cnJlbnRfYnVmYCwgW2J1ZmZlcl0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgYWxsIG9wZW4gY2hhbm5lbHNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0NoYW5uZWxbXX0gQXJyYXkgb2YgY2hhbm5lbHNcbiAgICAgKi9cbiAgICBnZXQgY2hhbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9bGlzdF9jaGFuc2ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGluZm9ybWF0aW9uIGFib3V0IGEgY2hhbm5lbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW4gVGhlIGNoYW5uZWwgbnVtYmVyXG4gICAgICogQHJldHVybiB7Q2hhbm5lbH0gQSBjaGFubmVsXG4gICAgICovXG4gICAgZ2V0Q2hhbkluZm8oY2hhbikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWdldF9jaGFuX2luZm9gLCBbY2hhbl0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbWFwIG9mIGJ1ZmZlci1sb2NhbCB8dXNlci1jb21tYW5kc3wuXG4gICAgICovXG4gICAgZ2V0IGNvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21tYW5kcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbWFwIG9mIGJ1ZmZlci1sb2NhbCB8dXNlci1jb21tYW5kc3wuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25hbCBwYXJhbWV0ZXJzIChjdXJyZW50bHkgbm90IHVzZWQpXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBNYXAgb2YgbWFwcyBkZXNjcmliaW5nIGNvbW1hbmRzXG4gICAgICovXG4gICAgZ2V0Q29tbWFuZHMob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Z2V0X2NvbW1hbmRzYCwgW29wdGlvbnNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBsaXN0IG9mIHRhYnBhZ2UgaGFuZGxlc1xuICAgICAqXG4gICAgICogQHJldHVybiB7VGFicGFnZVtdfSBMaXN0IG9mIHRhZ3BhZ2UgaGFuZGxlc1xuICAgICAqL1xuICAgIGdldCB0YWJwYWdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1saXN0X3RhYnBhZ2VzYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHdpbmRvdyB0YWJwYWdlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtUYWJwYWdlfSBUYWdwYWdlIHRoYXQgY29udGFpbnMgdGhlIHdpbmRvd1xuICAgICAqL1xuICAgIGdldCB0YWJwYWdlKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlQXBpXzEuY3JlYXRlQ2hhaW5hYmxlQXBpLmNhbGwodGhpcywgJ1RhYnBhZ2UnLCBUYWJwYWdlXzEuVGFicGFnZSwgKCkgPT4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWdldF9jdXJyZW50X3RhYnBhZ2VgKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdGFicGFnZVxuICAgICAqL1xuICAgIHNldCB0YWJwYWdlKHRhYnBhZ2UpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fXNldF9jdXJyZW50X3RhYnBhZ2VgLCBbdGFicGFnZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGxpc3Qgb2Ygd2luZG93IGhhbmRsZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1dpbmRvd1tdfSBMaXN0IG9mIHdpbmRvdyBoYW5kbGVzXG4gICAgICovXG4gICAgZ2V0IHdpbmRvd3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdpbmRvd3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB3aW5kb3dcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1dpbmRvd30gV2luZG93IGhhbmRsZVxuICAgICAqL1xuICAgIGdldCB3aW5kb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdpbmRvdygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHdpbmRvd1xuICAgICAqXG4gICAgICogQHBhcmFtIHtXaW5kb3d9IFdpbmRvdyBoYW5kbGVcbiAgICAgKi9cbiAgICBzZXQgd2luZG93KHdpbikge1xuICAgICAgICBpZiAod2luIGluc3RhbmNlb2YgV2luZG93XzEuV2luZG93KVxuICAgICAgICAgICAgdGhpcy5zZXRXaW5kb3cod2luKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgd2luLnRoZW4od2luID0+IHRoaXMuc2V0V2luZG93KHdpbikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGxpc3Qgb2Ygd2luZG93IGhhbmRsZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1dpbmRvd1tdfSBMaXN0IG9mIHdpbmRvdyBoYW5kbGVzXG4gICAgICovXG4gICAgZ2V0V2luZG93cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1saXN0X3dpbnNgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB3aW5kb3dcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1dpbmRvd30gV2luZG93IGhhbmRsZVxuICAgICAqL1xuICAgIGdldFdpbmRvdygpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZUFwaV8xLmNyZWF0ZUNoYWluYWJsZUFwaS5jYWxsKHRoaXMsICdXaW5kb3cnLCBXaW5kb3dfMS5XaW5kb3csICgpID0+IHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1nZXRfY3VycmVudF93aW5gKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgd2luZG93XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dpbmRvd30gV2luZG93IGhhbmRsZVxuICAgICAqL1xuICAgIHNldFdpbmRvdyh3aW4pIHtcbiAgICAgICAgLy8gVGhyb3cgZXJyb3IgaWYgd2luIGlzIG5vdCBpbnN0YW5jZSBvZiBXaW5kb3c/XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9c2V0X2N1cnJlbnRfd2luYCwgW3dpbl0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwYXRocyBjb250YWluZWQgaW4gXCJydW50aW1lcGF0aFwiXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmdbXX0gTGlzdCBvZiBwYXRoc1xuICAgICAqL1xuICAgIGdldCBydW50aW1lUGF0aHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9bGlzdF9ydW50aW1lX3BhdGhzYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIGdsb2JhbCB3b3JraW5nIGRpcmVjdG9yeVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IERpcmVjdG9yeSBwYXRoXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXQgZGlyKGRpcikge1xuICAgICAgICB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9c2V0X2N1cnJlbnRfZGlyYCwgW2Rpcl0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gQ3VycmVudCBsaW5lIHN0cmluZ1xuICAgICAqL1xuICAgIGdldCBsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgY3VycmVudCBsaW5lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZSBMaW5lIGNvbnRlbnRzXG4gICAgICovXG4gICAgc2V0IGxpbmUobGluZSkge1xuICAgICAgICAvLyBEb2luZyB0aGlzIHRvIHNhdGlzZnkgVFMgcmVxdWlyZW1lbnQgdGhhdCBnZXQvc2V0dGVycyBoYXZlIHRvIGJlIHNhbWUgdHlwZVxuICAgICAgICBpZiAodHlwZW9mIGxpbmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLnNldExpbmUobGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBsaW5lXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEN1cnJlbnQgbGluZSBzdHJpbmdcbiAgICAgKi9cbiAgICBnZXRMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWdldF9jdXJyZW50X2xpbmVgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBjdXJyZW50IGxpbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lIExpbmUgY29udGVudHNcbiAgICAgKi9cbiAgICBzZXRMaW5lKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1zZXRfY3VycmVudF9saW5lYCwgW2xpbmVdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgZ2xvYmFsIChub24tYnVmZmVyLWxvY2FsKSB8bWFwcGluZ3wgZGVmaW5pdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kZSBNb2RlIHNob3J0LW5hbWUgKFwiblwiLCBcImlcIiwgXCJ2XCIsIC4uLilcbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gIEFycmF5IG9mIG1hcGFyZygpLWxpa2UgZGljdGlvbmFyaWVzIGRlc2NyaWJpbmcgbWFwcGluZ3MuIFRoZSBcImJ1ZmZlclwiIGtleSBpcyBhbHdheXMgemVyby5cbiAgICAgKi9cbiAgICBnZXRLZXltYXAobW9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWdldF9rZXltYXBgLCBbbW9kZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IG1vZGUuIHxtb2RlKCl8IFwiYmxvY2tpbmdcIiBpcyB0cnVlIGlmIE52aW0gaXMgd2FpdGluZyBmb3IgaW5wdXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IERpY3Rpb25hcnkgeyBcIm1vZGVcIjogU3RyaW5nLCBcImJsb2NraW5nXCI6IEJvb2xlYW4gfVxuICAgICAqL1xuICAgIGdldCBtb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWdldF9tb2RlYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgbWFwIG9mIGRlZmluZWQgY29sb3JzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENvbG9yIG1hcFxuICAgICAqL1xuICAgIGdldCBjb2xvck1hcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1nZXRfY29sb3JfbWFwYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjb2xvciBieSBuYW1lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBDb2xvciBuYW1lXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBDb2xvciB2YWx1ZVxuICAgICAqL1xuICAgIGdldENvbG9yQnlOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1nZXRfY29sb3JfYnlfbmFtZWAsIFtuYW1lXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBoaWdobGlnaHQgYnkgbmFtZSBvciBpZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBuYW1lT3JJZCBOYW1lIG9yIElEXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc1JnYiBTaG91bGQgZXhwb3J0IFJHQiBjb2xvcnNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEhpZ2hsaWdodCBkZWZpbml0aW9uIG1hcFxuICAgICAqL1xuICAgIGdldEhpZ2hsaWdodChuYW1lT3JJZCwgaXNSZ2IgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IHR5cGVvZiBuYW1lT3JJZCA9PT0gJ3N0cmluZycgPyAnYnlfbmFtZScgOiAnYnlfaWQnO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWdldF9obF8ke2Z1bmN0aW9uTmFtZX1gLCBbXG4gICAgICAgICAgICBuYW1lT3JJZCxcbiAgICAgICAgICAgIGlzUmdiLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGhpZ2hsaWdodCBkZWZpbml0aW9uIGJ5IG5hbWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEhpZ2hsaWdodCBncm91cCBuYW1lXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc1JnYiBTaG91bGQgZXhwb3J0IFJHQiBjb2xvcnNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEhpZ2hsaWdodCBkZWZpbml0aW9uIG1hcFxuICAgICAqL1xuICAgIGdldEhpZ2hsaWdodEJ5TmFtZShuYW1lLCBpc1JnYiA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1nZXRfaGxfYnlfbmFtZWAsIFtuYW1lLCBpc1JnYl0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgaGlnaGxpZ2h0IGRlZmluaXRpb24gYnkgaWQgfGhsSUQoKXxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZCBIaWdobGlnaHQgaWQgYXMgcmV0dXJuZWQgYnkgfGhsSUQoKXxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmdiIFNob3VsZCBleHBvcnQgUkdCIGNvbG9yc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gSGlnaGxpZ2h0IGRlZmluaXRpb24gbWFwXG4gICAgICovXG4gICAgZ2V0SGlnaGxpZ2h0QnlJZChpZCwgaXNSZ2IgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Z2V0X2hsX2J5X2lkYCwgW2lkLCBpc1JnYl0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgKi9cbiAgICBkZWxldGVDdXJyZW50TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1kZWxfY3VycmVudF9saW5lYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyBhIFZpbUwgZXhwcmVzc2lvbiAoOmhlbHAgZXhwcmVzc2lvbikuIERpY3Rpb25hcmllc1xuICAgICAqIGFuZCBMaXN0cyBhcmUgcmVjdXJzaXZlbHkgZXhwYW5kZWQuIE9uIFZpbUwgZXJyb3I6IFJldHVybnMgYVxuICAgICAqIGdlbmVyaWMgZXJyb3I7IHY6ZXJybXNnIGlzIG5vdCB1cGRhdGVkLlxuICAgICAqXG4gICAgICovXG4gICAgZXZhbChleHByKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9ZXZhbGAsIFtleHByXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGx1YSwgaXQncyBwb3NzaWJsZSBuZW92aW0gY2xpZW50IGRvZXMgbm90IHN1cHBvcnQgdGhpc1xuICAgICAqL1xuICAgIGx1YShjb2RlLCBhcmdzID0gW10pIHtcbiAgICAgICAgY29uc3QgX2FyZ3MgPSBBcnJheS5pc0FycmF5KGFyZ3MpID8gYXJncyA6IFthcmdzXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1leGVjdXRlX2x1YWAsIFtjb2RlLCBfYXJnc10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3IgYGx1YSgpYCB0byBiZSBjb25zaXN0ZW50IHdpdGggbmVvdmltIEFQSVxuICAgICAqL1xuICAgIGV4ZWN1dGVMdWEoY29kZSwgYXJncyA9IFtdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmx1YShjb2RlLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgYSBWaW1MIHxEaWN0aW9uYXJ5LWZ1bmN0aW9ufCB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBPbiBleGVjdXRpb24gZXJyb3I6IGZhaWxzIHdpdGggVmltTCBlcnJvciwgZG9lcyBub3QgdXBkYXRlIHY6ZXJybXNnLlxuICAgICAqL1xuICAgIGNhbGxEaWN0RnVuY3Rpb24oZGljdCwgZm5hbWUsIGFyZ3MgPSBbXSkge1xuICAgICAgICBjb25zdCBfYXJncyA9IEFycmF5LmlzQXJyYXkoYXJncykgPyBhcmdzIDogW2FyZ3NdO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWNhbGxfZGljdF9mdW5jdGlvbmAsIFtcbiAgICAgICAgICAgIGRpY3QsXG4gICAgICAgICAgICBmbmFtZSxcbiAgICAgICAgICAgIF9hcmdzLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgYSBWaW1MIGZ1bmN0aW9uIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIE9uIGV4ZWN1dGlvbiBlcnJvcjogZmFpbHMgd2l0aCBWaW1MIGVycm9yLCBkb2VzIG5vdCB1cGRhdGUgdjplcnJtc2cuXG4gICAgICovXG4gICAgY2FsbChmbmFtZSwgYXJncyA9IFtdKSB7XG4gICAgICAgIGNvbnN0IF9hcmdzID0gQXJyYXkuaXNBcnJheShhcmdzKSA/IGFyZ3MgOiBbYXJnc107XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Y2FsbF9mdW5jdGlvbmAsIFtmbmFtZSwgX2FyZ3NdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIGBjYWxsYFxuICAgICAqL1xuICAgIGNhbGxGdW5jdGlvbihmbmFtZSwgYXJncyA9IFtdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoZm5hbWUsIGFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxscyBtYW55IEFQSSBtZXRob2RzIGF0b21pY2FsbHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGhhcyB0d28gbWFpbiB1c2FnZXM6XG4gICAgICogIC0gVG8gcGVyZm9ybSBzZXZlcmFsIHJlcXVlc3RzIGZyb20gYW4gYXN5bmMgY29udGV4dCBhdG9taWNhbGx5LCBpLmUuIHdpdGhvdXRcbiAgICAgKiBpbnRlcmxlYXZpbmcgcmVkcmF3cywgUlBDIHJlcXVlc3RzIGZyb20gb3RoZXIgY2xpZW50cywgb3IgdXNlciBpbnRlcmFjdGlvbnNcbiAgICAgKiAoaG93ZXZlciBBUEkgbWV0aG9kcyBtYXkgdHJpZ2dlciBhdXRvY29tbWFuZHMgb3IgZXZlbnQgcHJvY2Vzc2luZyB3aGljaCBoYXZlXG4gICAgICogc3VjaCBzaWRlLWVmZmVjdHMsIGUuZy4gfDpzbGVlcHwgbWF5IHdha2UgdGltZXJzKVxuICAgICAqXG4gICAgICogIC0gVG8gbWluaW1pemUgUlBDIG92ZXJoZWFkIChyb3VuZHRyaXBzKSBvZiBhIHNlcXVlbmNlIG9mIG1hbnkgcmVxdWVzdHMuXG4gICAgICovXG4gICAgY2FsbEF0b21pYyhjYWxscykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWNhbGxfYXRvbWljYCwgW2NhbGxzXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGFuIGV4LWNvbW1hbmQuXG4gICAgICpcbiAgICAgKiBPbiBleGVjdXRpb24gZXJyb3I6IGZhaWxzIHdpdGggVmltTCBlcnJvciwgZG9lcyBub3QgdXBkYXRlIHY6ZXJybXNnLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFyZyBFeC1jb21tYW5kIHN0cmluZ1xuICAgICAqL1xuICAgIGNvbW1hbmQoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Y29tbWFuZGAsIFthcmddKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYW4gZXgtY29tbWFuZCBhbmQgcmV0dXJucyBpdHMgKG5vbi1lcnJvcikgb3V0cHV0LlxuICAgICAqIFNoZWxsIHw6IXwgb3V0cHV0IGlzIG5vdCBjYXB0dXJlZC5cbiAgICAgKlxuICAgICAqIE9uIGV4ZWN1dGlvbiBlcnJvcjogZmFpbHMgd2l0aCBWaW1MIGVycm9yLCBkb2VzIG5vdCB1cGRhdGUgdjplcnJtc2cuXG4gICAgICovXG4gICAgY29tbWFuZE91dHB1dChhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1jb21tYW5kX291dHB1dGAsIFthcmddKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHY6IHZhcmlhYmxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBWYXJpYWJsZSBuYW1lXG4gICAgICogQHJldHVybiB7VmltVmFsdWV9IFZhcmlhYmxlIHZhbHVlXG4gICAgICovXG4gICAgZ2V0VnZhcihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Z2V0X3Z2YXJgLCBbbmFtZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdjogdmFyaWFibGUsIGlmIGl0IGlzIG5vdCByZWFkb25seS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFZhcmlhYmxlIG5hbWVcbiAgICAgKiBAcGFyYW0ge1ZpbVZhbHVlfSB2YWx1ZSBWYXJpYWJsZSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFZ2YXIobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1zZXRfdnZhcmAsIFtuYW1lLCB2YWx1ZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBpbnB1dC1rZXlzIHRvIE52aW0sIHN1YmplY3QgdG8gdmFyaW91cyBxdWlya3MgY29udHJvbGxlZFxuICAgICAqIGJ5IGBtb2RlYCBmbGFncy4gVGhpcyBpcyBhIGJsb2NraW5nIGNhbGwsIHVubGlrZSB8bnZpbV9pbnB1dCgpfC5cbiAgICAgKlxuICAgICAqIE9uIGV4ZWN1dGlvbiBlcnJvcjogZG9lcyBub3QgZmFpbCwgYnV0IHVwZGF0ZXMgdjplcnJtc2cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5cyBUbyBiZSB0eXBlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlIEJlaGF2aW9yIGZsYWdzLCBzZWUgfGZlZWRrZXlzKCl8XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlc2NhcGVDc2kgSWYgdHJ1ZSwgZXNjYXBlIEtfU1BFQ0lBTC9DU0kgYnl0ZXMgaW4gYGtleXNgXG4gICAgICovXG4gICAgZmVlZEtleXMoa2V5cywgbW9kZSwgZXNjYXBlQ3NpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9ZmVlZGtleXNgLCBba2V5cywgbW9kZSwgZXNjYXBlQ3NpXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXVlcyByYXcgdXNlci1pbnB1dC4gVW5saWtlIHxudmltX2ZlZWRrZXlzKCl8LCB0aGlzIHVzZXMgYVxuICAgICAqIGxvdy1sZXZlbCBpbnB1dCBidWZmZXIgYW5kIHRoZSBjYWxsIGlzIG5vbi1ibG9ja2luZyAoaW5wdXQgaXNcbiAgICAgKiBwcm9jZXNzZWQgYXN5bmNocm9ub3VzbHkgYnkgdGhlIGV2ZW50bG9vcCkuXG4gICAgICpcbiAgICAgKiBPbiBleGVjdXRpb24gZXJyb3I6IGRvZXMgbm90IGZhaWwsIGJ1dCB1cGRhdGVzIHY6ZXJybXNnLlxuICAgICAqXG4gICAgICogTm90ZTpcbiAgICAgKiB8a2V5Y29kZXN8IGxpa2UgPENSPiBhcmUgdHJhbnNsYXRlZCwgc28gXCI8XCIgaXMgc3BlY2lhbC4gVG9cbiAgICAgKiBpbnB1dCBhIGxpdGVyYWwgXCI8XCIsIHNlbmQgPExUPi5cbiAgICAgKlxuICAgICAqIE5vdGU6XG4gICAgICogRm9yIG1vdXNlIGV2ZW50cyB1c2UgfG52aW1faW5wdXRfbW91c2UoKXwuIFRoZSBwc2V1ZG9rZXlcbiAgICAgKiBmb3JtIFwiPExlZnRNb3VzZT48Y29sLHJvdz5cIiBpcyBkZXByZWNhdGVkIHNpbmNlXG4gICAgICogfGFwaS1sZXZlbHwgNi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlzIFRvIGJlIHR5cGVkXG4gICAgICovXG4gICAgaW5wdXQoa2V5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWlucHV0YCwgW2tleXNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBtb3VzZSBldmVudCBmcm9tIEdVSS5cbiAgICAgKlxuICAgICAqIFRoZSBjYWxsIGlzIG5vbi1ibG9ja2luZy4gSXQgZG9lc24ndCB3YWl0IG9uIGFueSByZXN1bHRpbmdcbiAgICAgKiBhY3Rpb24sIGJ1dCBxdWV1ZXMgdGhlIGV2ZW50IHRvIGJlIHByb2Nlc3NlZCBzb29uIGJ5IHRoZSBldmVudFxuICAgICAqIGxvb3AuXG4gICAgICpcbiAgICAgKiBOb3RlOlxuICAgICAqIEN1cnJlbnRseSB0aGlzIGRvZXNuJ3Qgc3VwcG9ydCBcInNjcmlwdGluZ1wiIG11bHRpcGxlIG1vdXNlXG4gICAgICogZXZlbnRzIGJ5IGNhbGxpbmcgaXQgbXVsdGlwbGUgdGltZXMgaW4gYSBsb29wOiB0aGVcbiAgICAgKiBpbnRlcm1lZGlhdGUgbW91c2UgcG9zaXRpb25zIHdpbGwgYmUgaWdub3JlZC4gSXQgc2hvdWxkIGJlXG4gICAgICogdXNlZCB0byBpbXBsZW1lbnQgcmVhbC10aW1lIG1vdXNlIGlucHV0IGluIGEgR1VJLiBUaGVcbiAgICAgKiBkZXByZWNhdGVkIHBzZXVkb2tleSBmb3JtIChcIjxMZWZ0TW91c2U+PGNvbCxyb3c+XCIpIG9mXG4gICAgICogfG52aW1faW5wdXQoKXwgaGFzIHRoZSBzYW1lIGxpbWl0aWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGJ1dHRvbiAgICBNb3VzZSBidXR0b246IG9uZSBvZiBcImxlZnRcIiwgXCJyaWdodFwiLCBcIm1pZGRsZVwiLCBcIndoZWVsXCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbiAgICBGb3Igb3JkaW5hcnkgYnV0dG9ucywgb25lIG9mIFwicHJlc3NcIiwgXCJkcmFnXCIsIFwicmVsZWFzZVwiLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIHRoZSB3aGVlbCwgb25lIG9mIFwidXBcIiwgXCJkb3duXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyICBTdHJpbmcgb2YgbW9kaWZpZXJzIGVhY2ggcmVwcmVzZW50ZWQgYnkgYVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luZ2xlIGNoYXIuIFRoZSBzYW1lIHNwZWNpZmllcnMgYXJlIHVzZWQgYXNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBhIGtleSBwcmVzcywgZXhjZXB0IHRoYXQgdGhlIFwiLVwiIHNlcGFyYXRvclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgb3B0aW9uYWwsIHNvIFwiQy1BLVwiLCBcImMtYVwiIGFuZCBcIkNBXCIgY2FuIGFsbFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgdXNlZCB0byBzcGVjaWZ5IEN0cmwrQWx0K2NsaWNrLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBncmlkICAgICAgR3JpZCBudW1iZXIgaWYgdGhlIGNsaWVudCB1c2VzIHx1aS1tdWx0aWdyaWR8LCBlbHNlIDAuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJvdyAgICAgICBNb3VzZSByb3ctcG9zaXRpb24gKHplcm8tYmFzZWQsIGxpa2UgcmVkcmF3IGV2ZW50cylcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29sICAgICAgIE1vdXNlIGNvbHVtbi1wb3NpdGlvbiAoemVyby1iYXNlZCwgbGlrZSByZWRyYXcgZXZlbnRzKVxuICAgICAqL1xuICAgIGlucHV0TW91c2UoYnV0dG9uLCBhY3Rpb24sIG1vZGlmaWVyLCBncmlkLCByb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWlucHV0X21vdXNlYCwgW1xuICAgICAgICAgICAgYnV0dG9uLFxuICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgbW9kaWZpZXIsXG4gICAgICAgICAgICBncmlkLFxuICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgY29sLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgYSBWaW1MIEV4cHJlc3Npb25cbiAgICAgKlxuICAgICAqIFRPRE86IHJldHVybiB0eXBlLCBzZWUgOmhlbHBcbiAgICAgKi9cbiAgICBwYXJzZUV4cHJlc3Npb24oZXhwciwgZmxhZ3MsIGhpZ2hsaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fXBhcnNlX2V4cHJlc3Npb25gLCBbXG4gICAgICAgICAgICBleHByLFxuICAgICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgICBoaWdobGlnaHQsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGluZm8gZGVzY3JpYmluZyBwcm9jZXNzIGBwaWRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBpZCBwaWRcbiAgICAgKiBAcmV0dXJuIHtQcm9jfSBNYXAgb2YgcHJvY2VzcyBwcm9wZXJ0aWVzLCBvciBudWxsIGlmIHByb2Nlc3Mgbm90IGZvdW5kXG4gICAgICovXG4gICAgZ2V0UHJvYyhwaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1nZXRfcHJvY2AsIFtwaWRdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW1tZWRpYXRlIGNoaWxkcmVuIG9mIHByb2Nlc3MgYHBpZGBcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb2NbXX0gQXJyYXkgb2YgY2hpbGQgcHJvY2VzcyBpZHMsIGVtcHR5IGlmIHByb2Nlc3Mgbm90IGZvdW5kXG4gICAgICovXG4gICAgZ2V0UHJvY0NoaWxkcmVuKHBpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWdldF9wcm9jX2NoaWxkcmVuYCwgW3BpZF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyB0ZXJtaW5hbCBjb2RlcyBhbmQgfGtleWNvZGVzfCAoPENSPiwgPEVzYz4sIC4uLikgaW4gYVxuICAgICAqIHN0cmluZyB3aXRoIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIGJlIGNvbnZlcnRlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZyb21QYXJ0IExlZ2FjeSBWaW0gcGFyYW1ldGVyLiBVc3VhbGx5IHRydWUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkb0l0IEFsc28gdHJhbnNsYXRlIDxsdD4uIElnbm9yZWQgaWYgYHNwZWNpYWxgIGlzIGZhbHNlLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3BlY2lhbCBSZXBsYWNlIHxrZXljb2Rlc3wsIGUuZy4gPENSPiBiZWNvbWVzIGEgXCJcXG5cIiBjaGFyLlxuICAgICAqL1xuICAgIHJlcGxhY2VUZXJtY29kZXMoc3RyLCBmcm9tUGFydCwgZG9JdCwgc3BlY2lhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fXJlcGxhY2VfdGVybWNvZGVzYCwgW1xuICAgICAgICAgICAgc3RyLFxuICAgICAgICAgICAgZnJvbVBhcnQsXG4gICAgICAgICAgICBkb0l0LFxuICAgICAgICAgICAgc3BlY2lhbCxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkaXNwbGF5IGNlbGxzIG9jY3VwaWVkIGJ5IGB0ZXh0YC5cbiAgICAgKiA8VGFiPiBjb3VudHMgYXMgb25lIGNlbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFNvbWUgdGV4dFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTnVtYmVyIG9mIGNlbGxzXG4gICAgICovXG4gICAgc3RyV2lkdGgoc3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9c3Ryd2lkdGhgLCBbc3RyXSk7XG4gICAgfVxuICAgIC8qKiBXcml0ZSB0byBvdXRwdXQgYnVmZmVyICovXG4gICAgb3V0V3JpdGUoc3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9b3V0X3dyaXRlYCwgW3N0cl0pO1xuICAgIH1cbiAgICBvdXRXcml0ZUxpbmUoc3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dFdyaXRlKGAke3N0cn1cXG5gKTtcbiAgICB9XG4gICAgLyoqIFdyaXRlIHRvIGVycm9yIGJ1ZmZlciAqL1xuICAgIGVycldyaXRlKHN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWVycl93cml0ZWAsIFtzdHJdKTtcbiAgICB9XG4gICAgLyoqIFdyaXRlIHRvIGVycm9yIGJ1ZmZlciAqL1xuICAgIGVycldyaXRlTGluZShzdHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH1lcnJfd3JpdGVsbmAsIFtzdHJdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgZGljdGlvbmFyaWVzIHJlcHJlc2VudGluZyBhdHRhY2hlZCBVSXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtVaVtdfSBBcnJheSBvZiBVSSBkaWN0aW9uYXJpZXNcbiAgICAgKiBFYWNoIGRpY3Rpb25hcnkgaGFzIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICAgKiBcImhlaWdodFwiIHJlcXVlc3RlZCBoZWlnaHQgb2YgdGhlIFVJXG4gICAgICogXCJ3aWR0aFwiIHJlcXVlc3RlZCB3aWR0aCBvZiB0aGUgVUlcbiAgICAgKiBcInJnYlwiIHdoZXRoZXIgdGhlIFVJIHVzZXMgcmdiIGNvbG9ycyAoZmFsc2UgaW1wbGllcyBjdGVybSBjb2xvcnMpXG4gICAgICogXCJleHRfLi4uXCIgUmVxdWVzdGVkIFVJIGV4dGVuc2lvbnMsIHNlZSB8dWktb3B0aW9uc3xcbiAgICAgKiBcImNoYW5cIiBDaGFubmVsIGlkIG9mIHJlbW90ZSBVSSAobm90IHByZXNlbnQgZm9yIFRVSSlcbiAgICAgKi9cbiAgICBnZXQgdWlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fWxpc3RfdWlzYCk7XG4gICAgfVxuICAgIHVpQXR0YWNoKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH11aV9hdHRhY2hgLCBbd2lkdGgsIGhlaWdodCwgb3B0aW9uc10pO1xuICAgIH1cbiAgICB1aURldGFjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH11aV9kZXRhY2hgLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRPRE86IERvY3VtZW50YXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgbmV3IHJlcXVlc3RlZCB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIG5ldyByZXF1ZXN0ZWQgaGVpZ2h0XG4gICAgICovXG4gICAgdWlUcnlSZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fXVpX3RyeV9yZXNpemVgLCBbd2lkdGgsIGhlaWdodF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZWxsIE52aW0gdG8gcmVzaXplIGEgZ3JpZC4gVHJpZ2dlcnMgYSBncmlkX3Jlc2l6ZSBldmVudCB3aXRoXG4gICAgICogdGhlIHJlcXVlc3RlZCBncmlkIHNpemUgb3IgdGhlIG1heGltdW0gc2l6ZSBpZiBpdCBleGNlZWRzIHNpemVcbiAgICAgKiBsaW1pdHMuXG4gICAgICpcbiAgICAgKiBPbiBpbnZhbGlkIGdyaWQgaGFuZGxlLCBmYWlscyB3aXRoIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGdyaWQgVGhlIGhhbmRsZSBvZiB0aGUgZ3JpZCB0byBiZSBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSBuZXcgcmVxdWVzdGVkIHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgbmV3IHJlcXVlc3RlZCBoZWlnaHRcbiAgICAgKi9cbiAgICB1aVRyeVJlc2l6ZUdyaWQoZ3JpZCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fXVpX3RyeV9yZXNpemVfZ3JpZGAsIFtcbiAgICAgICAgICAgIGdyaWQsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBVSSBPcHRpb25cbiAgICAgKi9cbiAgICB1aVNldE9wdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fXVpX3NldF9vcHRpb25gLCBbbmFtZSwgdmFsdWVdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIG52aW0gZXZlbnQgYnJvYWRjYXN0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IEV2ZW50IHR5cGUgc3RyaW5nXG4gICAgICovXG4gICAgc3Vic2NyaWJlKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9c3Vic2NyaWJlYCwgW2V2ZW50XSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIHRvIG52aW0gZXZlbnQgYnJvYWRjYXN0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IEV2ZW50IHR5cGUgc3RyaW5nXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChgJHt0aGlzLnByZWZpeH11bnN1YnNjcmliZWAsIFtldmVudF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZGVudGlmeSB0aGUgY2xpZW50IGZvciBudmltLiBDYW4gYmUgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLFxuICAgICAqIGJ1dCBzdWJzZXF1ZW50IGNhbGxzIHdpbGwgcmVtb3ZlIGVhcmxpZXIgaW5mbywgd2hpY2ggc2hvdWxkIGJlXG4gICAgICogcmVzZW50IGlmIGl0IGlzIHN0aWxsIHZhbGlkLiAoVGhpcyBjb3VsZCBoYXBwZW4gaWYgYSBsaWJyYXJ5XG4gICAgICogZmlyc3QgaWRlbnRpZmllcyB0aGUgY2hhbm5lbCwgYW5kIGEgcGx1Z2luIHVzaW5nIHRoYXQgbGlicmFyeVxuICAgICAqIGxhdGVyIG92ZXJyaWRlcyB0aGF0IGluZm8pXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXRDbGllbnRJbmZvKG5hbWUsIHZlcnNpb24sIHR5cGUsIG1ldGhvZHMsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fXNldF9jbGllbnRfaW5mb2AsIFtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG1ldGhvZHMsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBuYW1lc3BhY2UsIG9yIGdldHMgYW4gZXhpc3Rpbmcgb25lLlxuICAgICAqXG4gICAgICogTmFtZXNwYWNlcyBhcmUgdXNlZCBmb3IgYnVmZmVyIGhpZ2hsaWdodHMgYW5kIHZpcnR1YWwgdGV4dCxcbiAgICAgKiBzZWUgfG52aW1fYnVmX2FkZF9oaWdobGlnaHQoKXwgYW5kIHxudmltX2J1Zl9zZXRfdmlydHVhbF90ZXh0KCl8LlxuICAgICAqXG4gICAgICogTmFtZXNwYWNlcyBjYW4gYmUgbmFtZWQgb3IgYW5vbnltb3VzLiBJZiBgbmFtZWAgbWF0Y2hlcyBhblxuICAgICAqIGV4aXN0aW5nIG5hbWVzcGFjZSwgdGhlIGFzc29jaWF0ZWQgaWQgaXMgcmV0dXJuZWQuIElmIGBuYW1lYFxuICAgICAqIGlzIGFuIGVtcHR5IHN0cmluZyBhIG5ldywgYW5vbnltb3VzIG5hbWVzcGFjZSBpcyBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZXNwYWNlIG5hbWUgb3IgZW1wdHkgc3RyaW5nXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOYW1lc3BhY2UgaWRcbiAgICAgKi9cbiAgICBjcmVhdGVOYW1lc3BhY2UobmFtZSA9ICcnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Y3JlYXRlX25hbWVzcGFjZWAsIFtuYW1lXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBgZ2V0TmFtZXNwYWNlcygpYFxuICAgICAqL1xuICAgIGdldCBuYW1lc3BhY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROYW1lc3BhY2VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgZXhpc3RpbmcsIG5vbi1hbm9ueW1vdXMgbmFtZXNwYWNlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gZGljdCB0aGF0IG1hcHMgZnJvbSBuYW1lcyB0byBuYW1lc3BhY2UgaWRzLlxuICAgICAqL1xuICAgIGdldE5hbWVzcGFjZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Z2V0X25hbWVzcGFjZXNgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBhbiBpdGVtIGluIHRoZSBjb21wbGV0aW9uIHBvcHVwbWVudS5cbiAgICAgKlxuICAgICAqIElmIHxpbnMtY29tcGxldGlvbnwgaXMgbm90IGFjdGl2ZSB0aGlzIEFQSSBjYWxsIGlzIHNpbGVudGx5XG4gICAgICogaWdub3JlZC4gVXNlZnVsIGZvciBhbiBleHRlcm5hbCBVSSB1c2luZyB8dWktcG9wdXBtZW51fCB0b1xuICAgICAqIGNvbnRyb2wgdGhlIHBvcHVwbWVudSB3aXRoIHRoZSBtb3VzZS4gQ2FuIGFsc28gYmUgdXNlZCBpbiBhXG4gICAgICogbWFwcGluZzsgdXNlIDxjbWQ+IHw6bWFwLWNtZHwgdG8gZW5zdXJlIHRoZSBtYXBwaW5nIGRvZXNuJ3RcbiAgICAgKiBlbmQgY29tcGxldGlvbiBtb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9ICBpdGVtICAgICBJbmRleCAoemVyby1iYXNlZCkgb2YgdGhlIGl0ZW0gdG8gc2VsZWN0LlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgVmFsdWUgb2YgLTEgc2VsZWN0cyBub3RoaW5nIGFuZCByZXN0b3JlcyB0aGUgb3JpZ2luYWwgdGV4dC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluc2VydCAgIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW4gdGhlIGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbmlzaCAgIEZpbmlzaCB0aGUgY29tcGxldGlvbiBhbmQgZGlzbWlzcyB0aGUgcG9wdXBtZW51LlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgSW1wbGllcyBgaW5zZXJ0YC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIG9wdHMgICAgIE9wdGlvbmFsIHBhcmFtZXRlcnMuIFJlc2VydmVkIGZvciBmdXR1cmUgdXNlLlxuICAgICAqL1xuICAgIHNlbGVjdFBvcHVwbWVudUl0ZW0oaXRlbSwgaW5zZXJ0LCBmaW5pc2gsIG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGAke3RoaXMucHJlZml4fXNlbGVjdF9wb3B1cG1lbnVfaXRlbWAsIFtcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBpbnNlcnQsXG4gICAgICAgICAgICBmaW5pc2gsXG4gICAgICAgICAgICBvcHRzLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldywgZW1wdHksIHVubmFtZWQgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBsaXN0ZWQgIENvbnRyb2xzICdidWZsaXN0ZWQnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzY3JhdGNoIENyZWF0ZXMgYSBcInRocm93YXdheVwiIHxzY3JhdGNoLWJ1ZmZlcnwgZm9yIHRlbXBvcmFyeSB3b3JrIChhbHdheXMgJ25vbW9kaWZpZWQnKVxuICAgICAqIEByZXR1cm4ge0J1ZmZlcnxOdW1iZXJ9IEJ1ZmZlciBoYW5kbGUsIG9yIDAgb24gZXJyb3JcbiAgICAgKi9cbiAgICBjcmVhdGVCdWYobGlzdGVkLCBzY3JhdGNoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9Y3JlYXRlX2J1ZmAsIFtsaXN0ZWQsIHNjcmF0Y2hdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIGFsaWFzIGZvciBgY3JlYXRlQnVmYFxuICAgICAqL1xuICAgIGNyZWF0ZUJ1ZmZlcihsaXN0ZWQsIHNjcmF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQnVmKGxpc3RlZCwgc2NyYXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW4gYSBuZXcgd2luZG93LlxuICAgICAqIEN1cnJlbnRseSB0aGlzIGlzIHVzZWQgdG8gb3BlbiBmbG9hdGluZyBhbmQgZXh0ZXJuYWwgd2luZG93cy5cbiAgICAgKiBGbG9hdHMgYXJlIHdpbmRvd3MgdGhhdCBhcmUgZHJhd24gYWJvdmUgdGhlIHNwbGl0IGxheW91dCwgYXRcbiAgICAgKiBzb21lIGFuY2hvciBwb3NpdGlvbiBpbiBzb21lIG90aGVyIHdpbmRvdy4gRmxvYXRzIGNhbiBiZSBkcmF3XG4gICAgICogaW50ZXJuYWxseSBvciBieSBleHRlcm5hbCBHVUkgd2l0aCB0aGUgfHVpLW11bHRpZ3JpZHxcbiAgICAgKiBleHRlbnNpb24uIEV4dGVybmFsIHdpbmRvd3MgYXJlIG9ubHkgc3VwcG9ydGVkIHdpdGggbXVsdGlncmlkXG4gICAgICogR1VJcywgYW5kIGFyZSBkaXNwbGF5ZWQgYXMgc2VwYXJhdGUgdG9wLWxldmVsIHdpbmRvd3MuXG4gICAgICpcbiAgICAgKiBFeGFjdGx5IG9uZSBvZiBgZXh0ZXJuYWxgIGFuZCBgcmVsYXRpdmVgIG11c3QgYmUgc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9ICBidWZmZXIgSGFuZGxlIG9mIGJ1ZmZlciB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIHdpbmRvd1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW50ZXIgIFdoZXRoZXIgdGhlIHdpbmRvdyBzaG91bGQgYmUgZW50ZXJlZCAobWFkZSB0aGUgY3VycmVudCB3aW5kb3cpXG4gICAgICogQFBhcmFtIHtPYmplY3R9ICBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7V2luZG93fE51bWJlcn0gVGhlIFdpbmRvdyBoYW5kbGUgb3IgMCB3aGVuIGVycm9yXG4gICAgICovXG4gICAgb3BlbldpbihidWZmZXIsIGVudGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9b3Blbl93aW5gLCBbYnVmZmVyLCBlbnRlciwgb3B0aW9uc10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgYWxpYXMgZm9yIGBvcGVuV2luYFxuICAgICAqL1xuICAgIG9wZW5XaW5kb3coYnVmZmVyLCBlbnRlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuV2luKGJ1ZmZlciwgZW50ZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgd2luZG93IHBvc2l0aW9uLiBDdXJyZW50bHkgdGhpcyBpcyBvbmx5IHVzZWQgdG9cbiAgICAgKiBjb25maWd1cmUgZmxvYXRpbmcgYW5kIGV4dGVybmFsIHdpbmRvd3MgKGluY2x1ZGluZyBjaGFuZ2luZyBhXG4gICAgICogc3BsaXQgd2luZG93IHRvIHRoZXNlIHR5cGVzKS5cbiAgICAgKlxuICAgICAqIFNlZSBkb2N1bWVudGF0aW9uIGF0IHxudmltX29wZW5fd2luKCl8LCBmb3IgdGhlIG1lYW5pbmcgb2ZcbiAgICAgKiBwYXJhbWV0ZXJzLiBQYXNzIGluIC0xIGZvciAnd2l0ZGgnIGFuZCAnaGVpZ2h0JyB0byBrZWVwXG4gICAgICogZXhpdGluZyBzaXplLlxuICAgICAqXG4gICAgICogV2hlbiByZWNvbmZpZ3VyaW5nIGEgZmxvYXRpbmcgd2luZG93LCBhYnNlbnQgb3B0aW9uIGtleXMgd2lsbFxuICAgICAqIG5vdCBiZSBjaGFuZ2VkLiBUaGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uIGFwcGx5OiBgcm93YCwgYGNvbGBcbiAgICAgKiBhbmQgYHJlbGF0aXZlYCBtdXN0IGJlIHJlY29uZmlndXJlZCB0b2dldGhlci4gT25seSBjaGFuZ2luZyBhXG4gICAgICogc3Vic2V0IG9mIHRoZXNlIGlzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXaW5kb3d9ICB3aW5kb3cgV2luZG93IGhhbmRsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgd2lkdGggIFdpZHRoIG9mIHdpbmRvdyAoaW4gY2hhcmFjdGVyIGNlbGxzKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgaGVpZ2h0IEhlaWdodCBvZiB3aW5kb3cgKGluIGNoYXJhY3RlciBjZWxscylcbiAgICAgKiBAUGFyYW0ge09iamVjdH0gIG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICB3aW5Db25maWcod2luZG93LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5jb25maWcob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBbGlhcyBmb3IgYHdpbkNvbmZpZ2BcbiAgICAgKi9cbiAgICB3aW5kb3dDb25maWcod2luZG93LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2luQ29uZmlnKHdpbmRvdywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB3aW5kb3dcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgRm9yY2UgY2xvc2Ugd2luZG93XG4gICAgICovXG4gICAgd2luQ2xvc2Uod2luZG93LCBmb3JjZSkge1xuICAgICAgICByZXR1cm4gd2luZG93LmNsb3NlKGZvcmNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIGFsaWFzIGZvciBgd2luQ2xvc2VgXG4gICAgICovXG4gICAgd2luZG93Q2xvc2Uod2luZG93LCBmb3JjZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aW5DbG9zZSh3aW5kb3csIGZvcmNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpdCBudmltXG4gICAgICovXG4gICAgcXVpdCgpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kKCdxYSEnKTtcbiAgICB9XG59XG5leHBvcnRzLk5lb3ZpbSA9IE5lb3ZpbTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OZW92aW1DbGllbnQgPSB2b2lkIDA7XG5jb25zdCB0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuLi91dGlscy90cmFuc3BvcnRcIik7XG5jb25zdCBOZW92aW1fMSA9IHJlcXVpcmUoXCIuL05lb3ZpbVwiKTtcbmNvbnN0IFJFR0VYX0JVRl9FVkVOVCA9IC9udmltX2J1Zl8oLiopX2V2ZW50LztcbmNsYXNzIE5lb3ZpbUNsaWVudCBleHRlbmRzIE5lb3ZpbV8xLk5lb3ZpbSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIE5lb3ZpbSBoYXMgbm8gYGRhdGFgIG9yIGBtZXRhZGF0YWBcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbG9nZ2VyOiBvcHRpb25zLmxvZ2dlcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXR0YWNoZWRCdWZmZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBvcHRpb25zLnRyYW5zcG9ydCB8fCBuZXcgdHJhbnNwb3J0XzEuVHJhbnNwb3J0KCk7XG4gICAgICAgIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgIHRoaXMucmVxdWVzdFF1ZXVlID0gW107XG4gICAgICAgIHRoaXMudHJhbnNwb3J0QXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXF1ZXN0ID0gdGhpcy5oYW5kbGVSZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlTm90aWZpY2F0aW9uID0gdGhpcy5oYW5kbGVOb3RpZmljYXRpb24uYmluZCh0aGlzKTtcbiAgICB9XG4gICAgLyoqIEF0dGFjaGVzIG1zZ3BhY2sgdG8gcmVhZC93cml0ZSBzdHJlYW1zICogKi9cbiAgICBhdHRhY2goeyByZWFkZXIsIHdyaXRlciwgfSkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5hdHRhY2god3JpdGVyLCByZWFkZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydEF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXR1cFRyYW5zcG9ydCgpO1xuICAgIH1cbiAgICBnZXQgaXNBcGlSZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0QXR0YWNoZWQgJiYgdHlwZW9mIHRoaXMuX2NoYW5uZWxJZCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIGdldCBjaGFubmVsSWQoKSB7XG4gICAgICAgIHJldHVybiAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5faXNSZWFkeTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGFubmVsSWQ7XG4gICAgICAgIH0pKSgpO1xuICAgIH1cbiAgICBpc0F0dGFjaGVkKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBrZXkgPSBgJHtidWZmZXIuZGF0YX1gO1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRhY2hlZEJ1ZmZlcnMuaGFzKGtleSk7XG4gICAgfVxuICAgIGhhbmRsZVJlcXVlc3QobWV0aG9kLCBhcmdzLCByZXNwLCAuLi5yZXN0QXJncykge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdoYW5kbGVSZXF1ZXN0OiAnLCBtZXRob2QpO1xuICAgICAgICAvLyBJZiBuZW92aW0gQVBJIGlzIG5vdCBnZW5lcmF0ZWQgeWV0IGFuZCB3ZSBhcmUgbm90IGhhbmRsZSBhICdzcGVjcycgcmVxdWVzdFxuICAgICAgICAvLyB0aGVuIHF1ZXVlIHVwIHJlcXVlc3RzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE90aGVyd2lzZSBlbWl0IGFzIG5vcm1hbFxuICAgICAgICBpZiAoIXRoaXMuaXNBcGlSZWFkeSAmJiBtZXRob2QgIT09ICdzcGVjcycpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdyZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbbWV0aG9kLCBhcmdzLCByZXNwLCAuLi5yZXN0QXJnc10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVxdWVzdCcsIG1ldGhvZCwgYXJncywgcmVzcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdE5vdGlmaWNhdGlvbihtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgaWYgKG1ldGhvZC5lbmRzV2l0aCgnX2V2ZW50JykpIHtcbiAgICAgICAgICAgIGlmICghbWV0aG9kLnN0YXJ0c1dpdGgoJ252aW1fYnVmXycpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1VuaGFuZGxlZCBldmVudDogJywgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaG9ydE5hbWUgPSBtZXRob2QucmVwbGFjZShSRUdFWF9CVUZfRVZFTlQsICckMScpO1xuICAgICAgICAgICAgY29uc3QgW2J1ZmZlcl0gPSBhcmdzO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyS2V5ID0gYCR7YnVmZmVyLmRhdGF9YDtcbiAgICAgICAgICAgIGlmICghdGhpcy5hdHRhY2hlZEJ1ZmZlcnMuaGFzKGJ1ZmZlcktleSkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgcHJvYmxlbVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlck1hcCA9IHRoaXMuYXR0YWNoZWRCdWZmZXJzLmdldChidWZmZXJLZXkpO1xuICAgICAgICAgICAgY29uc3QgY2JzID0gYnVmZmVyTWFwLmdldChzaG9ydE5hbWUpIHx8IFtdO1xuICAgICAgICAgICAgY2JzLmZvckVhY2goY2IgPT4gY2IoLi4uYXJncykpO1xuICAgICAgICAgICAgLy8gSGFuZGxlIGBudmltX2J1Zl9kZXRhY2hfZXZlbnRgXG4gICAgICAgICAgICAvLyBjbGVhbiBgYXR0YWNoZWRCdWZmZXJzYCBzaW5jZSBpdCB3aWxsIG5vIGxvbmdlciBiZSBhdHRhY2hlZFxuICAgICAgICAgICAgaWYgKHNob3J0TmFtZSA9PT0gJ2RldGFjaCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaGVkQnVmZmVycy5kZWxldGUoYnVmZmVyS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnbm90aWZpY2F0aW9uJywgbWV0aG9kLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVOb3RpZmljYXRpb24obWV0aG9kLCBhcmdzLCAuLi5yZXN0QXJncykge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdoYW5kbGVOb3RpZmljYXRpb246ICcsIG1ldGhvZCk7XG4gICAgICAgIC8vIElmIG5lb3ZpbSBBUEkgaXMgbm90IGdlbmVyYXRlZCB5ZXQgdGhlbiBxdWV1ZSB1cCByZXF1ZXN0c1xuICAgICAgICAvL1xuICAgICAgICAvLyBPdGhlcndpc2UgZW1pdCBhcyBub3JtYWxcbiAgICAgICAgaWYgKCF0aGlzLmlzQXBpUmVhZHkpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdub3RpZmljYXRpb24nLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFttZXRob2QsIGFyZ3MsIC4uLnJlc3RBcmdzXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0Tm90aWZpY2F0aW9uKG1ldGhvZCwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTGlzdGVuIGFuZCBzZXR1cCBoYW5kbGVycyBmb3IgdHJhbnNwb3J0XG4gICAgc2V0dXBUcmFuc3BvcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy50cmFuc3BvcnRBdHRhY2hlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXR0YWNoZWQgdG8gaW5wdXQvb3V0cHV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc3BvcnQub24oJ3JlcXVlc3QnLCB0aGlzLmhhbmRsZVJlcXVlc3QpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbignbm90aWZpY2F0aW9uJywgdGhpcy5oYW5kbGVOb3RpZmljYXRpb24pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbignZGV0YWNoJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkaXNjb25uZWN0Jyk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlcXVlc3QnKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnbm90aWZpY2F0aW9uJyk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RldGFjaCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faXNSZWFkeSA9IHRoaXMuZ2VuZXJhdGVBcGkoKTtcbiAgICB9XG4gICAgcmVxdWVzdEFwaSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoJ252aW1fZ2V0X2FwaV9pbmZvJywgW10sIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBSZXF1ZXN0IEFQSSBmcm9tIG5lb3ZpbSBhbmQgYXVnbWVudCB0aGlzIGN1cnJlbnQgY2xhc3MgdG8gYWRkIHRoZXNlIEFQSXNcbiAgICBnZW5lcmF0ZUFwaSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHRzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0geWllbGQgdGhpcy5yZXF1ZXN0QXBpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0NvdWxkIG5vdCBnZXQgdmltIGFwaSByZXN1bHRzJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2NoYW5uZWxJZCAvKiAsIGVuY29kZWRNZXRhZGF0YSAqL10gPSByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBtZXRhZGF0YSA9IGVuY29kZWRNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5sb2dnZXIuZGVidWcoYCQkJDogJHttZXRhZGF0YX1gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBzYW5pdHkgY2hlY2sgZm9yIG1ldGFkYXRhIHR5cGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIE9iamVjdC5rZXlzKG1ldGFkYXRhLnR5cGVzKS5mb3JFYWNoKChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgbWV0YURhdGFGb3JUeXBlID0gbWV0YWRhdGEudHlwZXNbbmFtZV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGNoZWNrIGBwcmVmaXhgIGFuZCBgaWRgXG4gICAgICAgICAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFubmVsSWQgPSBjaGFubmVsSWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBub24tcXVldWVpbmcgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVxdWV1ZSBhbnkgcGVuZGluZyBSUENzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLmZvckVhY2gocGVuZGluZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVuZGluZy50eXBlID09PSAnbm90aWZpY2F0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdE5vdGlmaWNhdGlvbihwZW5kaW5nLmFyZ3NbMF0sIHBlbmRpbmcuYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQocGVuZGluZy50eXBlLCAuLi5wZW5kaW5nLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoYENvdWxkIG5vdCBkeW5hbWljYWxseSBnZW5lcmF0ZSBuZW92aW0gQVBJOiAke2Vycn1gLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyLnN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhdHRhY2hCdWZmZXIoYnVmZmVyLCBldmVudE5hbWUsIGNiKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcktleSA9IGAke2J1ZmZlci5kYXRhfWA7XG4gICAgICAgIGlmICghdGhpcy5hdHRhY2hlZEJ1ZmZlcnMuaGFzKGJ1ZmZlcktleSkpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoZWRCdWZmZXJzLnNldChidWZmZXJLZXksIG5ldyBNYXAoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyTWFwID0gdGhpcy5hdHRhY2hlZEJ1ZmZlcnMuZ2V0KGJ1ZmZlcktleSk7XG4gICAgICAgIGlmICghYnVmZmVyTWFwLmdldChldmVudE5hbWUpKSB7XG4gICAgICAgICAgICBidWZmZXJNYXAuc2V0KGV2ZW50TmFtZSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNicyA9IGJ1ZmZlck1hcC5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgaWYgKGNicy5pbmNsdWRlcyhjYikpXG4gICAgICAgICAgICByZXR1cm4gY2I7XG4gICAgICAgIGNicy5wdXNoKGNiKTtcbiAgICAgICAgYnVmZmVyTWFwLnNldChldmVudE5hbWUsIGNicyk7XG4gICAgICAgIHRoaXMuYXR0YWNoZWRCdWZmZXJzLnNldChidWZmZXJLZXksIGJ1ZmZlck1hcCk7XG4gICAgICAgIHJldHVybiBjYjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgYnVmZmVyIHNob3VsZCBiZSBkZXRhY2hlZFxuICAgICAqL1xuICAgIGRldGFjaEJ1ZmZlcihidWZmZXIsIGV2ZW50TmFtZSwgY2IpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyS2V5ID0gYCR7YnVmZmVyLmRhdGF9YDtcbiAgICAgICAgY29uc3QgYnVmZmVyTWFwID0gdGhpcy5hdHRhY2hlZEJ1ZmZlcnMuZ2V0KGJ1ZmZlcktleSk7XG4gICAgICAgIGlmICghYnVmZmVyTWFwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IChidWZmZXJNYXAuZ2V0KGV2ZW50TmFtZSkgfHwgW10pLmZpbHRlcihoYW5kbGVyID0+IGhhbmRsZXIgIT09IGNiKTtcbiAgICAgICAgLy8gUmVtb3ZlIGV2ZW50TmFtZSBsaXN0ZW5lciBmcm9tIGJ1ZmZlck1hcCBpZiBubyBtb3JlIGhhbmRsZXJzXG4gICAgICAgIGlmICghaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBidWZmZXJNYXAuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBidWZmZXJNYXAuc2V0KGV2ZW50TmFtZSwgaGFuZGxlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYnVmZmVyTWFwLnNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoZWRCdWZmZXJzLmRlbGV0ZShidWZmZXJLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuTmVvdmltQ2xpZW50ID0gTmVvdmltQ2xpZW50O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hdHRhY2ggPSB2b2lkIDA7XG5jb25zdCBub2RlX25ldF8xID0gcmVxdWlyZShcIm5vZGU6bmV0XCIpO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi4vYXBpL2NsaWVudFwiKTtcbmNvbnN0IGxvZ2dlcl8xID0gcmVxdWlyZShcIi4uL3V0aWxzL2xvZ2dlclwiKTtcbmZ1bmN0aW9uIGF0dGFjaCh7IHJlYWRlcjogX3JlYWRlciwgd3JpdGVyOiBfd3JpdGVyLCBwcm9jLCBzb2NrZXQsIG9wdGlvbnMgPSB7fSwgfSkge1xuICAgIGxldCB3cml0ZXI7XG4gICAgbGV0IHJlYWRlcjtcbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9ICgwLCBub2RlX25ldF8xLmNyZWF0ZUNvbm5lY3Rpb24pKHNvY2tldCk7XG4gICAgICAgIHdyaXRlciA9IGNsaWVudDtcbiAgICAgICAgcmVhZGVyID0gY2xpZW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChfcmVhZGVyICYmIF93cml0ZXIpIHtcbiAgICAgICAgd3JpdGVyID0gX3dyaXRlcjtcbiAgICAgICAgcmVhZGVyID0gX3JlYWRlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvYykge1xuICAgICAgICB3cml0ZXIgPSBwcm9jLnN0ZGluO1xuICAgICAgICByZWFkZXIgPSBwcm9jLnN0ZG91dDtcbiAgICB9XG4gICAgaWYgKHdyaXRlciAmJiByZWFkZXIpIHtcbiAgICAgICAgY29uc3QgbG9nZ2VySW5zdGFuY2UgPSBvcHRpb25zLmxvZ2dlciB8fCAoMCwgbG9nZ2VyXzEuZ2V0TG9nZ2VyKSgpOyAvLyBsYXp5IGxvYWQgdG8gd2luc3RvbiBvbmx5IGlmIG5lZWRlZFxuICAgICAgICBjb25zdCBuZW92aW0gPSBuZXcgY2xpZW50XzEuTmVvdmltQ2xpZW50KHsgbG9nZ2VyOiBsb2dnZXJJbnN0YW5jZSB9KTtcbiAgICAgICAgbmVvdmltLmF0dGFjaCh7XG4gICAgICAgICAgICB3cml0ZXIsXG4gICAgICAgICAgICByZWFkZXIsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmVvdmltO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzLCBjb3VsZCBub3QgYXR0YWNoJyk7XG59XG5leHBvcnRzLmF0dGFjaCA9IGF0dGFjaDtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXR0YWNoID0gdm9pZCAwO1xudmFyIGF0dGFjaF8xID0gcmVxdWlyZShcIi4vYXR0YWNoL2F0dGFjaFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImF0dGFjaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXR0YWNoXzEuYXR0YWNoOyB9IH0pO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UYWJwYWdlID0gZXhwb3J0cy5XaW5kb3cgPSBleHBvcnRzLkJ1ZmZlciA9IGV4cG9ydHMuTmVvdmltQ2xpZW50ID0gZXhwb3J0cy5OZW92aW0gPSB2b2lkIDA7XG52YXIgTmVvdmltXzEgPSByZXF1aXJlKFwiLi9OZW92aW1cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOZW92aW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5lb3ZpbV8xLk5lb3ZpbTsgfSB9KTtcbnZhciBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5lb3ZpbUNsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xpZW50XzEuTmVvdmltQ2xpZW50OyB9IH0pO1xudmFyIEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vQnVmZmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnVmZmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCdWZmZXJfMS5CdWZmZXI7IH0gfSk7XG52YXIgV2luZG93XzEgPSByZXF1aXJlKFwiLi9XaW5kb3dcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXaW5kb3dcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFdpbmRvd18xLldpbmRvdzsgfSB9KTtcbnZhciBUYWJwYWdlXzEgPSByZXF1aXJlKFwiLi9UYWJwYWdlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGFicGFnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVGFicGFnZV8xLlRhYnBhZ2U7IH0gfSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5WSU1fTUVUSE9EX05BTUUgPSBleHBvcnRzLk5WSU1fU1lOQyA9IGV4cG9ydHMuTlZJTV9TUEVDID0gZXhwb3J0cy5OVklNX0RFVl9NT0RFID0gZXhwb3J0cy5OVklNX1BMVUdJTiA9IHZvaWQgMDtcbi8vIENvbnN0YW50cyBmb3IgcGx1Z2luIHByb3BlcnRpZXNcbmV4cG9ydHMuTlZJTV9QTFVHSU4gPSAnX252aW1fcGx1Z2luJztcbmV4cG9ydHMuTlZJTV9ERVZfTU9ERSA9ICdfbnZpbV9kZXZfbW9kZSc7XG5leHBvcnRzLk5WSU1fU1BFQyA9ICdfbnZpbV9ycGNfc3BlYyc7XG5leHBvcnRzLk5WSU1fU1lOQyA9ICdfbnZpbV9ycGNfc3luYyc7XG5leHBvcnRzLk5WSU1fTUVUSE9EX05BTUUgPSAnX252aW1fcnBjX21ldGhvZF9uYW1lJztcbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OdmltUGx1Z2luID0gZXhwb3J0cy5jYWxsYWJsZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIGNhbGxhYmxlKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGZuKSAmJiBmbi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gZm5bMV0uYXBwbHkoZm5bMF0sIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbn1cbmV4cG9ydHMuY2FsbGFibGUgPSBjYWxsYWJsZTtcbmNsYXNzIE52aW1QbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKGZpbGVuYW1lLCBwbHVnaW4sIG52aW0pIHtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLm52aW0gPSBudmltO1xuICAgICAgICB0aGlzLmRldiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsd2F5c0luaXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdXRvY21kcyA9IHt9O1xuICAgICAgICB0aGlzLmNvbW1hbmRzID0ge307XG4gICAgICAgIHRoaXMuZnVuY3Rpb25zID0ge307XG4gICAgICAgIC8vIFNpbXBsaWZpZXMgY2xhc3MgYW5kIGRlY29yYXRvciBzdHlsZSBwbHVnaW5zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcFxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBwbHVnaW4odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBwbHVnaW4odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZGV2ID0gb3B0aW9ucy5kZXYgPT09IHVuZGVmaW5lZCA/IHRoaXMuZGV2IDogb3B0aW9ucy5kZXY7XG4gICAgICAgIHRoaXMuYWx3YXlzSW5pdCA9IG9wdGlvbnMuYWx3YXlzSW5pdDtcbiAgICB9XG4gICAgLy8gQ2FjaGUgbW9kdWxlIChpbiBkZXYgbW9kZSB3aWxsIGNsZWFyIHRoZSByZXF1aXJlIG1vZHVsZSBjYWNoZSlcbiAgICBnZXQgc2hvdWxkQ2FjaGVNb2R1bGUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kZXY7XG4gICAgfVxuICAgIHJlZ2lzdGVyQXV0b2NtZChuYW1lLCBmbiwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMucGF0dGVybikge1xuICAgICAgICAgICAgdGhpcy5udmltLmxvZ2dlci5lcnJvcihgcmVnaXN0ZXJBdXRvY21kIGV4cGVjdGVkIHBhdHRlcm4gb3B0aW9uIGZvciAke25hbWV9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BlYyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdhdXRvY21kJyxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBzeW5jOiBvcHRpb25zICYmICEhb3B0aW9ucy5zeW5jLFxuICAgICAgICAgICAgb3B0czoge30sXG4gICAgICAgIH07XG4gICAgICAgIFsncGF0dGVybicsICdldmFsJ10uZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9uc1tvcHRpb25dICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHNwZWMub3B0c1tvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYXV0b2NtZHNbYCR7bmFtZX0gJHtvcHRpb25zLnBhdHRlcm59YF0gPSB7XG4gICAgICAgICAgICAgICAgZm46IGNhbGxhYmxlKGZuKSxcbiAgICAgICAgICAgICAgICBzcGVjLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLm52aW0ubG9nZ2VyLmVycm9yKGByZWdpc3RlckF1dG9jbWQgZXhwZWN0ZWQgY2FsbGFibGUgYXJndW1lbnQgZm9yICR7bmFtZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3RlckNvbW1hbmQobmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3BlYyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBzeW5jOiBvcHRpb25zICYmICEhb3B0aW9ucy5zeW5jLFxuICAgICAgICAgICAgb3B0czoge30sXG4gICAgICAgIH07XG4gICAgICAgIFsncmFuZ2UnLCAnbmFyZ3MnLCAnY29tcGxldGUnXS5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zW29wdGlvbl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc3BlYy5vcHRzW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jb21tYW5kc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBmbjogY2FsbGFibGUoZm4pLFxuICAgICAgICAgICAgICAgIHNwZWMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMubnZpbS5sb2dnZXIuZXJyb3IoYHJlZ2lzdGVyQ29tbWFuZCBleHBlY3RlZCBjYWxsYWJsZSBhcmd1bWVudCBmb3IgJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2lzdGVyRnVuY3Rpb24obmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3BlYyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgc3luYzogb3B0aW9ucyAmJiAhIW9wdGlvbnMuc3luYyxcbiAgICAgICAgICAgIG9wdHM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBbJ3JhbmdlJywgJ2V2YWwnXS5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zW29wdGlvbl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc3BlYy5vcHRzW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5mdW5jdGlvbnNbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgZm46IGNhbGxhYmxlKGZuKSxcbiAgICAgICAgICAgICAgICBzcGVjLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLm52aW0ubG9nZ2VyLmVycm9yKGByZWdpc3RlckZ1bmN0aW9uIGV4cGVjdGVkIGNhbGxhYmxlIGFyZ3VtZW50IGZvciAke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNwZWNzKCkge1xuICAgICAgICBjb25zdCBhdXRvY21kcyA9IE9iamVjdC5rZXlzKHRoaXMuYXV0b2NtZHMpLm1hcChrZXkgPT4gdGhpcy5hdXRvY21kc1trZXldLnNwZWMpO1xuICAgICAgICBjb25zdCBjb21tYW5kcyA9IE9iamVjdC5rZXlzKHRoaXMuY29tbWFuZHMpLm1hcChrZXkgPT4gdGhpcy5jb21tYW5kc1trZXldLnNwZWMpO1xuICAgICAgICBjb25zdCBmdW5jdGlvbnMgPSBPYmplY3Qua2V5cyh0aGlzLmZ1bmN0aW9ucykubWFwKGtleSA9PiB0aGlzLmZ1bmN0aW9uc1trZXldLnNwZWMpO1xuICAgICAgICByZXR1cm4gYXV0b2NtZHMuY29uY2F0KGNvbW1hbmRzKS5jb25jYXQoZnVuY3Rpb25zKTtcbiAgICB9XG4gICAgaGFuZGxlUmVxdWVzdChuYW1lLCB0eXBlLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgaGFuZGxlcnM7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdhdXRvY21kJzpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMgPSB0aGlzLmF1dG9jbWRzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tYW5kJzpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMgPSB0aGlzLmNvbW1hbmRzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzID0gdGhpcy5mdW5jdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9IGBObyBoYW5kbGVyIGZvciB1bmtub3duIHR5cGUgJHt0eXBlfTogXCIke25hbWV9XCIgaW4gJHt0aGlzLmZpbGVuYW1lfWA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubnZpbS5sb2dnZXIuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFuZGxlcnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuc3BlYy5zeW5jXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGhhbmRsZXIuZm4oLi4uYXJncylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogeWllbGQgaGFuZGxlci5mbiguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgRXJyb3IgaW4gcGx1Z2luIGZvciAke3R5cGV9OiR7bmFtZX06ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5udmltLmxvZ2dlci5lcnJvcihgJHttc2d9IChmaWxlOiAke3RoaXMuZmlsZW5hbWV9LCBzdGFjazogJHtlcnIuc3RhY2t9KWApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSBgTWlzc2luZyBoYW5kbGVyIGZvciAke3R5cGV9OiBcIiR7bmFtZX1cIiBpbiAke3RoaXMuZmlsZW5hbWV9YDtcbiAgICAgICAgICAgICAgICB0aGlzLm52aW0ubG9nZ2VyLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTnZpbVBsdWdpbiA9IE52aW1QbHVnaW47XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQgbm8tc2hhZG93OjAsIGltcG9ydC9leHBvcnQ6MCAqL1xuLy8gUGx1Z2luIGRlY29yYXRvclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wbHVnaW4gPSBleHBvcnRzLk52aW1QbHVnaW4gPSBleHBvcnRzLk5lb3ZpbSA9IHZvaWQgMDtcbmNvbnN0IHByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXNcIik7XG5jb25zdCBOZW92aW1fMSA9IHJlcXVpcmUoXCIuLi9hcGkvTmVvdmltXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmVvdmltXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOZW92aW1fMS5OZW92aW07IH0gfSk7XG5jb25zdCBOdmltUGx1Z2luXzEgPSByZXF1aXJlKFwiLi4vaG9zdC9OdmltUGx1Z2luXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTnZpbVBsdWdpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTnZpbVBsdWdpbl8xLk52aW1QbHVnaW47IH0gfSk7XG5mdW5jdGlvbiB3cmFwcGVyKGNscywgb3B0aW9ucykge1xuICAgIHJldHVybiBjbGFzcyBleHRlbmRzIGNscyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsdWdpbiA9IGFyZ3NbMF07XG4gICAgICAgICAgICBzdXBlcihwbHVnaW4ubnZpbSwgcGx1Z2luKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXBpKHBsdWdpbi5udmltKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbHVnaW4ubnZpbS5sb2dnZXIuaW5mbyhgRGVjb3JhdGluZyBjbGFzcyAke2Nsc31gKTtcbiAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgZGVjb3JhdGVkIG1ldGhvZHNcbiAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNscy5wcm90b3R5cGUpLmZvckVhY2gobWV0aG9kTmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLm52aW0ubG9nZ2VyLmluZm8oYE1ldGhvZCBuYW1lICR7bWV0aG9kTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBwbHVnaW4ubnZpbS5sb2dnZXIuaW5mbyhgJHtjbHMucHJvdG90eXBlW21ldGhvZE5hbWVdfSAke3R5cGVvZiBjbHMucHJvdG90eXBlW21ldGhvZE5hbWVdfWApO1xuICAgICAgICAgICAgICAgIHBsdWdpbi5udmltLmxvZ2dlci5pbmZvKGAke3RoaXN9ICR7dHlwZW9mIHRoaXN9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gY2xzLnByb3RvdHlwZVttZXRob2ROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kICYmIG1ldGhvZFtwcm9wZXJ0aWVzXzEuTlZJTV9TUEVDXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGVjID0gbWV0aG9kW3Byb3BlcnRpZXNfMS5OVklNX1NQRUNdO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNwZWMudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXV0b2NtZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXV0b0NtZE9wdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IHNwZWMub3B0cy5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jOiBzcGVjLnN5bmMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMub3B0cy5ldmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvQ21kT3B0cy5ldmFsID0gc3BlYy5vcHRzLmV2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbi5yZWdpc3RlckF1dG9jbWQoc3BlYy5uYW1lLCBbdGhpcywgbWV0aG9kXSwgYXV0b0NtZE9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tbWFuZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY21kT3B0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luYzogc3BlYy5zeW5jLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzcGVjLm9wdHMucmFuZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtZE9wdHMucmFuZ2UgPSBzcGVjLm9wdHMucmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BlYy5vcHRzLm5hcmdzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbWRPcHRzLm5hcmdzID0gc3BlYy5vcHRzLm5hcmdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMub3B0cy5jb21wbGV0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY21kT3B0cy5jb21wbGV0ZSA9IHNwZWMub3B0cy5jb21wbGV0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luLnJlZ2lzdGVyQ29tbWFuZChzcGVjLm5hbWUsIFt0aGlzLCBtZXRob2RdLCBjbWRPcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmdW5jT3B0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luYzogc3BlYy5zeW5jLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzcGVjLm9wdHMucmFuZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmNPcHRzLnJhbmdlID0gc3BlYy5vcHRzLnJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMub3B0cy5ldmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jT3B0cy5ldmFsID0gc3BlYy5vcHRzLmV2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbi5yZWdpc3RlckZ1bmN0aW9uKHNwZWMubmFtZSwgW3RoaXMsIG1ldGhvZF0sIGZ1bmNPcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRBcGkobnZpbSkge1xuICAgICAgICAgICAgdGhpcy5udmltID0gbnZpbTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBwbHVnaW4ob3V0dGVyKSB7XG4gICAgLyoqXG4gICAgICogRGVjb3JhdG9yIHNob3VsZCBzdXBwb3J0XG4gICAgICpcbiAgICAgKiBAUGx1Z2luKG9wdHMpXG4gICAgICogY2xhc3MgVGVzdFBsdWcge31cbiAgICAgKlxuICAgICAqIGFuZFxuICAgICAqXG4gICAgICogQFBsdWdpblxuICAgICAqIGNsYXNzIFRlc3RQbHVnIHt9XG4gICAgICpcbiAgICAgKmFuZFxuICAgICAqXG4gICAgICogUGx1Z2luKG9wdHMpKFRlc3RQbHVnaW4pXG4gICAgICpcbiAgICAgKiBvclxuICAgICAqXG4gICAgICogUGx1Z2luKFRlc3RQbHVnaW4pXG4gICAgICovXG4gICAgcmV0dXJuIHR5cGVvZiBvdXR0ZXIgIT09ICdmdW5jdGlvbidcbiAgICAgICAgPyAoY2xzKSA9PiB3cmFwcGVyKGNscywgb3V0dGVyKVxuICAgICAgICA6IHdyYXBwZXIob3V0dGVyKTtcbn1cbmV4cG9ydHMucGx1Z2luID0gcGx1Z2luO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5udmltRnVuY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0aWVzXCIpO1xuZnVuY3Rpb24gbnZpbUZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2xzLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIC8vIGNvbnN0IHtcbiAgICAgICAgLy8gc3luYyxcbiAgICAgICAgLy8gLi4ub3B0cyxcbiAgICAgICAgLy8gfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHN5bmMgPSBvcHRpb25zICYmICEhb3B0aW9ucy5zeW5jO1xuICAgICAgICBjb25zdCBpc01ldGhvZCA9IHR5cGVvZiBtZXRob2ROYW1lID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgZiA9IGlzTWV0aG9kID8gY2xzW21ldGhvZE5hbWVdIDogY2xzO1xuICAgICAgICBjb25zdCBvcHRzID0ge307XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmFuZ2UpIHtcbiAgICAgICAgICAgIG9wdHMucmFuZ2UgPSBvcHRpb25zLnJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXZhbCkge1xuICAgICAgICAgICAgb3B0cy5ldmFsID0gb3B0aW9ucy5ldmFsO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBwcm9wZXJ0aWVzXzEuTlZJTV9NRVRIT0RfTkFNRSwgeyB2YWx1ZTogYGZ1bmN0aW9uOiR7bmFtZX1gIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgcHJvcGVydGllc18xLk5WSU1fU1lOQywgeyB2YWx1ZTogISFzeW5jIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgcHJvcGVydGllc18xLk5WSU1fU1BFQywge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgc3luYzogISFzeW5jLFxuICAgICAgICAgICAgICAgIG9wdHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzTWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGNsc1ttZXRob2ROYW1lXSA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNscztcbiAgICB9O1xufVxuZXhwb3J0cy5udmltRnVuY3Rpb24gPSBudmltRnVuY3Rpb247XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmF1dG9jbWQgPSB2b2lkIDA7XG5jb25zdCBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0aWVzXCIpO1xuLy8gRXhhbXBsZVxuLy8gQGF1dG9jbWQoJ0J1ZkVudGVyJywgeyBwYXR0ZXJuOiAnKi5qcycsIGV2YWw6ICdleHBhbmQoXCI8YWZpbGU+XCIpJywgc3luYzogdHJ1ZSB9KVxuZnVuY3Rpb24gYXV0b2NtZChuYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjbHMsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgLy8gY29uc3Qge1xuICAgICAgICAvLyBzeW5jLFxuICAgICAgICAvLyAuLi5vcHRzLFxuICAgICAgICAvLyB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3Qgc3luYyA9IG9wdGlvbnMgJiYgISFvcHRpb25zLnN5bmM7XG4gICAgICAgIGNvbnN0IGlzTWV0aG9kID0gdHlwZW9mIG1ldGhvZE5hbWUgPT09ICdzdHJpbmcnO1xuICAgICAgICBjb25zdCBmID0gaXNNZXRob2QgPyBjbHNbbWV0aG9kTmFtZV0gOiBjbHM7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICBwYXR0ZXJuOiAnJyxcbiAgICAgICAgfTtcbiAgICAgICAgWydwYXR0ZXJuJywgJ2V2YWwnXS5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zW29wdGlvbl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgb3B0c1tvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbmFtZVdpdGhQYXR0ZXJuID0gYCR7bmFtZX0ke29wdGlvbnMucGF0dGVybiA/IGA6JHtvcHRpb25zLnBhdHRlcm59YCA6ICcnfWA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBwcm9wZXJ0aWVzXzEuTlZJTV9NRVRIT0RfTkFNRSwge1xuICAgICAgICAgICAgdmFsdWU6IGBhdXRvY21kOiR7bmFtZVdpdGhQYXR0ZXJufWAsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgcHJvcGVydGllc18xLk5WSU1fU1lOQywgeyB2YWx1ZTogISFzeW5jIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgcHJvcGVydGllc18xLk5WSU1fU1BFQywge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXV0b2NtZCcsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBzeW5jOiAhIXN5bmMsXG4gICAgICAgICAgICAgICAgb3B0cyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNNZXRob2QpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgY2xzW21ldGhvZE5hbWVdID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xzO1xuICAgIH07XG59XG5leHBvcnRzLmF1dG9jbWQgPSBhdXRvY21kO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21tYW5kID0gdm9pZCAwO1xuY29uc3QgcHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vcHJvcGVydGllc1wiKTtcbi8vIEV4YW1wbGVcbi8vIEBjb21tYW5kKCdCdWZFbnRlcicsIHsgcmFuZ2U6ICcnLCBuYXJnczogJyonIH0pXG4vLyBAY29tbWFuZCgnTXlDb21tYW5kJywgeyBjb21wbGV0ZTogJ2N1c3RvbWxpc3QsTXlDdXN0b21Db21wbGV0ZUxpc3RGdW5jJyB9KVxuLy8gQGNvbW1hbmQoJ015Q29tbWFuZCcsIHsgY29tcGxldGU6ICdkaXInIH0pXG5mdW5jdGlvbiBjb21tYW5kKG5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNscywgbWV0aG9kTmFtZSkge1xuICAgICAgICBjb25zdCBzeW5jID0gb3B0aW9ucyAmJiAhIW9wdGlvbnMuc3luYztcbiAgICAgICAgY29uc3QgaXNNZXRob2QgPSB0eXBlb2YgbWV0aG9kTmFtZSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGYgPSBpc01ldGhvZCA/IGNsc1ttZXRob2ROYW1lXSA6IGNscztcbiAgICAgICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgICAgICBbJ3JhbmdlJywgJ25hcmdzJywgJ2NvbXBsZXRlJ10uZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9uc1tvcHRpb25dICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG9wdHNbb3B0aW9uXSA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBwcm9wZXJ0aWVzXzEuTlZJTV9NRVRIT0RfTkFNRSwgeyB2YWx1ZTogYGNvbW1hbmQ6JHtuYW1lfWAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBwcm9wZXJ0aWVzXzEuTlZJTV9TWU5DLCB7IHZhbHVlOiAhIXN5bmMgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBwcm9wZXJ0aWVzXzEuTlZJTV9TUEVDLCB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21tYW5kJyxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHN5bmM6ICEhc3luYyxcbiAgICAgICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc01ldGhvZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBjbHNbbWV0aG9kTmFtZV0gPSBmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbHM7XG4gICAgfTtcbn1cbmV4cG9ydHMuY29tbWFuZCA9IGNvbW1hbmQ7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQgZ2xvYmFsLXJlcXVpcmU6MCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tYW5kID0gZXhwb3J0cy5BdXRvY21kID0gZXhwb3J0cy5GdW5jdGlvbiA9IGV4cG9ydHMuUGx1Z2luID0gdm9pZCAwO1xudmFyIHBsdWdpbl8xID0gcmVxdWlyZShcIi4vcGx1Z2luXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwbHVnaW5fMS5wbHVnaW47IH0gfSk7XG52YXIgZnVuY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Z1bmN0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRnVuY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uXzEubnZpbUZ1bmN0aW9uOyB9IH0pO1xudmFyIGF1dG9jbWRfMSA9IHJlcXVpcmUoXCIuL2F1dG9jbWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBdXRvY21kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhdXRvY21kXzEuYXV0b2NtZDsgfSB9KTtcbnZhciBjb21tYW5kXzEgPSByZXF1aXJlKFwiLi9jb21tYW5kXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29tbWFuZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tbWFuZF8xLmNvbW1hbmQ7IH0gfSk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1hbmQgPSBleHBvcnRzLkF1dG9jbWQgPSBleHBvcnRzLkZ1bmN0aW9uID0gZXhwb3J0cy5QbHVnaW4gPSB2b2lkIDA7XG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL3BsdWdpbi9pbmRleFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBsdWdpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfMS5QbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGdW5jdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfMS5GdW5jdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkF1dG9jbWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4XzEuQXV0b2NtZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbW1hbmRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4XzEuQ29tbWFuZDsgfSB9KTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb2FkUGx1Z2luID0gdm9pZCAwO1xuY29uc3QgcGF0aCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibm9kZTpwYXRoXCIpKTtcbmNvbnN0IE1vZHVsZSA9IHJlcXVpcmUoXCJtb2R1bGVcIik7XG5jb25zdCBOdmltUGx1Z2luXzEgPSByZXF1aXJlKFwiLi9OdmltUGx1Z2luXCIpO1xuLy8gaW5zcGlyYXRpb24gZHJhd24gZnJvbSBNb2R1bGVcbmZ1bmN0aW9uIGNyZWF0ZVBsdWdpbihmaWxlbmFtZSwgbnZpbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbnZpbS5sb2dnZXIuZGVidWcoYGNyZWF0ZVBsdWdpbi4ke2ZpbGVuYW1lfS5jbGVhckNhY2hlOiAke29wdGlvbnMgJiYgIW9wdGlvbnMuY2FjaGV9YCk7XG4gICAgICAgIC8vIENsZWFyIG1vZHVsZSBmcm9tIGNhY2hlXG4gICAgICAgIGlmIChvcHRpb25zICYmICFvcHRpb25zLmNhY2hlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGBhcyBhbnlgIHRvIGFjY2VzcyBoaWRkZW4gQVBJXG4gICAgICAgICAgICAgICAgZGVsZXRlIE1vZHVsZS5fY2FjaGVbcmVxdWlyZS5yZXNvbHZlKGZpbGVuYW1lKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gcG9zc2libGUgdGhpcyBkb2Vzbid0IGV4aXN0IGluIGNhY2hlLCBpZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhdHRlbXB0IHRvIGltcG9ydCBwbHVnaW5cbiAgICAgICAgLy8gUmVxdWlyZSBwbHVnaW4gdG8gZXhwb3J0IGEgY2xhc3NcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdsb2JhbC1yZXF1aXJlLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzLCBpbXBvcnQvbm8tZHluYW1pYy1yZXF1aXJlXG4gICAgICAgIGNvbnN0IGRlZmF1bHRJbXBvcnQgPSByZXF1aXJlKGZpbGVuYW1lKTtcbiAgICAgICAgY29uc3QgcGx1Z2luID0gKGRlZmF1bHRJbXBvcnQgJiYgZGVmYXVsdEltcG9ydC5kZWZhdWx0KSB8fCBkZWZhdWx0SW1wb3J0O1xuICAgICAgICBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdmltUGx1Z2luXzEuTnZpbVBsdWdpbihmaWxlbmFtZSwgcGx1Z2luLCBudmltKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBwYXRoLmJhc2VuYW1lKGZpbGVuYW1lKTtcbiAgICAgICAgbnZpbS5sb2dnZXIuZXJyb3IoYFske2ZpbGV9XSAke2Vyci5zdGFja31gKTtcbiAgICAgICAgbnZpbS5sb2dnZXIuZXJyb3IoYFske2ZpbGV9XSBFcnJvciBsb2FkaW5nIGNoaWxkIENoaWxkUGx1Z2luICR7ZmlsZW5hbWV9YCk7XG4gICAgfVxuICAgIC8vIFRoZXJlIG1heSBoYXZlIGJlZW4gYW4gZXJyb3IsIGJ1dCBtYXliZSBub3RcbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGxvYWRQbHVnaW4oZmlsZW5hbWUsIG52aW0sIG9wdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQbHVnaW4oZmlsZW5hbWUsIG52aW0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGxvZ2dlci5lcnJvcihgQ291bGQgbm90IGxvYWQgcGx1Z2luIFwiJHtmaWxlbmFtZX1cIjpgLCBlcnIsIGVyci5zdGFjayk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMubG9hZFBsdWdpbiA9IGxvYWRQbHVnaW47XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4cG9ydHNGb3JUZXN0aW5nID0gZXhwb3J0cy5maW5kTnZpbSA9IHZvaWQgMDtcbmNvbnN0IG5vZGVfY2hpbGRfcHJvY2Vzc18xID0gcmVxdWlyZShcIm5vZGU6Y2hpbGRfcHJvY2Vzc1wiKTtcbmNvbnN0IG5vZGVfcGF0aF8xID0gcmVxdWlyZShcIm5vZGU6cGF0aFwiKTtcbmNvbnN0IG5vZGVfZnNfMSA9IHJlcXVpcmUoXCJub2RlOmZzXCIpO1xuY29uc3QgdmVyc2lvblJlZ2V4ID0gL14oXFxkKylcXC4oXFxkKylcXC4oXFxkKykoPzotKC4rKSk/JC87XG5jb25zdCBudmltVmVyc2lvblJlZ2V4ID0gL15OVklNXFxzK3YoLispJC9tO1xuY29uc3QgYnVpbGRUeXBlUmVnZXggPSAvXkJ1aWxkXFxzK3R5cGU6XFxzKyguKykkL207XG5jb25zdCBsdWFKaXRWZXJzaW9uUmVnZXggPSAvXkx1YUpJVFxccysoLispJC9tO1xuY29uc3Qgd2luZG93cyA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG5mdW5jdGlvbiBwYXJzZVZlcnNpb24odmVyc2lvbikge1xuICAgIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB2ZXJzaW9uIGZvcm1hdDogbm90IGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gdmVyc2lvbi5tYXRjaCh2ZXJzaW9uUmVnZXgpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgWywgbWFqb3IsIG1pbm9yLCBwYXRjaCwgcHJlcmVsZWFzZV0gPSBtYXRjaDtcbiAgICBjb25zdCBtYWpvck51bWJlciA9IE51bWJlcihtYWpvcik7XG4gICAgY29uc3QgbWlub3JOdW1iZXIgPSBOdW1iZXIobWlub3IpO1xuICAgIGNvbnN0IHBhdGNoTnVtYmVyID0gTnVtYmVyKHBhdGNoKTtcbiAgICBjb25zdCB2ZXJzaW9uUGFydHMgPSBbXG4gICAgICAgIG1ham9yTnVtYmVyLFxuICAgICAgICBtaW5vck51bWJlcixcbiAgICAgICAgcGF0Y2hOdW1iZXIsXG4gICAgXTtcbiAgICBpZiAocHJlcmVsZWFzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZlcnNpb25QYXJ0cy5wdXNoKHByZXJlbGVhc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmVyc2lvblBhcnRzLnB1c2goJ3p6eicpO1xuICAgIH1cbiAgICByZXR1cm4gdmVyc2lvblBhcnRzO1xufVxuLyoqXG4gKiBDb21wYXJlcyB0d28gdmVyc2lvbnMuXG4gKiBAcGFyYW0gYSAtIEZpcnN0IHZlcnNpb24gdG8gY29tcGFyZS5cbiAqIEBwYXJhbSBiIC0gU2Vjb25kIHZlcnNpb24gdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIC0xIGlmIGEgPCBiLCAwIGlmIGEgPT0gYiwgMSBpZiBhID4gYi5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIHZlcnNpb25zIGFyZSBub3QgdmFsaWQuXG4gKlxuICogRm9ybWF0IGNvdWxkIGJlOlxuICogLSAwLjkuMVxuICogLSAwLjEwLjAtZGV2LTY1OCtnMDY2OTQyMDNlLUhvbWVicmV3XG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9ucyhhLCBiKSB7XG4gICAgY29uc3QgdmVyc2lvbkEgPSBwYXJzZVZlcnNpb24oYSk7XG4gICAgY29uc3QgdmVyc2lvbkIgPSBwYXJzZVZlcnNpb24oYik7XG4gICAgY29uc3QgbGVuZ3RoID0gTWF0aC5taW4odmVyc2lvbkEubGVuZ3RoLCB2ZXJzaW9uQi5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpID0gaSArIDEpIHtcbiAgICAgICAgY29uc3QgcGFydEEgPSB2ZXJzaW9uQVtpXTtcbiAgICAgICAgY29uc3QgcGFydEIgPSB2ZXJzaW9uQltpXTtcbiAgICAgICAgaWYgKHBhcnRBIDwgcGFydEIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydEEgPiBwYXJ0Qikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZlcnNpb25CLmxlbmd0aCA+IHZlcnNpb25BLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuLyoqXG4gKiBUcmllcyB0byBmaW5kIGEgdXNhYmxlIGBudmltYCBiaW5hcnkgb24gdGhlIGN1cnJlbnQgc3lzdGVtLlxuICpcbiAqIEBwYXJhbSBvcHQubWluVmVyc2lvbiBTZWUge0BsaW5rIEZpbmROdmltT3B0aW9ucy5taW5WZXJzaW9ufVxuICogQHBhcmFtIG9wdC5vcmRlckJ5IFNlZSB7QGxpbmsgRmluZE52aW1PcHRpb25zLm9yZGVyQnl9XG4gKi9cbmZ1bmN0aW9uIGZpbmROdmltKG9wdCA9IHt9KSB7XG4gICAgY29uc3QgcGF0aHMgPSBwcm9jZXNzLmVudi5QQVRILnNwbGl0KG5vZGVfcGF0aF8xLmRlbGltaXRlcik7XG4gICAgY29uc3QgcGF0aExlbmd0aCA9IHBhdGhzLmxlbmd0aDtcbiAgICBjb25zdCBtYXRjaGVzID0gbmV3IEFycmF5KCk7XG4gICAgY29uc3QgaW52YWxpZCA9IG5ldyBBcnJheSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBwYXRoTGVuZ3RoOyBpID0gaSArIDEpIHtcbiAgICAgICAgY29uc3QgbnZpbVBhdGggPSAoMCwgbm9kZV9wYXRoXzEuam9pbikocGF0aHNbaV0sIHdpbmRvd3MgPyAnbnZpbS5leGUnIDogJ252aW0nKTtcbiAgICAgICAgaWYgKCgwLCBub2RlX2ZzXzEuZXhpc3RzU3luYykobnZpbVBhdGgpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICgwLCBub2RlX2ZzXzEuYWNjZXNzU3luYykobnZpbVBhdGgsIG5vZGVfZnNfMS5jb25zdGFudHMuWF9PSyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbnZpbVZlcnNpb25GdWxsID0gKDAsIG5vZGVfY2hpbGRfcHJvY2Vzc18xLmV4ZWNGaWxlU3luYykobnZpbVBhdGgsIFtcbiAgICAgICAgICAgICAgICAgICAgJy0tdmVyc2lvbicsXG4gICAgICAgICAgICAgICAgXSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBudmltVmVyc2lvbk1hdGNoID0gbnZpbVZlcnNpb25SZWdleC5leGVjKG52aW1WZXJzaW9uRnVsbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVpbGRUeXBlTWF0Y2ggPSBidWlsZFR5cGVSZWdleC5leGVjKG52aW1WZXJzaW9uRnVsbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbHVhSml0VmVyc2lvbk1hdGNoID0gbHVhSml0VmVyc2lvblJlZ2V4LmV4ZWMobnZpbVZlcnNpb25GdWxsKTtcbiAgICAgICAgICAgICAgICBpZiAobnZpbVZlcnNpb25NYXRjaCAmJiBidWlsZFR5cGVNYXRjaCAmJiBsdWFKaXRWZXJzaW9uTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdtaW5WZXJzaW9uJyBpbiBvcHQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmVWZXJzaW9ucyhvcHQubWluVmVyc2lvbiwgbnZpbVZlcnNpb25NYXRjaFsxXSkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnZpbVZlcnNpb246IG52aW1WZXJzaW9uTWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogbnZpbVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRUeXBlOiBidWlsZFR5cGVNYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsdWFKaXRWZXJzaW9uOiBsdWFKaXRWZXJzaW9uTWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnZpbVZlcnNpb246IG52aW1WZXJzaW9uTWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogbnZpbVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRUeXBlOiBidWlsZFR5cGVNYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsdWFKaXRWZXJzaW9uOiBsdWFKaXRWZXJzaW9uTWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogbnZpbVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHQub3JkZXJCeSA9PT0gdW5kZWZpbmVkIHx8IG9wdC5vcmRlckJ5ID09PSAnZGVzYycpIHtcbiAgICAgICAgbWF0Y2hlcy5zb3J0KChhLCBiKSA9PiBjb21wYXJlVmVyc2lvbnMoYi5udmltVmVyc2lvbiwgYS5udmltVmVyc2lvbikpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBpbnZhbGlkLFxuICAgIH07XG59XG5leHBvcnRzLmZpbmROdmltID0gZmluZE52aW07XG4vLyBqZXN0IHNldHMgTk9ERV9FTlY9dGVzdC5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gICAgLy8gVGhlc2UgZnVuY3Rpb25zIGFyZSBpbnRlbnRpb25hbGx5IG5vdCBleHBvcnRlZC4gQWZ0ZXIgYG52aW1gIGlzIGZvdW5kLCBjbGllbnRzIGNhbiB1c2UgTnZpbSdzXG4gICAgLy8gb3duIGB2aW0udmVyc2lvbmAgbW9kdWxlLCBzbyBub2RlLWNsaWVudCBzaG91bGRuJ3QgZXhwb3NlIGEgaGFsZi1iYWtlZCBcInNlbXZlclwiIGltcGxlbWVudGF0aW9uLlxuICAgIGV4cG9ydHMuZXhwb3J0c0ZvclRlc3RpbmcgPSB7XG4gICAgICAgIHBhcnNlVmVyc2lvbixcbiAgICAgICAgY29tcGFyZVZlcnNpb25zLFxuICAgIH07XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZpbmROdmltID0gZXhwb3J0cy5sb2FkUGx1Z2luID0gZXhwb3J0cy5OdmltUGx1Z2luID0gZXhwb3J0cy5Db21tYW5kID0gZXhwb3J0cy5BdXRvY21kID0gZXhwb3J0cy5GdW5jdGlvbiA9IGV4cG9ydHMuUGx1Z2luID0gZXhwb3J0cy5XaW5kb3cgPSBleHBvcnRzLlRhYnBhZ2UgPSBleHBvcnRzLkJ1ZmZlciA9IGV4cG9ydHMuTmVvdmltQ2xpZW50ID0gZXhwb3J0cy5OZW92aW0gPSBleHBvcnRzLmF0dGFjaCA9IHZvaWQgMDtcbnZhciBhdHRhY2hfMSA9IHJlcXVpcmUoXCIuL2F0dGFjaFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImF0dGFjaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXR0YWNoXzEuYXR0YWNoOyB9IH0pO1xudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi9hcGkvaW5kZXhcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOZW92aW1cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4XzEuTmVvdmltOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmVvdmltQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF8xLk5lb3ZpbUNsaWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJ1ZmZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfMS5CdWZmZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUYWJwYWdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF8xLlRhYnBhZ2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXaW5kb3dcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4XzEuV2luZG93OyB9IH0pO1xudmFyIHBsdWdpbl8xID0gcmVxdWlyZShcIi4vcGx1Z2luXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwbHVnaW5fMS5QbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGdW5jdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGx1Z2luXzEuRnVuY3Rpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBdXRvY21kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwbHVnaW5fMS5BdXRvY21kOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29tbWFuZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGx1Z2luXzEuQ29tbWFuZDsgfSB9KTtcbnZhciBOdmltUGx1Z2luXzEgPSByZXF1aXJlKFwiLi9ob3N0L052aW1QbHVnaW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdmltUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOdmltUGx1Z2luXzEuTnZpbVBsdWdpbjsgfSB9KTtcbnZhciBmYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9ob3N0L2ZhY3RvcnlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2FkUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWN0b3J5XzEubG9hZFBsdWdpbjsgfSB9KTtcbnZhciBmaW5kTnZpbV8xID0gcmVxdWlyZShcIi4vdXRpbHMvZmluZE52aW1cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmaW5kTnZpbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmluZE52aW1fMS5maW5kTnZpbTsgfSB9KTtcbiIsICJpbXBvcnQgeyBBcHAsIEZpbGVTeXN0ZW1BZGFwdGVyLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgZmluZE52aW0sIH0gZnJvbSAnbmVvdmltJ1xuaW1wb3J0ICogYXMgY2hpbGRfcHJvY2VzcyBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5pbXBvcnQgeyBOdmltVmVyc2lvbiB9IGZyb20gJ25lb3ZpbS9saWIvdXRpbHMvZmluZE52aW0nO1xuXG5cbmludGVyZmFjZSBFZGl0SW5OZW92aW1TZXR0aW5ncyB7XG5cdHRlcm1pbmFsOiBzdHJpbmc7XG5cdGxpc3Rlbk9uOiBzdHJpbmc7XG5cdG9wZW5OZW92aW1PbkxvYWQ6IGJvb2xlYW47XG5cdHN1cHBvcnRlZEZpbGVUeXBlczogc3RyaW5nW107XG59XG5cbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IEVkaXRJbk5lb3ZpbVNldHRpbmdzID0ge1xuXHR0ZXJtaW5hbDogcHJvY2Vzcy5lbnYuVEVSTUlOQUwgfHwgXCJhbGFjcml0dHlcIixcblx0bGlzdGVuT246IFwiMTI3LjAuMC4xOjIwMDZcIixcblx0b3Blbk5lb3ZpbU9uTG9hZDogdHJ1ZSxcblx0c3VwcG9ydGVkRmlsZVR5cGVzOiBbJ3R4dCcsICdtZCcsICdjc3MnLCAnanMnLCAndHMnLCAndHN4JywgJ2pzeCcsICdqc29uJ10sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVkaXRJbk5lb3ZpbSBleHRlbmRzIFBsdWdpbiB7XG5cdHNldHRpbmdzOiBFZGl0SW5OZW92aW1TZXR0aW5ncztcblxuXHRzcGF3bk5ld0luc3RhbmNlT25Mb2FkID0gKG52aW06IE52aW1WZXJzaW9uLCBhZGFwdGVyOiBGaWxlU3lzdGVtQWRhcHRlcikgPT4ge1xuXHRcdGNoaWxkX3Byb2Nlc3Muc3Bhd24odGhpcy5zZXR0aW5ncy50ZXJtaW5hbCwgW1xuXHRcdFx0Jy1lJyxcblx0XHRcdG52aW0ucGF0aCxcblx0XHRcdFwiLS1saXN0ZW5cIixcblx0XHRcdHRoaXMuc2V0dGluZ3MubGlzdGVuT24sXG5cdFx0XSwgeyBjd2Q6IGFkYXB0ZXIuZ2V0QmFzZVBhdGgoKSB9KVxuXHR9XG5cblx0b3BlbkluTmVvdmltSW5zdGFuY2UgPSAoZmlsZTogVEZpbGUgfCBudWxsKSA9PiB7XG5cdFx0aWYgKCFmaWxlKSByZXR1cm47XG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLnN1cHBvcnRlZEZpbGVUeXBlcy5pbmNsdWRlcyhmaWxlLmV4dGVuc2lvbikpIHJldHVybjtcblxuXHRcdGNvbnN0IGZvdW5kID0gZmluZE52aW0oeyBvcmRlckJ5OiAnZGVzYycsIG1pblZlcnNpb246ICcwLjkuMCcgfSk7XG5cdFx0Y2hpbGRfcHJvY2Vzcy5zcGF3bihmb3VuZC5tYXRjaGVzWzBdLnBhdGgsIFtcblx0XHRcdCctLXNlcnZlcicsIHRoaXMuc2V0dGluZ3MubGlzdGVuT24sXG5cdFx0XHQnLS1yZW1vdGUnLFxuXHRcdFx0YCR7ZmlsZS5wYXRofWBcblx0XHRdKVxuXHR9XG5cblx0YXN5bmMgb25sb2FkKCkge1xuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cblx0XHRjb25zdCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlcjtcblx0XHRjb25zdCBmb3VuZCA9IGZpbmROdmltKHsgb3JkZXJCeTogJ2Rlc2MnLCBtaW5WZXJzaW9uOiAnMC45LjAnIH0pXG5cdFx0aWYgKGZvdW5kLm1hdGNoZXMubGVuZ3RoID09PSAwKSB0aHJvdyBFcnJvcihcIk5vIFZhbGlkIG52aW0gYmluYXJpZXMgOicoIHBsdWdpbiBjYW4ndCBydW4gd2l0aG91dCB0aGVtXCIpO1xuXG5cdFx0aWYgKCEoYWRhcHRlciBpbnN0YW5jZW9mIEZpbGVTeXN0ZW1BZGFwdGVyKSkgdGhyb3cgRXJyb3IoXCJJIG5lZWQgYSBGaWxlU3lzdGVtQWRhcHRlciBpbiBvcmRlciB0byB3b3JrLCBhcmUgeW91IHJ1bm5pbmcgb24gbW9iaWxlP1wiKTtcblxuXHRcdGlmICh0aGlzLnNldHRpbmdzLm9wZW5OZW92aW1PbkxvYWQpIHRoaXMuc3Bhd25OZXdJbnN0YW5jZU9uTG9hZChmb3VuZC5tYXRjaGVzWzBdLCBhZGFwdGVyKVxuXHRcdGNvbnNvbGUubG9nKFwiRWRpdCBpbiBOZW92aW0gTG9hZGVkISB3aWxsIGxvb2sgZm9yIG5lb3ZpbSBsaXN0ZW5pbmcgYXQ6IFwiICsgdGhpcy5zZXR0aW5ncy5saXN0ZW5Pbik7XG5cblx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQodGhpcy5hcHAud29ya3NwYWNlLm9uKFwiZmlsZS1vcGVuXCIsIHRoaXMub3BlbkluTmVvdmltSW5zdGFuY2UpKTtcblxuXHRcdC8vIFRoaXMgYWRkcyBhIHNldHRpbmdzIHRhYiBzbyB0aGUgdXNlciBjYW4gY29uZmlndXJlIHZhcmlvdXMgYXNwZWN0cyBvZiB0aGUgcGx1Z2luXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBFZGl0SW5OZW92aW1TZXR0aW5nc1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG5cdFx0Ly8gUGxhbiB3b3VsZCBiZSB0byBhc2sgZm9yIHRoZSBwYXRoIHRvIHRoZSBmaWxlIHlvdSB3YW50IHRvIG9wZW4gaGVyZVxuXHRcdC8vIHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0Ly8gaWQ6ICdlZGl0LWluLW5lb3ZpbS1vcGVuJyxcblx0XHQvLyBuYW1lOiAnT3BlbiBJbiBOZW92aW0nLFxuXHRcdC8vIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdC8vIGNvbnNvbGUubG9nKGVkaXRvci5nZXRTZWxlY3Rpb24oKSk7XG5cdFx0Ly8gZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24oJ1NhbXBsZSBFZGl0b3IgQ29tbWFuZCcpO1xuXHRcdC8vIH1cblx0XHQvLyB9KTtcblx0fVxuXG5cdG9udW5sb2FkKCkgeyB9XG5cblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuXHR9XG5cblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG5cdH1cbn1cblxuY2xhc3MgRWRpdEluTmVvdmltU2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcblx0cGx1Z2luOiBFZGl0SW5OZW92aW07XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogRWRpdEluTmVvdmltKSB7XG5cdFx0c3VwZXIoYXBwLCBwbHVnaW4pO1xuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXHR9XG5cblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ1Rlcm1pbmFsJylcblx0XHRcdC5zZXREZXNjKCdXaGljaCB0ZXJtaW5hbCBlbXVsYXRvciBzaG91bGQgSSB0cnkgYW5kIHVzZSBmb3IgdGhlIG5lb3ZpbSBpbnN0YW5jZT8nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRS5nLiBhbGFjcml0dHksIGtpdHR5LCB3ZXp0ZXJtLi4uJylcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnRlcm1pbmFsKVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MudGVybWluYWwgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSkpO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnTmVvdmltIFNlcnZlciBMb2NhdGlvbicpXG5cdFx0XHQuc2V0RGVzYygnVGhlIE5lb3ZpbSBpbnN0YW5jZSB3aWxsIGJlIHNwYXduZWQgdXNpbmcgLS1saXN0ZW4gYW5kIG5lZWRzIGEgc29ja2V0IG9yIElQOlBPUlQgKG5vdCBzdXJlIGlmIHNvY2tldHMgd29yayBzbyB1c2UgYXQgeW91ciBvd24gcmlzayknKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignMTI3LjAuMC4xOjIwMDYnKVxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubGlzdGVuT24pXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyB2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MubGlzdGVuT24gPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSkpO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnT3BlbiBvbiBzdGFydHVwJylcblx0XHRcdC5zZXREZXNjKCdPcGVuIHRoZSBOZW92aW0gaW5zdGFuY2Ugd2hlbiBPYnNpZGlhbiBvcGVucycpXG5cdFx0XHQuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm9wZW5OZW92aW1PbkxvYWQpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyB2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3Mub3Blbk5lb3ZpbU9uTG9hZCA9IHZhbHVlO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHR9KSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdTdXBwb3J0ZWQgZmlsZSB0eXBlcycpXG5cdFx0XHQuc2V0RGVzYygnV2hpY2ggZmlsZSBleHRlbnNpb25zIGRvIHlvdSB3YW50IHRoaXMgZXh0ZW5zaW9uIHRvIHRyeSBhbmQgb3Blbj8nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcihcIkZpbGV0eXBlcyBzaG91bGQgYmUgc2VwYXJhdGVkIGJ5IHNwYWNlcyBhbmQgbm90IGluY2x1ZGUgdGhlICcuJywgRS5nLiAndHh0IG1kIGNzcyBodG1sJ1wiKVxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Muc3VwcG9ydGVkRmlsZVR5cGVzLmpvaW4oXCIgXCIpKVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgdmFsdWUgPT4ge1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnN1cHBvcnRlZEZpbGVUeXBlcyA9IHZhbHVlLnNwbGl0KFwiIFwiKVxuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHR9KSk7XG5cdH1cbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVhLFlBQUEsYUFBYTtBQUsxQixhQUFnQixVQUFVLE1BQWdCLFFBQWdCLE9BQWE7QUFDckUsWUFBTSxPQUFPLFFBQVE7QUFDckIsWUFBTSxNQUFNO0FBQ1osV0FBSyxVQUFVLFFBQVEsSUFBSTtBQUMzQixXQUFLLFVBQVUsU0FBUyxHQUFHLEdBQUc7SUFDaEM7QUFMQSxZQUFBLFlBQUE7QUFPQSxhQUFnQixTQUFTLE1BQWdCLFFBQWdCLE9BQWE7QUFDcEUsWUFBTSxPQUFPLEtBQUssTUFBTSxRQUFRLFVBQWE7QUFDN0MsWUFBTSxNQUFNO0FBQ1osV0FBSyxVQUFVLFFBQVEsSUFBSTtBQUMzQixXQUFLLFVBQVUsU0FBUyxHQUFHLEdBQUc7SUFDaEM7QUFMQSxZQUFBLFdBQUE7QUFPQSxhQUFnQixTQUFTLE1BQWdCLFFBQWM7QUFDckQsWUFBTSxPQUFPLEtBQUssU0FBUyxNQUFNO0FBQ2pDLFlBQU0sTUFBTSxLQUFLLFVBQVUsU0FBUyxDQUFDO0FBQ3JDLGFBQU8sT0FBTyxhQUFnQjtJQUNoQztBQUpBLFlBQUEsV0FBQTtBQU1BLGFBQWdCLFVBQVUsTUFBZ0IsUUFBYztBQUN0RCxZQUFNLE9BQU8sS0FBSyxVQUFVLE1BQU07QUFDbEMsWUFBTSxNQUFNLEtBQUssVUFBVSxTQUFTLENBQUM7QUFDckMsYUFBTyxPQUFPLGFBQWdCO0lBQ2hDO0FBSkEsWUFBQSxZQUFBOzs7Ozs7Ozs7Ozs7O0FDMUJBLFFBQUEsUUFBQTtBQUVBLFFBQU0sMkJBQ0gsT0FBTyxZQUFZLGlCQUFlLEtBQUEsWUFBTyxRQUFQLFlBQU8sU0FBQSxTQUFQLFFBQVMsU0FBRyxRQUFBLE9BQUEsU0FBQSxTQUFBLEdBQUcsZUFBZSxPQUFNLFlBQ3ZFLE9BQU8sZ0JBQWdCLGVBQ3ZCLE9BQU8sZ0JBQWdCO0FBRXpCLGFBQWdCLFVBQVUsS0FBVztBQUNuQyxZQUFNLFlBQVksSUFBSTtBQUV0QixVQUFJLGFBQWE7QUFDakIsVUFBSSxNQUFNO0FBQ1YsYUFBTyxNQUFNLFdBQVc7QUFDdEIsWUFBSSxRQUFRLElBQUksV0FBVyxLQUFLO0FBRWhDLGFBQUssUUFBUSxnQkFBZ0IsR0FBRztBQUU5QjtBQUNBO29CQUNVLFFBQVEsZ0JBQWdCLEdBQUc7QUFFckMsd0JBQWM7ZUFDVDtBQUVMLGNBQUksU0FBUyxTQUFVLFNBQVMsT0FBUTtBQUV0QyxnQkFBSSxNQUFNLFdBQVc7QUFDbkIsb0JBQU0sUUFBUSxJQUFJLFdBQVcsR0FBRztBQUNoQyxtQkFBSyxRQUFRLFdBQVksT0FBUTtBQUMvQixrQkFBRTtBQUNGLDBCQUFVLFFBQVEsU0FBVSxPQUFPLFFBQVEsUUFBUzs7OztBQUsxRCxlQUFLLFFBQVEsZ0JBQWdCLEdBQUc7QUFFOUIsMEJBQWM7aUJBQ1Q7QUFFTCwwQkFBYzs7OztBQUlwQixhQUFPO0lBQ1Q7QUF0Q0EsWUFBQSxZQUFBO0FBd0NBLGFBQWdCLGFBQWEsS0FBYSxRQUFvQixjQUFvQjtBQUNoRixZQUFNLFlBQVksSUFBSTtBQUN0QixVQUFJLFNBQVM7QUFDYixVQUFJLE1BQU07QUFDVixhQUFPLE1BQU0sV0FBVztBQUN0QixZQUFJLFFBQVEsSUFBSSxXQUFXLEtBQUs7QUFFaEMsYUFBSyxRQUFRLGdCQUFnQixHQUFHO0FBRTlCLGlCQUFPLFFBQVEsSUFBSTtBQUNuQjtvQkFDVSxRQUFRLGdCQUFnQixHQUFHO0FBRXJDLGlCQUFPLFFBQVEsSUFBTSxTQUFTLElBQUssS0FBUTtlQUN0QztBQUVMLGNBQUksU0FBUyxTQUFVLFNBQVMsT0FBUTtBQUV0QyxnQkFBSSxNQUFNLFdBQVc7QUFDbkIsb0JBQU0sUUFBUSxJQUFJLFdBQVcsR0FBRztBQUNoQyxtQkFBSyxRQUFRLFdBQVksT0FBUTtBQUMvQixrQkFBRTtBQUNGLDBCQUFVLFFBQVEsU0FBVSxPQUFPLFFBQVEsUUFBUzs7OztBQUsxRCxlQUFLLFFBQVEsZ0JBQWdCLEdBQUc7QUFFOUIsbUJBQU8sUUFBUSxJQUFNLFNBQVMsS0FBTSxLQUFRO0FBQzVDLG1CQUFPLFFBQVEsSUFBTSxTQUFTLElBQUssS0FBUTtpQkFDdEM7QUFFTCxtQkFBTyxRQUFRLElBQU0sU0FBUyxLQUFNLElBQVE7QUFDNUMsbUJBQU8sUUFBUSxJQUFNLFNBQVMsS0FBTSxLQUFRO0FBQzVDLG1CQUFPLFFBQVEsSUFBTSxTQUFTLElBQUssS0FBUTs7O0FBSS9DLGVBQU8sUUFBUSxJQUFLLFFBQVEsS0FBUTs7SUFFeEM7QUF6Q0EsWUFBQSxlQUFBO0FBMkNBLFFBQU0sb0JBQW9CLDBCQUEwQixJQUFJLFlBQVcsSUFBSztBQUMzRCxZQUFBLHlCQUF5QixDQUFDLDBCQUNuQyxNQUFBLGFBQ0EsT0FBTyxZQUFZLGlCQUFlLEtBQUEsWUFBTyxRQUFQLFlBQU8sU0FBQSxTQUFQLFFBQVMsU0FBRyxRQUFBLE9BQUEsU0FBQSxTQUFBLEdBQUcsZUFBZSxPQUFNLFVBQ3RFLE1BQ0E7QUFFSixhQUFTLG1CQUFtQixLQUFhLFFBQW9CLGNBQW9CO0FBQy9FLGFBQU8sSUFBSSxrQkFBbUIsT0FBTyxHQUFHLEdBQUcsWUFBWTtJQUN6RDtBQUVBLGFBQVMsdUJBQXVCLEtBQWEsUUFBb0IsY0FBb0I7QUFDbkYsd0JBQW1CLFdBQVcsS0FBSyxPQUFPLFNBQVMsWUFBWSxDQUFDO0lBQ2xFO0FBRWEsWUFBQSxnQkFBZSxzQkFBaUIsUUFBakIsc0JBQWlCLFNBQUEsU0FBakIsa0JBQW1CLGNBQWEseUJBQXlCO0FBRXJGLFFBQU0sYUFBYTtBQUVuQixhQUFnQixhQUFhLE9BQW1CLGFBQXFCLFlBQWtCO0FBQ3JGLFVBQUksU0FBUztBQUNiLFlBQU0sTUFBTSxTQUFTO0FBRXJCLFlBQU0sUUFBdUIsQ0FBQTtBQUM3QixVQUFJLFNBQVM7QUFDYixhQUFPLFNBQVMsS0FBSztBQUNuQixjQUFNLFFBQVEsTUFBTSxRQUFRO0FBQzVCLGFBQUssUUFBUSxTQUFVLEdBQUc7QUFFeEIsZ0JBQU0sS0FBSyxLQUFLO29CQUNOLFFBQVEsU0FBVSxLQUFNO0FBRWxDLGdCQUFNLFFBQVEsTUFBTSxRQUFRLElBQUs7QUFDakMsZ0JBQU0sTUFBTyxRQUFRLE9BQVMsSUFBSyxLQUFLO29CQUM5QixRQUFRLFNBQVUsS0FBTTtBQUVsQyxnQkFBTSxRQUFRLE1BQU0sUUFBUSxJQUFLO0FBQ2pDLGdCQUFNLFFBQVEsTUFBTSxRQUFRLElBQUs7QUFDakMsZ0JBQU0sTUFBTyxRQUFRLE9BQVMsS0FBTyxTQUFTLElBQUssS0FBSztvQkFDOUMsUUFBUSxTQUFVLEtBQU07QUFFbEMsZ0JBQU0sUUFBUSxNQUFNLFFBQVEsSUFBSztBQUNqQyxnQkFBTSxRQUFRLE1BQU0sUUFBUSxJQUFLO0FBQ2pDLGdCQUFNLFFBQVEsTUFBTSxRQUFRLElBQUs7QUFDakMsY0FBSSxRQUFTLFFBQVEsTUFBUyxLQUFTLFNBQVMsS0FBUyxTQUFTLElBQVE7QUFDMUUsY0FBSSxPQUFPLE9BQVE7QUFDakIsb0JBQVE7QUFDUixrQkFBTSxLQUFPLFNBQVMsS0FBTSxPQUFTLEtBQU07QUFDM0MsbUJBQU8sUUFBVSxPQUFPOztBQUUxQixnQkFBTSxLQUFLLElBQUk7ZUFDVjtBQUNMLGdCQUFNLEtBQUssS0FBSzs7QUFHbEIsWUFBSSxNQUFNLFVBQVUsWUFBWTtBQUM5QixvQkFBVSxPQUFPLGFBQWEsR0FBRyxLQUFLO0FBQ3RDLGdCQUFNLFNBQVM7OztBQUluQixVQUFJLE1BQU0sU0FBUyxHQUFHO0FBQ3BCLGtCQUFVLE9BQU8sYUFBYSxHQUFHLEtBQUs7O0FBR3hDLGFBQU87SUFDVDtBQS9DQSxZQUFBLGVBQUE7QUFpREEsUUFBTSxvQkFBb0IsMEJBQTBCLElBQUksWUFBVyxJQUFLO0FBQzNELFlBQUEseUJBQXlCLENBQUMsMEJBQ25DLE1BQUEsYUFDQSxPQUFPLFlBQVksaUJBQWUsS0FBQSxZQUFPLFFBQVAsWUFBTyxTQUFBLFNBQVAsUUFBUyxTQUFHLFFBQUEsT0FBQSxTQUFBLFNBQUEsR0FBRyxjQUFjLE9BQU0sVUFDckUsTUFDQTtBQUVKLGFBQWdCLGFBQWEsT0FBbUIsYUFBcUIsWUFBa0I7QUFDckYsWUFBTSxjQUFjLE1BQU0sU0FBUyxhQUFhLGNBQWMsVUFBVTtBQUN4RSxhQUFPLGtCQUFtQixPQUFPLFdBQVc7SUFDOUM7QUFIQSxZQUFBLGVBQUE7Ozs7Ozs7Ozs7QUNuS0EsUUFBYSxVQUFiLE1BQW9CO01BQ2xCLFlBQXFCLE1BQXVCLE1BQWdCO0FBQXZDLGFBQUEsT0FBQTtBQUF1QixhQUFBLE9BQUE7TUFBbUI7O0FBRGpFLFlBQUEsVUFBQTs7Ozs7Ozs7OztBQ0hBLFFBQWEsY0FBYixjQUFpQyxNQUFLO01BQ3BDLFlBQVksU0FBZTtBQUN6QixjQUFNLE9BQU87QUFHYixjQUFNLFFBQXNDLE9BQU8sT0FBTyxZQUFZLFNBQVM7QUFDL0UsZUFBTyxlQUFlLE1BQU0sS0FBSztBQUVqQyxlQUFPLGVBQWUsTUFBTSxRQUFRO1VBQ2xDLGNBQWM7VUFDZCxZQUFZO1VBQ1osT0FBTyxZQUFZO1NBQ3BCO01BQ0g7O0FBYkYsWUFBQSxjQUFBOzs7Ozs7Ozs7O0FDQ0EsUUFBQSxnQkFBQTtBQUNBLFFBQUEsUUFBQTtBQUVhLFlBQUEsZ0JBQWdCO0FBTzdCLFFBQU0sc0JBQXNCLGFBQWM7QUFDMUMsUUFBTSxzQkFBc0IsY0FBYztBQUUxQyxhQUFnQiwwQkFBMEIsRUFBRSxLQUFLLEtBQUksR0FBWTtBQUMvRCxVQUFJLE9BQU8sS0FBSyxRQUFRLEtBQUssT0FBTyxxQkFBcUI7QUFFdkQsWUFBSSxTQUFTLEtBQUssT0FBTyxxQkFBcUI7QUFFNUMsZ0JBQU0sS0FBSyxJQUFJLFdBQVcsQ0FBQztBQUMzQixnQkFBTSxPQUFPLElBQUksU0FBUyxHQUFHLE1BQU07QUFDbkMsZUFBSyxVQUFVLEdBQUcsR0FBRztBQUNyQixpQkFBTztlQUNGO0FBRUwsZ0JBQU0sVUFBVSxNQUFNO0FBQ3RCLGdCQUFNLFNBQVMsTUFBTTtBQUNyQixnQkFBTSxLQUFLLElBQUksV0FBVyxDQUFDO0FBQzNCLGdCQUFNLE9BQU8sSUFBSSxTQUFTLEdBQUcsTUFBTTtBQUVuQyxlQUFLLFVBQVUsR0FBSSxRQUFRLElBQU0sVUFBVSxDQUFJO0FBRS9DLGVBQUssVUFBVSxHQUFHLE1BQU07QUFDeEIsaUJBQU87O2FBRUo7QUFFTCxjQUFNLEtBQUssSUFBSSxXQUFXLEVBQUU7QUFDNUIsY0FBTSxPQUFPLElBQUksU0FBUyxHQUFHLE1BQU07QUFDbkMsYUFBSyxVQUFVLEdBQUcsSUFBSTtBQUN0QixTQUFBLEdBQUEsTUFBQSxVQUFTLE1BQU0sR0FBRyxHQUFHO0FBQ3JCLGVBQU87O0lBRVg7QUE3QkEsWUFBQSw0QkFBQTtBQStCQSxhQUFnQixxQkFBcUIsTUFBVTtBQUM3QyxZQUFNLE9BQU8sS0FBSyxRQUFPO0FBQ3pCLFlBQU0sTUFBTSxLQUFLLE1BQU0sT0FBTyxHQUFHO0FBQ2pDLFlBQU0sUUFBUSxPQUFPLE1BQU0sT0FBTztBQUdsQyxZQUFNLFlBQVksS0FBSyxNQUFNLE9BQU8sR0FBRztBQUN2QyxhQUFPO1FBQ0wsS0FBSyxNQUFNO1FBQ1gsTUFBTSxPQUFPLFlBQVk7O0lBRTdCO0FBWEEsWUFBQSx1QkFBQTtBQWFBLGFBQWdCLHlCQUF5QixRQUFlO0FBQ3RELFVBQUksa0JBQWtCLE1BQU07QUFDMUIsY0FBTSxXQUFXLHFCQUFxQixNQUFNO0FBQzVDLGVBQU8sMEJBQTBCLFFBQVE7YUFDcEM7QUFDTCxlQUFPOztJQUVYO0FBUEEsWUFBQSwyQkFBQTtBQVNBLGFBQWdCLDBCQUEwQixNQUFnQjtBQUN4RCxZQUFNLE9BQU8sSUFBSSxTQUFTLEtBQUssUUFBUSxLQUFLLFlBQVksS0FBSyxVQUFVO0FBR3ZFLGNBQVEsS0FBSyxZQUFZO1FBQ3ZCLEtBQUssR0FBRztBQUVOLGdCQUFNLE1BQU0sS0FBSyxVQUFVLENBQUM7QUFDNUIsZ0JBQU0sT0FBTztBQUNiLGlCQUFPLEVBQUUsS0FBSyxLQUFJOztRQUVwQixLQUFLLEdBQUc7QUFFTixnQkFBTSxvQkFBb0IsS0FBSyxVQUFVLENBQUM7QUFDMUMsZ0JBQU0sV0FBVyxLQUFLLFVBQVUsQ0FBQztBQUNqQyxnQkFBTSxPQUFPLG9CQUFvQixLQUFPLGFBQWM7QUFDdEQsZ0JBQU0sT0FBTyxzQkFBc0I7QUFDbkMsaUJBQU8sRUFBRSxLQUFLLEtBQUk7O1FBRXBCLEtBQUssSUFBSTtBQUdQLGdCQUFNLE9BQU0sR0FBQSxNQUFBLFVBQVMsTUFBTSxDQUFDO0FBQzVCLGdCQUFNLE9BQU8sS0FBSyxVQUFVLENBQUM7QUFDN0IsaUJBQU8sRUFBRSxLQUFLLEtBQUk7O1FBRXBCO0FBQ0UsZ0JBQU0sSUFBSSxjQUFBLFlBQVksZ0VBQWdFLEtBQUssUUFBUTs7SUFFekc7QUE3QkEsWUFBQSw0QkFBQTtBQStCQSxhQUFnQix5QkFBeUIsTUFBZ0I7QUFDdkQsWUFBTSxXQUFXLDBCQUEwQixJQUFJO0FBQy9DLGFBQU8sSUFBSSxLQUFLLFNBQVMsTUFBTSxNQUFNLFNBQVMsT0FBTyxHQUFHO0lBQzFEO0FBSEEsWUFBQSwyQkFBQTtBQUthLFlBQUEscUJBQXFCO01BQ2hDLE1BQU0sUUFBQTtNQUNOLFFBQVE7TUFDUixRQUFROzs7Ozs7Ozs7OztBQ3hHVixRQUFBLFlBQUE7QUFDQSxRQUFBLGNBQUE7QUFrQkEsUUFBYSxpQkFBYixNQUEyQjtNQWdCekIsY0FBQTtBQVBpQixhQUFBLGtCQUErRSxDQUFBO0FBQy9FLGFBQUEsa0JBQStFLENBQUE7QUFHL0UsYUFBQSxXQUF3RSxDQUFBO0FBQ3hFLGFBQUEsV0FBd0UsQ0FBQTtBQUd2RixhQUFLLFNBQVMsWUFBQSxrQkFBa0I7TUFDbEM7TUFFTyxTQUFTLEVBQ2QsTUFDQSxRQUNBLE9BQU0sR0FLUDtBQUNDLFlBQUksUUFBUSxHQUFHO0FBRWIsZUFBSyxTQUFTLElBQUksSUFBSTtBQUN0QixlQUFLLFNBQVMsSUFBSSxJQUFJO2VBQ2pCO0FBRUwsZ0JBQU0sUUFBUSxJQUFJO0FBQ2xCLGVBQUssZ0JBQWdCLEtBQUssSUFBSTtBQUM5QixlQUFLLGdCQUFnQixLQUFLLElBQUk7O01BRWxDO01BRU8sWUFBWSxRQUFpQixTQUFvQjtBQUV0RCxpQkFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLGdCQUFnQixRQUFRLEtBQUs7QUFDcEQsZ0JBQU0sWUFBWSxLQUFLLGdCQUFnQixDQUFDO0FBQ3hDLGNBQUksYUFBYSxNQUFNO0FBQ3JCLGtCQUFNLE9BQU8sVUFBVSxRQUFRLE9BQU87QUFDdEMsZ0JBQUksUUFBUSxNQUFNO0FBQ2hCLG9CQUFNLE9BQU8sS0FBSztBQUNsQixxQkFBTyxJQUFJLFVBQUEsUUFBUSxNQUFNLElBQUk7Ozs7QUFNbkMsaUJBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxTQUFTLFFBQVEsS0FBSztBQUM3QyxnQkFBTSxZQUFZLEtBQUssU0FBUyxDQUFDO0FBQ2pDLGNBQUksYUFBYSxNQUFNO0FBQ3JCLGtCQUFNLE9BQU8sVUFBVSxRQUFRLE9BQU87QUFDdEMsZ0JBQUksUUFBUSxNQUFNO0FBQ2hCLG9CQUFNLE9BQU87QUFDYixxQkFBTyxJQUFJLFVBQUEsUUFBUSxNQUFNLElBQUk7Ozs7QUFLbkMsWUFBSSxrQkFBa0IsVUFBQSxTQUFTO0FBRTdCLGlCQUFPOztBQUVULGVBQU87TUFDVDtNQUVPLE9BQU8sTUFBa0IsTUFBYyxTQUFvQjtBQUNoRSxjQUFNLFlBQVksT0FBTyxJQUFJLEtBQUssZ0JBQWdCLEtBQUssSUFBSSxJQUFJLEtBQUssU0FBUyxJQUFJO0FBQ2pGLFlBQUksV0FBVztBQUNiLGlCQUFPLFVBQVUsTUFBTSxNQUFNLE9BQU87ZUFDL0I7QUFFTCxpQkFBTyxJQUFJLFVBQUEsUUFBUSxNQUFNLElBQUk7O01BRWpDOztBQWpGRixZQUFBLGlCQUFBO0FBQ3lCLG1CQUFBLGVBQThDLElBQUksZUFBYzs7Ozs7Ozs7OztBQ3RCekYsYUFBZ0IsaUJBQWlCLFFBQXNFO0FBQ3JHLFVBQUksa0JBQWtCLFlBQVk7QUFDaEMsZUFBTztpQkFDRSxZQUFZLE9BQU8sTUFBTSxHQUFHO0FBQ3JDLGVBQU8sSUFBSSxXQUFXLE9BQU8sUUFBUSxPQUFPLFlBQVksT0FBTyxVQUFVO2lCQUNoRSxrQkFBa0IsYUFBYTtBQUN4QyxlQUFPLElBQUksV0FBVyxNQUFNO2FBQ3ZCO0FBRUwsZUFBTyxXQUFXLEtBQUssTUFBTTs7SUFFakM7QUFYQSxZQUFBLG1CQUFBO0FBYUEsYUFBZ0IsZUFBZSxRQUF5RDtBQUN0RixVQUFJLGtCQUFrQixhQUFhO0FBQ2pDLGVBQU8sSUFBSSxTQUFTLE1BQU07O0FBRzVCLFlBQU0sYUFBYSxpQkFBaUIsTUFBTTtBQUMxQyxhQUFPLElBQUksU0FBUyxXQUFXLFFBQVEsV0FBVyxZQUFZLFdBQVcsVUFBVTtJQUNyRjtBQVBBLFlBQUEsaUJBQUE7Ozs7Ozs7Ozs7QUNiQSxRQUFBLFNBQUE7QUFDQSxRQUFBLG1CQUFBO0FBQ0EsUUFBQSxRQUFBO0FBQ0EsUUFBQSxnQkFBQTtBQUdhLFlBQUEsb0JBQW9CO0FBQ3BCLFlBQUEsOEJBQThCO0FBRTNDLFFBQWEsVUFBYixNQUFvQjtNQUtsQixZQUNtQixpQkFBa0QsaUJBQUEsZUFBZSxjQUNqRSxVQUF1QixRQUN2QixXQUFXLFFBQUEsbUJBQ1gsb0JBQW9CLFFBQUEsNkJBQ3BCLFdBQVcsT0FDWCxlQUFlLE9BQ2Ysa0JBQWtCLE9BQ2xCLHNCQUFzQixPQUFLO0FBUDNCLGFBQUEsaUJBQUE7QUFDQSxhQUFBLFVBQUE7QUFDQSxhQUFBLFdBQUE7QUFDQSxhQUFBLG9CQUFBO0FBQ0EsYUFBQSxXQUFBO0FBQ0EsYUFBQSxlQUFBO0FBQ0EsYUFBQSxrQkFBQTtBQUNBLGFBQUEsc0JBQUE7QUFaWCxhQUFBLE1BQU07QUFDTixhQUFBLE9BQU8sSUFBSSxTQUFTLElBQUksWUFBWSxLQUFLLGlCQUFpQixDQUFDO0FBQzNELGFBQUEsUUFBUSxJQUFJLFdBQVcsS0FBSyxLQUFLLE1BQU07TUFXNUM7TUFFSyxvQkFBaUI7QUFDdkIsYUFBSyxNQUFNO01BQ2I7Ozs7OztNQU9PLGdCQUFnQixRQUFlO0FBQ3BDLGFBQUssa0JBQWlCO0FBQ3RCLGFBQUssU0FBUyxRQUFRLENBQUM7QUFDdkIsZUFBTyxLQUFLLE1BQU0sU0FBUyxHQUFHLEtBQUssR0FBRztNQUN4Qzs7OztNQUtPLE9BQU8sUUFBZTtBQUMzQixhQUFLLGtCQUFpQjtBQUN0QixhQUFLLFNBQVMsUUFBUSxDQUFDO0FBQ3ZCLGVBQU8sS0FBSyxNQUFNLE1BQU0sR0FBRyxLQUFLLEdBQUc7TUFDckM7TUFFUSxTQUFTLFFBQWlCLE9BQWE7QUFDN0MsWUFBSSxRQUFRLEtBQUssVUFBVTtBQUN6QixnQkFBTSxJQUFJLE1BQU0sNkJBQTZCLE9BQU87O0FBR3RELFlBQUksVUFBVSxNQUFNO0FBQ2xCLGVBQUssVUFBUzttQkFDTCxPQUFPLFdBQVcsV0FBVztBQUN0QyxlQUFLLGNBQWMsTUFBTTttQkFDaEIsT0FBTyxXQUFXLFVBQVU7QUFDckMsZUFBSyxhQUFhLE1BQU07bUJBQ2YsT0FBTyxXQUFXLFVBQVU7QUFDckMsZUFBSyxhQUFhLE1BQU07ZUFDbkI7QUFDTCxlQUFLLGFBQWEsUUFBUSxLQUFLOztNQUVuQztNQUVRLHdCQUF3QixhQUFtQjtBQUNqRCxjQUFNLGVBQWUsS0FBSyxNQUFNO0FBRWhDLFlBQUksS0FBSyxLQUFLLGFBQWEsY0FBYztBQUN2QyxlQUFLLGFBQWEsZUFBZSxDQUFDOztNQUV0QztNQUVRLGFBQWEsU0FBZTtBQUNsQyxjQUFNLFlBQVksSUFBSSxZQUFZLE9BQU87QUFDekMsY0FBTSxXQUFXLElBQUksV0FBVyxTQUFTO0FBQ3pDLGNBQU0sVUFBVSxJQUFJLFNBQVMsU0FBUztBQUV0QyxpQkFBUyxJQUFJLEtBQUssS0FBSztBQUV2QixhQUFLLE9BQU87QUFDWixhQUFLLFFBQVE7TUFDZjtNQUVRLFlBQVM7QUFDZixhQUFLLFFBQVEsR0FBSTtNQUNuQjtNQUVRLGNBQWMsUUFBZTtBQUNuQyxZQUFJLFdBQVcsT0FBTztBQUNwQixlQUFLLFFBQVEsR0FBSTtlQUNaO0FBQ0wsZUFBSyxRQUFRLEdBQUk7O01BRXJCO01BQ1EsYUFBYSxRQUFjO0FBQ2pDLFlBQUksT0FBTyxjQUFjLE1BQU0sS0FBSyxDQUFDLEtBQUsscUJBQXFCO0FBQzdELGNBQUksVUFBVSxHQUFHO0FBQ2YsZ0JBQUksU0FBUyxLQUFNO0FBRWpCLG1CQUFLLFFBQVEsTUFBTTt1QkFDVixTQUFTLEtBQU87QUFFekIsbUJBQUssUUFBUSxHQUFJO0FBQ2pCLG1CQUFLLFFBQVEsTUFBTTt1QkFDVixTQUFTLE9BQVM7QUFFM0IsbUJBQUssUUFBUSxHQUFJO0FBQ2pCLG1CQUFLLFNBQVMsTUFBTTt1QkFDWCxTQUFTLFlBQWE7QUFFL0IsbUJBQUssUUFBUSxHQUFJO0FBQ2pCLG1CQUFLLFNBQVMsTUFBTTttQkFDZjtBQUVMLG1CQUFLLFFBQVEsR0FBSTtBQUNqQixtQkFBSyxTQUFTLE1BQU07O2lCQUVqQjtBQUNMLGdCQUFJLFVBQVUsS0FBTztBQUVuQixtQkFBSyxRQUFRLE1BQVEsU0FBUyxFQUFLO3VCQUMxQixVQUFVLE1BQU87QUFFMUIsbUJBQUssUUFBUSxHQUFJO0FBQ2pCLG1CQUFLLFFBQVEsTUFBTTt1QkFDVixVQUFVLFFBQVM7QUFFNUIsbUJBQUssUUFBUSxHQUFJO0FBQ2pCLG1CQUFLLFNBQVMsTUFBTTt1QkFDWCxVQUFVLGFBQWE7QUFFaEMsbUJBQUssUUFBUSxHQUFJO0FBQ2pCLG1CQUFLLFNBQVMsTUFBTTttQkFDZjtBQUVMLG1CQUFLLFFBQVEsR0FBSTtBQUNqQixtQkFBSyxTQUFTLE1BQU07OztlQUduQjtBQUVMLGNBQUksS0FBSyxjQUFjO0FBRXJCLGlCQUFLLFFBQVEsR0FBSTtBQUNqQixpQkFBSyxTQUFTLE1BQU07aUJBQ2Y7QUFFTCxpQkFBSyxRQUFRLEdBQUk7QUFDakIsaUJBQUssU0FBUyxNQUFNOzs7TUFHMUI7TUFFUSxrQkFBa0IsWUFBa0I7QUFDMUMsWUFBSSxhQUFhLElBQUk7QUFFbkIsZUFBSyxRQUFRLE1BQU8sVUFBVTttQkFDckIsYUFBYSxLQUFPO0FBRTdCLGVBQUssUUFBUSxHQUFJO0FBQ2pCLGVBQUssUUFBUSxVQUFVO21CQUNkLGFBQWEsT0FBUztBQUUvQixlQUFLLFFBQVEsR0FBSTtBQUNqQixlQUFLLFNBQVMsVUFBVTttQkFDZixhQUFhLFlBQWE7QUFFbkMsZUFBSyxRQUFRLEdBQUk7QUFDakIsZUFBSyxTQUFTLFVBQVU7ZUFDbkI7QUFDTCxnQkFBTSxJQUFJLE1BQU0sb0JBQW9CLDJCQUEyQjs7TUFFbkU7TUFFUSxhQUFhLFFBQWM7QUFDakMsY0FBTSxnQkFBZ0IsSUFBSTtBQUMxQixjQUFNLFlBQVksT0FBTztBQUV6QixZQUFJLFlBQVksT0FBQSx3QkFBd0I7QUFDdEMsZ0JBQU0sY0FBYSxHQUFBLE9BQUEsV0FBVSxNQUFNO0FBQ25DLGVBQUssd0JBQXdCLGdCQUFnQixVQUFVO0FBQ3ZELGVBQUssa0JBQWtCLFVBQVU7QUFDakMsV0FBQSxHQUFBLE9BQUEsY0FBYSxRQUFRLEtBQUssT0FBTyxLQUFLLEdBQUc7QUFDekMsZUFBSyxPQUFPO2VBQ1A7QUFDTCxnQkFBTSxjQUFhLEdBQUEsT0FBQSxXQUFVLE1BQU07QUFDbkMsZUFBSyx3QkFBd0IsZ0JBQWdCLFVBQVU7QUFDdkQsZUFBSyxrQkFBa0IsVUFBVTtBQUNqQyxXQUFBLEdBQUEsT0FBQSxjQUFhLFFBQVEsS0FBSyxPQUFPLEtBQUssR0FBRztBQUN6QyxlQUFLLE9BQU87O01BRWhCO01BRVEsYUFBYSxRQUFpQixPQUFhO0FBRWpELGNBQU0sTUFBTSxLQUFLLGVBQWUsWUFBWSxRQUFRLEtBQUssT0FBTztBQUNoRSxZQUFJLE9BQU8sTUFBTTtBQUNmLGVBQUssZ0JBQWdCLEdBQUc7bUJBQ2YsTUFBTSxRQUFRLE1BQU0sR0FBRztBQUNoQyxlQUFLLFlBQVksUUFBUSxLQUFLO21CQUNyQixZQUFZLE9BQU8sTUFBTSxHQUFHO0FBQ3JDLGVBQUssYUFBYSxNQUFNO21CQUNmLE9BQU8sV0FBVyxVQUFVO0FBQ3JDLGVBQUssVUFBVSxRQUFtQyxLQUFLO2VBQ2xEO0FBRUwsZ0JBQU0sSUFBSSxNQUFNLHdCQUF3QixPQUFPLFVBQVUsU0FBUyxNQUFNLE1BQU0sR0FBRzs7TUFFckY7TUFFUSxhQUFhLFFBQXVCO0FBQzFDLGNBQU0sT0FBTyxPQUFPO0FBQ3BCLFlBQUksT0FBTyxLQUFPO0FBRWhCLGVBQUssUUFBUSxHQUFJO0FBQ2pCLGVBQUssUUFBUSxJQUFJO21CQUNSLE9BQU8sT0FBUztBQUV6QixlQUFLLFFBQVEsR0FBSTtBQUNqQixlQUFLLFNBQVMsSUFBSTttQkFDVCxPQUFPLFlBQWE7QUFFN0IsZUFBSyxRQUFRLEdBQUk7QUFDakIsZUFBSyxTQUFTLElBQUk7ZUFDYjtBQUNMLGdCQUFNLElBQUksTUFBTSxxQkFBcUIsTUFBTTs7QUFFN0MsY0FBTSxTQUFRLEdBQUEsY0FBQSxrQkFBaUIsTUFBTTtBQUNyQyxhQUFLLFNBQVMsS0FBSztNQUNyQjtNQUVRLFlBQVksUUFBd0IsT0FBYTtBQUN2RCxjQUFNLE9BQU8sT0FBTztBQUNwQixZQUFJLE9BQU8sSUFBSTtBQUViLGVBQUssUUFBUSxNQUFPLElBQUk7bUJBQ2YsT0FBTyxPQUFTO0FBRXpCLGVBQUssUUFBUSxHQUFJO0FBQ2pCLGVBQUssU0FBUyxJQUFJO21CQUNULE9BQU8sWUFBYTtBQUU3QixlQUFLLFFBQVEsR0FBSTtBQUNqQixlQUFLLFNBQVMsSUFBSTtlQUNiO0FBQ0wsZ0JBQU0sSUFBSSxNQUFNLG9CQUFvQixNQUFNOztBQUU1QyxtQkFBVyxRQUFRLFFBQVE7QUFDekIsZUFBSyxTQUFTLE1BQU0sUUFBUSxDQUFDOztNQUVqQztNQUVRLHNCQUFzQixRQUFpQyxNQUEyQjtBQUN4RixZQUFJLFFBQVE7QUFFWixtQkFBVyxPQUFPLE1BQU07QUFDdEIsY0FBSSxPQUFPLEdBQUcsTUFBTSxRQUFXO0FBQzdCOzs7QUFJSixlQUFPO01BQ1Q7TUFFUSxVQUFVLFFBQWlDLE9BQWE7QUFDOUQsY0FBTSxPQUFPLE9BQU8sS0FBSyxNQUFNO0FBQy9CLFlBQUksS0FBSyxVQUFVO0FBQ2pCLGVBQUssS0FBSTs7QUFHWCxjQUFNLE9BQU8sS0FBSyxrQkFBa0IsS0FBSyxzQkFBc0IsUUFBUSxJQUFJLElBQUksS0FBSztBQUVwRixZQUFJLE9BQU8sSUFBSTtBQUViLGVBQUssUUFBUSxNQUFPLElBQUk7bUJBQ2YsT0FBTyxPQUFTO0FBRXpCLGVBQUssUUFBUSxHQUFJO0FBQ2pCLGVBQUssU0FBUyxJQUFJO21CQUNULE9BQU8sWUFBYTtBQUU3QixlQUFLLFFBQVEsR0FBSTtBQUNqQixlQUFLLFNBQVMsSUFBSTtlQUNiO0FBQ0wsZ0JBQU0sSUFBSSxNQUFNLHlCQUF5QixNQUFNOztBQUdqRCxtQkFBVyxPQUFPLE1BQU07QUFDdEIsZ0JBQU0sUUFBUSxPQUFPLEdBQUc7QUFFeEIsY0FBSSxFQUFFLEtBQUssbUJBQW1CLFVBQVUsU0FBWTtBQUNsRCxpQkFBSyxhQUFhLEdBQUc7QUFDckIsaUJBQUssU0FBUyxPQUFPLFFBQVEsQ0FBQzs7O01BR3BDO01BRVEsZ0JBQWdCLEtBQVk7QUFDbEMsY0FBTSxPQUFPLElBQUksS0FBSztBQUN0QixZQUFJLFNBQVMsR0FBRztBQUVkLGVBQUssUUFBUSxHQUFJO21CQUNSLFNBQVMsR0FBRztBQUVyQixlQUFLLFFBQVEsR0FBSTttQkFDUixTQUFTLEdBQUc7QUFFckIsZUFBSyxRQUFRLEdBQUk7bUJBQ1IsU0FBUyxHQUFHO0FBRXJCLGVBQUssUUFBUSxHQUFJO21CQUNSLFNBQVMsSUFBSTtBQUV0QixlQUFLLFFBQVEsR0FBSTttQkFDUixPQUFPLEtBQU87QUFFdkIsZUFBSyxRQUFRLEdBQUk7QUFDakIsZUFBSyxRQUFRLElBQUk7bUJBQ1IsT0FBTyxPQUFTO0FBRXpCLGVBQUssUUFBUSxHQUFJO0FBQ2pCLGVBQUssU0FBUyxJQUFJO21CQUNULE9BQU8sWUFBYTtBQUU3QixlQUFLLFFBQVEsR0FBSTtBQUNqQixlQUFLLFNBQVMsSUFBSTtlQUNiO0FBQ0wsZ0JBQU0sSUFBSSxNQUFNLCtCQUErQixNQUFNOztBQUV2RCxhQUFLLFFBQVEsSUFBSSxJQUFJO0FBQ3JCLGFBQUssU0FBUyxJQUFJLElBQUk7TUFDeEI7TUFFUSxRQUFRLE9BQWE7QUFDM0IsYUFBSyx3QkFBd0IsQ0FBQztBQUU5QixhQUFLLEtBQUssU0FBUyxLQUFLLEtBQUssS0FBSztBQUNsQyxhQUFLO01BQ1A7TUFFUSxTQUFTLFFBQXlCO0FBQ3hDLGNBQU0sT0FBTyxPQUFPO0FBQ3BCLGFBQUssd0JBQXdCLElBQUk7QUFFakMsYUFBSyxNQUFNLElBQUksUUFBUSxLQUFLLEdBQUc7QUFDL0IsYUFBSyxPQUFPO01BQ2Q7TUFFUSxRQUFRLE9BQWE7QUFDM0IsYUFBSyx3QkFBd0IsQ0FBQztBQUU5QixhQUFLLEtBQUssUUFBUSxLQUFLLEtBQUssS0FBSztBQUNqQyxhQUFLO01BQ1A7TUFFUSxTQUFTLE9BQWE7QUFDNUIsYUFBSyx3QkFBd0IsQ0FBQztBQUU5QixhQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssS0FBSztBQUNuQyxhQUFLLE9BQU87TUFDZDtNQUVRLFNBQVMsT0FBYTtBQUM1QixhQUFLLHdCQUF3QixDQUFDO0FBRTlCLGFBQUssS0FBSyxTQUFTLEtBQUssS0FBSyxLQUFLO0FBQ2xDLGFBQUssT0FBTztNQUNkO01BRVEsU0FBUyxPQUFhO0FBQzVCLGFBQUssd0JBQXdCLENBQUM7QUFFOUIsYUFBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLEtBQUs7QUFDbkMsYUFBSyxPQUFPO01BQ2Q7TUFFUSxTQUFTLE9BQWE7QUFDNUIsYUFBSyx3QkFBd0IsQ0FBQztBQUU5QixhQUFLLEtBQUssU0FBUyxLQUFLLEtBQUssS0FBSztBQUNsQyxhQUFLLE9BQU87TUFDZDtNQUVRLFNBQVMsT0FBYTtBQUM1QixhQUFLLHdCQUF3QixDQUFDO0FBQzlCLGFBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLO0FBQ3BDLGFBQUssT0FBTztNQUNkO01BRVEsU0FBUyxPQUFhO0FBQzVCLGFBQUssd0JBQXdCLENBQUM7QUFDOUIsYUFBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUs7QUFDcEMsYUFBSyxPQUFPO01BQ2Q7TUFFUSxTQUFTLE9BQWE7QUFDNUIsYUFBSyx3QkFBd0IsQ0FBQztBQUU5QixTQUFBLEdBQUEsTUFBQSxXQUFVLEtBQUssTUFBTSxLQUFLLEtBQUssS0FBSztBQUNwQyxhQUFLLE9BQU87TUFDZDtNQUVRLFNBQVMsT0FBYTtBQUM1QixhQUFLLHdCQUF3QixDQUFDO0FBRTlCLFNBQUEsR0FBQSxNQUFBLFVBQVMsS0FBSyxNQUFNLEtBQUssS0FBSyxLQUFLO0FBQ25DLGFBQUssT0FBTztNQUNkOztBQWpaRixZQUFBLFVBQUE7Ozs7Ozs7Ozs7QUNUQSxRQUFBLFlBQUE7QUF5REEsUUFBTSx1QkFBc0MsQ0FBQTtBQVE1QyxhQUFnQixPQUNkLE9BQ0EsVUFBc0Qsc0JBQTJCO0FBRWpGLFlBQU0sVUFBVSxJQUFJLFVBQUEsUUFDbEIsUUFBUSxnQkFDUCxRQUE4QyxTQUMvQyxRQUFRLFVBQ1IsUUFBUSxtQkFDUixRQUFRLFVBQ1IsUUFBUSxjQUNSLFFBQVEsaUJBQ1IsUUFBUSxtQkFBbUI7QUFFN0IsYUFBTyxRQUFRLGdCQUFnQixLQUFLO0lBQ3RDO0FBZkEsWUFBQSxTQUFBOzs7Ozs7Ozs7O0FDakVBLGFBQWdCLFdBQVcsTUFBWTtBQUNyQyxhQUFPLEdBQUcsT0FBTyxJQUFJLE1BQU0sT0FBTyxLQUFLLElBQUksSUFBSSxFQUFFLFNBQVMsRUFBRSxFQUFFLFNBQVMsR0FBRyxHQUFHO0lBQy9FO0FBRkEsWUFBQSxhQUFBOzs7Ozs7Ozs7O0FDQUEsUUFBQSxTQUFBO0FBRUEsUUFBTSx5QkFBeUI7QUFDL0IsUUFBTSw2QkFBNkI7QUFXbkMsUUFBYSxtQkFBYixNQUE2QjtNQUszQixZQUFxQixlQUFlLHdCQUFpQyxrQkFBa0IsNEJBQTBCO0FBQTVGLGFBQUEsZUFBQTtBQUFnRCxhQUFBLGtCQUFBO0FBSnJFLGFBQUEsTUFBTTtBQUNOLGFBQUEsT0FBTztBQU1MLGFBQUssU0FBUyxDQUFBO0FBQ2QsaUJBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxjQUFjLEtBQUs7QUFDMUMsZUFBSyxPQUFPLEtBQUssQ0FBQSxDQUFFOztNQUV2QjtNQUVPLFlBQVksWUFBa0I7QUFDbkMsZUFBTyxhQUFhLEtBQUssY0FBYyxLQUFLO01BQzlDO01BRVEsS0FBSyxPQUFtQixhQUFxQixZQUFrQjtBQUNyRSxjQUFNLFVBQVUsS0FBSyxPQUFPLGFBQWEsQ0FBQztBQUUxQztBQUFZLHFCQUFXLFVBQVUsU0FBUztBQUN4QyxrQkFBTSxjQUFjLE9BQU87QUFFM0IscUJBQVMsSUFBSSxHQUFHLElBQUksWUFBWSxLQUFLO0FBQ25DLGtCQUFJLFlBQVksQ0FBQyxNQUFNLE1BQU0sY0FBYyxDQUFDLEdBQUc7QUFDN0MseUJBQVM7OztBQUdiLG1CQUFPLE9BQU87O0FBRWhCLGVBQU87TUFDVDtNQUVRLE1BQU0sT0FBbUIsT0FBYTtBQUM1QyxjQUFNLFVBQVUsS0FBSyxPQUFPLE1BQU0sU0FBUyxDQUFDO0FBQzVDLGNBQU0sU0FBeUIsRUFBRSxPQUFPLEtBQUssTUFBSztBQUVsRCxZQUFJLFFBQVEsVUFBVSxLQUFLLGlCQUFpQjtBQUcxQyxrQkFBUyxLQUFLLE9BQU0sSUFBSyxRQUFRLFNBQVUsQ0FBQyxJQUFJO2VBQzNDO0FBQ0wsa0JBQVEsS0FBSyxNQUFNOztNQUV2QjtNQUVPLE9BQU8sT0FBbUIsYUFBcUIsWUFBa0I7QUFDdEUsY0FBTSxjQUFjLEtBQUssS0FBSyxPQUFPLGFBQWEsVUFBVTtBQUM1RCxZQUFJLGVBQWUsTUFBTTtBQUN2QixlQUFLO0FBQ0wsaUJBQU87O0FBRVQsYUFBSztBQUVMLGNBQU0sT0FBTSxHQUFBLE9BQUEsY0FBYSxPQUFPLGFBQWEsVUFBVTtBQUV2RCxjQUFNLG9CQUFvQixXQUFXLFVBQVUsTUFBTSxLQUFLLE9BQU8sYUFBYSxjQUFjLFVBQVU7QUFDdEcsYUFBSyxNQUFNLG1CQUFtQixHQUFHO0FBQ2pDLGVBQU87TUFDVDs7QUE1REYsWUFBQSxtQkFBQTs7Ozs7Ozs7OztBQ2RBLFFBQUEsZUFBQTtBQUNBLFFBQUEsbUJBQUE7QUFDQSxRQUFBLFFBQUE7QUFDQSxRQUFBLFNBQUE7QUFDQSxRQUFBLGdCQUFBO0FBQ0EsUUFBQSxxQkFBQTtBQUNBLFFBQUEsZ0JBQUE7QUFVQSxRQUFNLG9CQUFvQixDQUFDLFFBQW1DO0FBQzVELFlBQU0sVUFBVSxPQUFPO0FBRXZCLGFBQU8sWUFBWSxZQUFZLFlBQVk7SUFDN0M7QUFtQkEsUUFBTSxxQkFBcUI7QUFFM0IsUUFBTSxhQUFhLElBQUksU0FBUyxJQUFJLFlBQVksQ0FBQyxDQUFDO0FBQ2xELFFBQU0sY0FBYyxJQUFJLFdBQVcsV0FBVyxNQUFNO0FBSXZDLFlBQUEsaUNBQStDLE1BQUs7QUFDL0QsVUFBSTtBQUdGLG1CQUFXLFFBQVEsQ0FBQztlQUNiLEdBQVA7QUFDQSxlQUFPLEVBQUU7O0FBRVgsWUFBTSxJQUFJLE1BQU0sZUFBZTtJQUNqQyxHQUFFO0FBRUYsUUFBTSxZQUFZLElBQUksUUFBQSw4QkFBOEIsbUJBQW1CO0FBRXZFLFFBQU0seUJBQXlCLElBQUksbUJBQUEsaUJBQWdCO0FBRW5ELFFBQWEsVUFBYixNQUFvQjtNQVNsQixZQUNtQixpQkFBa0QsaUJBQUEsZUFBZSxjQUNqRSxVQUF1QixRQUN2QixlQUFlLE1BQUEsWUFDZixlQUFlLE1BQUEsWUFDZixpQkFBaUIsTUFBQSxZQUNqQixlQUFlLE1BQUEsWUFDZixlQUFlLE1BQUEsWUFDZixhQUFnQyx3QkFBc0I7QUFQdEQsYUFBQSxpQkFBQTtBQUNBLGFBQUEsVUFBQTtBQUNBLGFBQUEsZUFBQTtBQUNBLGFBQUEsZUFBQTtBQUNBLGFBQUEsaUJBQUE7QUFDQSxhQUFBLGVBQUE7QUFDQSxhQUFBLGVBQUE7QUFDQSxhQUFBLGFBQUE7QUFoQlgsYUFBQSxXQUFXO0FBQ1gsYUFBQSxNQUFNO0FBRU4sYUFBQSxPQUFPO0FBQ1AsYUFBQSxRQUFRO0FBQ1IsYUFBQSxXQUFXO0FBQ0YsYUFBQSxRQUEyQixDQUFBO01BV3pDO01BRUssb0JBQWlCO0FBQ3ZCLGFBQUssV0FBVztBQUNoQixhQUFLLFdBQVc7QUFDaEIsYUFBSyxNQUFNLFNBQVM7TUFHdEI7TUFFUSxVQUFVLFFBQXdDO0FBQ3hELGFBQUssU0FBUSxHQUFBLGNBQUEsa0JBQWlCLE1BQU07QUFDcEMsYUFBSyxRQUFPLEdBQUEsY0FBQSxnQkFBZSxLQUFLLEtBQUs7QUFDckMsYUFBSyxNQUFNO01BQ2I7TUFFUSxhQUFhLFFBQXdDO0FBQzNELFlBQUksS0FBSyxhQUFhLHNCQUFzQixDQUFDLEtBQUssYUFBYSxDQUFDLEdBQUc7QUFDakUsZUFBSyxVQUFVLE1BQU07ZUFDaEI7QUFDTCxnQkFBTSxnQkFBZ0IsS0FBSyxNQUFNLFNBQVMsS0FBSyxHQUFHO0FBQ2xELGdCQUFNLFdBQVUsR0FBQSxjQUFBLGtCQUFpQixNQUFNO0FBR3ZDLGdCQUFNLFlBQVksSUFBSSxXQUFXLGNBQWMsU0FBUyxRQUFRLE1BQU07QUFDdEUsb0JBQVUsSUFBSSxhQUFhO0FBQzNCLG9CQUFVLElBQUksU0FBUyxjQUFjLE1BQU07QUFDM0MsZUFBSyxVQUFVLFNBQVM7O01BRTVCO01BRVEsYUFBYSxNQUFZO0FBQy9CLGVBQU8sS0FBSyxLQUFLLGFBQWEsS0FBSyxPQUFPO01BQzVDO01BRVEscUJBQXFCLFdBQWlCO0FBQzVDLGNBQU0sRUFBRSxNQUFNLElBQUcsSUFBSztBQUN0QixlQUFPLElBQUksV0FBVyxTQUFTLEtBQUssYUFBYSxVQUFVLEtBQUssc0NBQXNDLFlBQVk7TUFDcEg7Ozs7O01BTU8sT0FBTyxRQUF3QztBQUNwRCxhQUFLLGtCQUFpQjtBQUN0QixhQUFLLFVBQVUsTUFBTTtBQUVyQixjQUFNLFNBQVMsS0FBSyxhQUFZO0FBQ2hDLFlBQUksS0FBSyxhQUFhLENBQUMsR0FBRztBQUN4QixnQkFBTSxLQUFLLHFCQUFxQixLQUFLLEdBQUc7O0FBRTFDLGVBQU87TUFDVDtNQUVPLENBQUMsWUFBWSxRQUF3QztBQUMxRCxhQUFLLGtCQUFpQjtBQUN0QixhQUFLLFVBQVUsTUFBTTtBQUVyQixlQUFPLEtBQUssYUFBYSxDQUFDLEdBQUc7QUFDM0IsZ0JBQU0sS0FBSyxhQUFZOztNQUUzQjtNQUVPLE1BQU0sWUFBWSxRQUF1RDtBQUM5RSxZQUFJLFVBQVU7QUFDZCxZQUFJO0FBQ0oseUJBQWlCLFVBQVUsUUFBUTtBQUNqQyxjQUFJLFNBQVM7QUFDWCxrQkFBTSxLQUFLLHFCQUFxQixLQUFLLFFBQVE7O0FBRy9DLGVBQUssYUFBYSxNQUFNO0FBRXhCLGNBQUk7QUFDRixxQkFBUyxLQUFLLGFBQVk7QUFDMUIsc0JBQVU7bUJBQ0gsR0FBUDtBQUNBLGdCQUFJLEVBQUUsYUFBYSxRQUFBLGdDQUFnQztBQUNqRCxvQkFBTTs7O0FBSVYsZUFBSyxZQUFZLEtBQUs7O0FBR3hCLFlBQUksU0FBUztBQUNYLGNBQUksS0FBSyxhQUFhLENBQUMsR0FBRztBQUN4QixrQkFBTSxLQUFLLHFCQUFxQixLQUFLLFFBQVE7O0FBRS9DLGlCQUFPOztBQUdULGNBQU0sRUFBRSxVQUFVLEtBQUssU0FBUSxJQUFLO0FBQ3BDLGNBQU0sSUFBSSxXQUNSLGlDQUFnQyxHQUFBLGFBQUEsWUFBVyxRQUFRLFFBQVEsYUFBYSw0QkFBNEI7TUFFeEc7TUFFTyxrQkFDTCxRQUF1RDtBQUV2RCxlQUFPLEtBQUssaUJBQWlCLFFBQVEsSUFBSTtNQUMzQztNQUVPLGFBQWEsUUFBdUQ7QUFDekUsZUFBTyxLQUFLLGlCQUFpQixRQUFRLEtBQUs7TUFDNUM7TUFFUSxPQUFPLGlCQUFpQixRQUF5RCxTQUFnQjtBQUN2RyxZQUFJLHdCQUF3QjtBQUM1QixZQUFJLGlCQUFpQjtBQUVyQix5QkFBaUIsVUFBVSxRQUFRO0FBQ2pDLGNBQUksV0FBVyxtQkFBbUIsR0FBRztBQUNuQyxrQkFBTSxLQUFLLHFCQUFxQixLQUFLLFFBQVE7O0FBRy9DLGVBQUssYUFBYSxNQUFNO0FBRXhCLGNBQUksdUJBQXVCO0FBQ3pCLDZCQUFpQixLQUFLLGNBQWE7QUFDbkMsb0NBQXdCO0FBQ3hCLGlCQUFLLFNBQVE7O0FBR2YsY0FBSTtBQUNGLG1CQUFPLE1BQU07QUFDWCxvQkFBTSxLQUFLLGFBQVk7QUFDdkIsa0JBQUksRUFBRSxtQkFBbUIsR0FBRztBQUMxQjs7O21CQUdHLEdBQVA7QUFDQSxnQkFBSSxFQUFFLGFBQWEsUUFBQSxnQ0FBZ0M7QUFDakQsb0JBQU07OztBQUlWLGVBQUssWUFBWSxLQUFLOztNQUUxQjtNQUVRLGVBQVk7QUFDbEI7QUFBUSxpQkFBTyxNQUFNO0FBQ25CLGtCQUFNLFdBQVcsS0FBSyxhQUFZO0FBQ2xDLGdCQUFJO0FBRUosZ0JBQUksWUFBWSxLQUFNO0FBRXBCLHVCQUFTLFdBQVc7dUJBQ1gsV0FBVyxLQUFNO0FBQzFCLGtCQUFJLFdBQVcsS0FBTTtBQUVuQix5QkFBUzt5QkFDQSxXQUFXLEtBQU07QUFFMUIsc0JBQU0sT0FBTyxXQUFXO0FBQ3hCLG9CQUFJLFNBQVMsR0FBRztBQUNkLHVCQUFLLGFBQWEsSUFBSTtBQUN0Qix1QkFBSyxTQUFRO0FBQ2IsMkJBQVM7dUJBQ0o7QUFDTCwyQkFBUyxDQUFBOzt5QkFFRixXQUFXLEtBQU07QUFFMUIsc0JBQU0sT0FBTyxXQUFXO0FBQ3hCLG9CQUFJLFNBQVMsR0FBRztBQUNkLHVCQUFLLGVBQWUsSUFBSTtBQUN4Qix1QkFBSyxTQUFRO0FBQ2IsMkJBQVM7dUJBQ0o7QUFDTCwyQkFBUyxDQUFBOztxQkFFTjtBQUVMLHNCQUFNLGFBQWEsV0FBVztBQUM5Qix5QkFBUyxLQUFLLGlCQUFpQixZQUFZLENBQUM7O3VCQUVyQyxhQUFhLEtBQU07QUFFNUIsdUJBQVM7dUJBQ0EsYUFBYSxLQUFNO0FBRTVCLHVCQUFTO3VCQUNBLGFBQWEsS0FBTTtBQUU1Qix1QkFBUzt1QkFDQSxhQUFhLEtBQU07QUFFNUIsdUJBQVMsS0FBSyxRQUFPO3VCQUNaLGFBQWEsS0FBTTtBQUU1Qix1QkFBUyxLQUFLLFFBQU87dUJBQ1osYUFBYSxLQUFNO0FBRTVCLHVCQUFTLEtBQUssT0FBTTt1QkFDWCxhQUFhLEtBQU07QUFFNUIsdUJBQVMsS0FBSyxRQUFPO3VCQUNaLGFBQWEsS0FBTTtBQUU1Qix1QkFBUyxLQUFLLFFBQU87dUJBQ1osYUFBYSxLQUFNO0FBRTVCLHVCQUFTLEtBQUssUUFBTzt1QkFDWixhQUFhLEtBQU07QUFFNUIsdUJBQVMsS0FBSyxPQUFNO3VCQUNYLGFBQWEsS0FBTTtBQUU1Qix1QkFBUyxLQUFLLFFBQU87dUJBQ1osYUFBYSxLQUFNO0FBRTVCLHVCQUFTLEtBQUssUUFBTzt1QkFDWixhQUFhLEtBQU07QUFFNUIsdUJBQVMsS0FBSyxRQUFPO3VCQUNaLGFBQWEsS0FBTTtBQUU1QixvQkFBTSxhQUFhLEtBQUssT0FBTTtBQUM5Qix1QkFBUyxLQUFLLGlCQUFpQixZQUFZLENBQUM7dUJBQ25DLGFBQWEsS0FBTTtBQUU1QixvQkFBTSxhQUFhLEtBQUssUUFBTztBQUMvQix1QkFBUyxLQUFLLGlCQUFpQixZQUFZLENBQUM7dUJBQ25DLGFBQWEsS0FBTTtBQUU1QixvQkFBTSxhQUFhLEtBQUssUUFBTztBQUMvQix1QkFBUyxLQUFLLGlCQUFpQixZQUFZLENBQUM7dUJBQ25DLGFBQWEsS0FBTTtBQUU1QixvQkFBTSxPQUFPLEtBQUssUUFBTztBQUN6QixrQkFBSSxTQUFTLEdBQUc7QUFDZCxxQkFBSyxlQUFlLElBQUk7QUFDeEIscUJBQUssU0FBUTtBQUNiLHlCQUFTO3FCQUNKO0FBQ0wseUJBQVMsQ0FBQTs7dUJBRUYsYUFBYSxLQUFNO0FBRTVCLG9CQUFNLE9BQU8sS0FBSyxRQUFPO0FBQ3pCLGtCQUFJLFNBQVMsR0FBRztBQUNkLHFCQUFLLGVBQWUsSUFBSTtBQUN4QixxQkFBSyxTQUFRO0FBQ2IseUJBQVM7cUJBQ0o7QUFDTCx5QkFBUyxDQUFBOzt1QkFFRixhQUFhLEtBQU07QUFFNUIsb0JBQU0sT0FBTyxLQUFLLFFBQU87QUFDekIsa0JBQUksU0FBUyxHQUFHO0FBQ2QscUJBQUssYUFBYSxJQUFJO0FBQ3RCLHFCQUFLLFNBQVE7QUFDYix5QkFBUztxQkFDSjtBQUNMLHlCQUFTLENBQUE7O3VCQUVGLGFBQWEsS0FBTTtBQUU1QixvQkFBTSxPQUFPLEtBQUssUUFBTztBQUN6QixrQkFBSSxTQUFTLEdBQUc7QUFDZCxxQkFBSyxhQUFhLElBQUk7QUFDdEIscUJBQUssU0FBUTtBQUNiLHlCQUFTO3FCQUNKO0FBQ0wseUJBQVMsQ0FBQTs7dUJBRUYsYUFBYSxLQUFNO0FBRTVCLG9CQUFNLE9BQU8sS0FBSyxPQUFNO0FBQ3hCLHVCQUFTLEtBQUssYUFBYSxNQUFNLENBQUM7dUJBQ3pCLGFBQWEsS0FBTTtBQUU1QixvQkFBTSxPQUFPLEtBQUssUUFBTztBQUN6Qix1QkFBUyxLQUFLLGFBQWEsTUFBTSxDQUFDO3VCQUN6QixhQUFhLEtBQU07QUFFNUIsb0JBQU0sT0FBTyxLQUFLLFFBQU87QUFDekIsdUJBQVMsS0FBSyxhQUFhLE1BQU0sQ0FBQzt1QkFDekIsYUFBYSxLQUFNO0FBRTVCLHVCQUFTLEtBQUssZ0JBQWdCLEdBQUcsQ0FBQzt1QkFDekIsYUFBYSxLQUFNO0FBRTVCLHVCQUFTLEtBQUssZ0JBQWdCLEdBQUcsQ0FBQzt1QkFDekIsYUFBYSxLQUFNO0FBRTVCLHVCQUFTLEtBQUssZ0JBQWdCLEdBQUcsQ0FBQzt1QkFDekIsYUFBYSxLQUFNO0FBRTVCLHVCQUFTLEtBQUssZ0JBQWdCLEdBQUcsQ0FBQzt1QkFDekIsYUFBYSxLQUFNO0FBRTVCLHVCQUFTLEtBQUssZ0JBQWdCLElBQUksQ0FBQzt1QkFDMUIsYUFBYSxLQUFNO0FBRTVCLG9CQUFNLE9BQU8sS0FBSyxPQUFNO0FBQ3hCLHVCQUFTLEtBQUssZ0JBQWdCLE1BQU0sQ0FBQzt1QkFDNUIsYUFBYSxLQUFNO0FBRTVCLG9CQUFNLE9BQU8sS0FBSyxRQUFPO0FBQ3pCLHVCQUFTLEtBQUssZ0JBQWdCLE1BQU0sQ0FBQzt1QkFDNUIsYUFBYSxLQUFNO0FBRTVCLG9CQUFNLE9BQU8sS0FBSyxRQUFPO0FBQ3pCLHVCQUFTLEtBQUssZ0JBQWdCLE1BQU0sQ0FBQzttQkFDaEM7QUFDTCxvQkFBTSxJQUFJLGNBQUEsWUFBWSw0QkFBMkIsR0FBQSxhQUFBLFlBQVcsUUFBUSxHQUFHOztBQUd6RSxpQkFBSyxTQUFRO0FBRWIsa0JBQU0sUUFBUSxLQUFLO0FBQ25CLG1CQUFPLE1BQU0sU0FBUyxHQUFHO0FBRXZCLG9CQUFNLFFBQVEsTUFBTSxNQUFNLFNBQVMsQ0FBQztBQUNwQyxrQkFBSSxNQUFNLFNBQUksR0FBa0I7QUFDOUIsc0JBQU0sTUFBTSxNQUFNLFFBQVEsSUFBSTtBQUM5QixzQkFBTTtBQUNOLG9CQUFJLE1BQU0sYUFBYSxNQUFNLE1BQU07QUFDakMsd0JBQU0sSUFBRztBQUNULDJCQUFTLE1BQU07dUJBQ1Y7QUFDTCwyQkFBUzs7eUJBRUYsTUFBTSxTQUFJLEdBQW9CO0FBQ3ZDLG9CQUFJLENBQUMsa0JBQWtCLE1BQU0sR0FBRztBQUM5Qix3QkFBTSxJQUFJLGNBQUEsWUFBWSxrREFBa0QsT0FBTyxNQUFNOztBQUV2RixvQkFBSSxXQUFXLGFBQWE7QUFDMUIsd0JBQU0sSUFBSSxjQUFBLFlBQVksa0NBQWtDOztBQUcxRCxzQkFBTSxNQUFNO0FBQ1osc0JBQU0sT0FBSTtBQUNWLHlCQUFTO3FCQUNKO0FBR0wsc0JBQU0sSUFBSSxNQUFNLEdBQUksSUFBSTtBQUN4QixzQkFBTTtBQUVOLG9CQUFJLE1BQU0sY0FBYyxNQUFNLE1BQU07QUFDbEMsd0JBQU0sSUFBRztBQUNULDJCQUFTLE1BQU07dUJBQ1Y7QUFDTCx3QkFBTSxNQUFNO0FBQ1osd0JBQU0sT0FBSTtBQUNWLDJCQUFTOzs7O0FBS2YsbUJBQU87O01BRVg7TUFFUSxlQUFZO0FBQ2xCLFlBQUksS0FBSyxhQUFhLG9CQUFvQjtBQUN4QyxlQUFLLFdBQVcsS0FBSyxPQUFNOztBQUk3QixlQUFPLEtBQUs7TUFDZDtNQUVRLFdBQVE7QUFDZCxhQUFLLFdBQVc7TUFDbEI7TUFFUSxnQkFBYTtBQUNuQixjQUFNLFdBQVcsS0FBSyxhQUFZO0FBRWxDLGdCQUFRLFVBQVU7VUFDaEIsS0FBSztBQUNILG1CQUFPLEtBQUssUUFBTztVQUNyQixLQUFLO0FBQ0gsbUJBQU8sS0FBSyxRQUFPO1VBQ3JCLFNBQVM7QUFDUCxnQkFBSSxXQUFXLEtBQU07QUFDbkIscUJBQU8sV0FBVzttQkFDYjtBQUNMLG9CQUFNLElBQUksY0FBQSxZQUFZLGtDQUFpQyxHQUFBLGFBQUEsWUFBVyxRQUFRLEdBQUc7Ozs7TUFJckY7TUFFUSxhQUFhLE1BQVk7QUFDL0IsWUFBSSxPQUFPLEtBQUssY0FBYztBQUM1QixnQkFBTSxJQUFJLGNBQUEsWUFBWSxvQ0FBb0MsK0JBQStCLEtBQUssZUFBZTs7QUFHL0csYUFBSyxNQUFNLEtBQUs7VUFDZCxNQUFJO1VBQ0o7VUFDQSxLQUFLO1VBQ0wsV0FBVztVQUNYLEtBQUssQ0FBQTtTQUNOO01BQ0g7TUFFUSxlQUFlLE1BQVk7QUFDakMsWUFBSSxPQUFPLEtBQUssZ0JBQWdCO0FBQzlCLGdCQUFNLElBQUksY0FBQSxZQUFZLHNDQUFzQywyQkFBMkIsS0FBSyxpQkFBaUI7O0FBRy9HLGFBQUssTUFBTSxLQUFLO1VBQ2QsTUFBSTtVQUNKO1VBQ0EsT0FBTyxJQUFJLE1BQWUsSUFBSTtVQUM5QixVQUFVO1NBQ1g7TUFDSDtNQUVRLGlCQUFpQixZQUFvQixjQUFvQjs7QUFDL0QsWUFBSSxhQUFhLEtBQUssY0FBYztBQUNsQyxnQkFBTSxJQUFJLGNBQUEsWUFDUiwyQ0FBMkMsK0JBQStCLEtBQUssZUFBZTs7QUFJbEcsWUFBSSxLQUFLLE1BQU0sYUFBYSxLQUFLLE1BQU0sZUFBZSxZQUFZO0FBQ2hFLGdCQUFNOztBQUdSLGNBQU0sU0FBUyxLQUFLLE1BQU07QUFDMUIsWUFBSTtBQUNKLFlBQUksS0FBSyxjQUFhLE9BQU0sS0FBQSxLQUFLLGdCQUFVLFFBQUEsT0FBQSxTQUFBLFNBQUEsR0FBRSxZQUFZLFVBQVUsSUFBRztBQUNwRSxtQkFBUyxLQUFLLFdBQVcsT0FBTyxLQUFLLE9BQU8sUUFBUSxVQUFVO21CQUNyRCxhQUFhLE9BQUEsd0JBQXdCO0FBQzlDLG9CQUFTLEdBQUEsT0FBQSxjQUFhLEtBQUssT0FBTyxRQUFRLFVBQVU7ZUFDL0M7QUFDTCxvQkFBUyxHQUFBLE9BQUEsY0FBYSxLQUFLLE9BQU8sUUFBUSxVQUFVOztBQUV0RCxhQUFLLE9BQU8sZUFBZTtBQUMzQixlQUFPO01BQ1Q7TUFFUSxnQkFBYTtBQUNuQixZQUFJLEtBQUssTUFBTSxTQUFTLEdBQUc7QUFDekIsZ0JBQU0sUUFBUSxLQUFLLE1BQU0sS0FBSyxNQUFNLFNBQVMsQ0FBQztBQUM5QyxpQkFBTyxNQUFNLFNBQUk7O0FBRW5CLGVBQU87TUFDVDtNQUVRLGFBQWEsWUFBb0IsWUFBa0I7QUFDekQsWUFBSSxhQUFhLEtBQUssY0FBYztBQUNsQyxnQkFBTSxJQUFJLGNBQUEsWUFBWSxvQ0FBb0MsK0JBQStCLEtBQUssZUFBZTs7QUFHL0csWUFBSSxDQUFDLEtBQUssYUFBYSxhQUFhLFVBQVUsR0FBRztBQUMvQyxnQkFBTTs7QUFHUixjQUFNLFNBQVMsS0FBSyxNQUFNO0FBQzFCLGNBQU0sU0FBUyxLQUFLLE1BQU0sU0FBUyxRQUFRLFNBQVMsVUFBVTtBQUM5RCxhQUFLLE9BQU8sYUFBYTtBQUN6QixlQUFPO01BQ1Q7TUFFUSxnQkFBZ0IsTUFBYyxZQUFrQjtBQUN0RCxZQUFJLE9BQU8sS0FBSyxjQUFjO0FBQzVCLGdCQUFNLElBQUksY0FBQSxZQUFZLG9DQUFvQyx5QkFBeUIsS0FBSyxlQUFlOztBQUd6RyxjQUFNLFVBQVUsS0FBSyxLQUFLLFFBQVEsS0FBSyxNQUFNLFVBQVU7QUFDdkQsY0FBTSxPQUFPLEtBQUs7VUFBYTtVQUFNLGFBQWE7O1FBQWU7QUFDakUsZUFBTyxLQUFLLGVBQWUsT0FBTyxNQUFNLFNBQVMsS0FBSyxPQUFPO01BQy9EO01BRVEsU0FBTTtBQUNaLGVBQU8sS0FBSyxLQUFLLFNBQVMsS0FBSyxHQUFHO01BQ3BDO01BRVEsVUFBTztBQUNiLGVBQU8sS0FBSyxLQUFLLFVBQVUsS0FBSyxHQUFHO01BQ3JDO01BRVEsVUFBTztBQUNiLGVBQU8sS0FBSyxLQUFLLFVBQVUsS0FBSyxHQUFHO01BQ3JDO01BRVEsU0FBTTtBQUNaLGNBQU0sUUFBUSxLQUFLLEtBQUssU0FBUyxLQUFLLEdBQUc7QUFDekMsYUFBSztBQUNMLGVBQU87TUFDVDtNQUVRLFNBQU07QUFDWixjQUFNLFFBQVEsS0FBSyxLQUFLLFFBQVEsS0FBSyxHQUFHO0FBQ3hDLGFBQUs7QUFDTCxlQUFPO01BQ1Q7TUFFUSxVQUFPO0FBQ2IsY0FBTSxRQUFRLEtBQUssS0FBSyxVQUFVLEtBQUssR0FBRztBQUMxQyxhQUFLLE9BQU87QUFDWixlQUFPO01BQ1Q7TUFFUSxVQUFPO0FBQ2IsY0FBTSxRQUFRLEtBQUssS0FBSyxTQUFTLEtBQUssR0FBRztBQUN6QyxhQUFLLE9BQU87QUFDWixlQUFPO01BQ1Q7TUFFUSxVQUFPO0FBQ2IsY0FBTSxRQUFRLEtBQUssS0FBSyxVQUFVLEtBQUssR0FBRztBQUMxQyxhQUFLLE9BQU87QUFDWixlQUFPO01BQ1Q7TUFFUSxVQUFPO0FBQ2IsY0FBTSxRQUFRLEtBQUssS0FBSyxTQUFTLEtBQUssR0FBRztBQUN6QyxhQUFLLE9BQU87QUFDWixlQUFPO01BQ1Q7TUFFUSxVQUFPO0FBQ2IsY0FBTSxTQUFRLEdBQUEsTUFBQSxXQUFVLEtBQUssTUFBTSxLQUFLLEdBQUc7QUFDM0MsYUFBSyxPQUFPO0FBQ1osZUFBTztNQUNUO01BRVEsVUFBTztBQUNiLGNBQU0sU0FBUSxHQUFBLE1BQUEsVUFBUyxLQUFLLE1BQU0sS0FBSyxHQUFHO0FBQzFDLGFBQUssT0FBTztBQUNaLGVBQU87TUFDVDtNQUVRLFVBQU87QUFDYixjQUFNLFFBQVEsS0FBSyxLQUFLLFdBQVcsS0FBSyxHQUFHO0FBQzNDLGFBQUssT0FBTztBQUNaLGVBQU87TUFDVDtNQUVRLFVBQU87QUFDYixjQUFNLFFBQVEsS0FBSyxLQUFLLFdBQVcsS0FBSyxHQUFHO0FBQzNDLGFBQUssT0FBTztBQUNaLGVBQU87TUFDVDs7QUFwakJGLFlBQUEsVUFBQTs7Ozs7Ozs7OztBQzdEQSxRQUFBLFlBQUE7QUEwQ2EsWUFBQSx1QkFBc0MsQ0FBQTtBQVduRCxhQUFnQixPQUNkLFFBQ0EsVUFBc0QsUUFBQSxzQkFBMkI7QUFFakYsWUFBTSxVQUFVLElBQUksVUFBQSxRQUNsQixRQUFRLGdCQUNQLFFBQThDLFNBQy9DLFFBQVEsY0FDUixRQUFRLGNBQ1IsUUFBUSxnQkFDUixRQUFRLGNBQ1IsUUFBUSxZQUFZO0FBRXRCLGFBQU8sUUFBUSxPQUFPLE1BQU07SUFDOUI7QUFkQSxZQUFBLFNBQUE7QUF1QkEsYUFBZ0IsWUFDZCxRQUNBLFVBQXNELFFBQUEsc0JBQTJCO0FBRWpGLFlBQU0sVUFBVSxJQUFJLFVBQUEsUUFDbEIsUUFBUSxnQkFDUCxRQUE4QyxTQUMvQyxRQUFRLGNBQ1IsUUFBUSxjQUNSLFFBQVEsZ0JBQ1IsUUFBUSxjQUNSLFFBQVEsWUFBWTtBQUV0QixhQUFPLFFBQVEsWUFBWSxNQUFNO0lBQ25DO0FBZEEsWUFBQSxjQUFBOzs7Ozs7Ozs7O0FDcEVBLGFBQWdCLGdCQUFtQixRQUE2QjtBQUM5RCxhQUFRLE9BQWUsT0FBTyxhQUFhLEtBQUs7SUFDbEQ7QUFGQSxZQUFBLGtCQUFBO0FBSUEsYUFBUyxjQUFpQixPQUEyQjtBQUNuRCxVQUFJLFNBQVMsTUFBTTtBQUNqQixjQUFNLElBQUksTUFBTSx5REFBeUQ7O0lBRTdFO0FBRU8sb0JBQWdCLHdCQUEyQixRQUF5QjtBQUN6RSxZQUFNLFNBQVMsT0FBTyxVQUFTO0FBRS9CLFVBQUk7QUFDRixlQUFPLE1BQU07QUFDWCxnQkFBTSxFQUFFLE1BQU0sTUFBSyxJQUFLLE1BQU0sT0FBTyxLQUFJO0FBQ3pDLGNBQUksTUFBTTtBQUNSOztBQUVGLHdCQUFjLEtBQUs7QUFDbkIsZ0JBQU07OztBQUdSLGVBQU8sWUFBVzs7SUFFdEI7QUFmQSxZQUFBLDBCQUFBO0FBaUJBLGFBQWdCLG9CQUF1QixZQUFpQztBQUN0RSxVQUFJLGdCQUFnQixVQUFVLEdBQUc7QUFDL0IsZUFBTzthQUNGO0FBQ0wsZUFBTyx3QkFBd0IsVUFBVTs7SUFFN0M7QUFOQSxZQUFBLHNCQUFBOzs7Ozs7Ozs7O0FDbkNBLFFBQUEsWUFBQTtBQUNBLFFBQUEsV0FBQTtBQUNBLFFBQUEsV0FBQTtBQVNRLG1CQUFlLFlBQ3JCLFlBQ0EsVUFBc0QsU0FBQSxzQkFBMkI7QUFFakYsWUFBTSxVQUFTLEdBQUEsU0FBQSxxQkFBb0IsVUFBVTtBQUU3QyxZQUFNLFVBQVUsSUFBSSxVQUFBLFFBQ2xCLFFBQVEsZ0JBQ1AsUUFBOEMsU0FDL0MsUUFBUSxjQUNSLFFBQVEsY0FDUixRQUFRLGdCQUNSLFFBQVEsY0FDUixRQUFRLFlBQVk7QUFFdEIsYUFBTyxRQUFRLFlBQVksTUFBTTtJQUNuQztBQWhCQyxZQUFBLGNBQUE7QUFzQkEsYUFBZ0Isa0JBQ2YsWUFDQSxVQUFzRCxTQUFBLHNCQUEyQjtBQUVqRixZQUFNLFVBQVMsR0FBQSxTQUFBLHFCQUFvQixVQUFVO0FBRTdDLFlBQU0sVUFBVSxJQUFJLFVBQUEsUUFDbEIsUUFBUSxnQkFDUCxRQUE4QyxTQUMvQyxRQUFRLGNBQ1IsUUFBUSxjQUNSLFFBQVEsZ0JBQ1IsUUFBUSxjQUNSLFFBQVEsWUFBWTtBQUd0QixhQUFPLFFBQVEsa0JBQWtCLE1BQU07SUFDekM7QUFqQkMsWUFBQSxvQkFBQTtBQXVCRCxhQUFnQixrQkFDZCxZQUNBLFVBQXNELFNBQUEsc0JBQTJCO0FBRWpGLFlBQU0sVUFBUyxHQUFBLFNBQUEscUJBQW9CLFVBQVU7QUFFN0MsWUFBTSxVQUFVLElBQUksVUFBQSxRQUNsQixRQUFRLGdCQUNQLFFBQThDLFNBQy9DLFFBQVEsY0FDUixRQUFRLGNBQ1IsUUFBUSxnQkFDUixRQUFRLGNBQ1IsUUFBUSxZQUFZO0FBR3RCLGFBQU8sUUFBUSxhQUFhLE1BQU07SUFDcEM7QUFqQkEsWUFBQSxvQkFBQTtBQXNCQSxhQUFnQixhQUNkLFlBQ0EsVUFBc0QsU0FBQSxzQkFBMkI7QUFFakYsYUFBTyxrQkFBa0IsWUFBWSxPQUFPO0lBQzlDO0FBTEEsWUFBQSxlQUFBOzs7Ozs7Ozs7O0FDNUVBLFFBQUEsV0FBQTtBQUNTLFdBQUEsZUFBQSxTQUFBLFVBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFEQSxTQUFBO0lBQU0sRUFBQSxDQUFBO0FBS2YsUUFBQSxXQUFBO0FBQ1MsV0FBQSxlQUFBLFNBQUEsVUFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQURBLFNBQUE7SUFBTSxFQUFBLENBQUE7QUFDRSxXQUFBLGVBQUEsU0FBQSxlQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBREEsU0FBQTtJQUFXLEVBQUEsQ0FBQTtBQUs1QixRQUFBLGdCQUFBO0FBQ1MsV0FBQSxlQUFBLFNBQUEsZUFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQURBLGNBQUE7SUFBVyxFQUFBLENBQUE7QUFDRSxXQUFBLGVBQUEsU0FBQSxxQkFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQURBLGNBQUE7SUFBaUIsRUFBQSxDQUFBO0FBQ0UsV0FBQSxlQUFBLFNBQUEscUJBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFEQSxjQUFBO0lBQWlCLEVBQUEsQ0FBQTtBQUNFLFdBQUEsZUFBQSxTQUFBLGdCQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBREEsY0FBQTtJQUFZLEVBQUEsQ0FBQTtBQUd4RSxRQUFBLFlBQUE7QUFFUyxXQUFBLGVBQUEsU0FBQSxXQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBRkEsVUFBQTtJQUFPLEVBQUEsQ0FBQTtBQUVlLFdBQUEsZUFBQSxTQUFBLGlDQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBRmIsVUFBQTtJQUE2QixFQUFBLENBQUE7QUFDL0MsUUFBQSxnQkFBQTtBQUNrQixXQUFBLGVBQUEsU0FBQSxlQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBRFQsY0FBQTtJQUFXLEVBQUEsQ0FBQTtBQUdwQixRQUFBLFlBQUE7QUFDUyxXQUFBLGVBQUEsU0FBQSxXQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBREEsVUFBQTtJQUFPLEVBQUEsQ0FBQTtBQUtoQixRQUFBLG1CQUFBO0FBQ1MsV0FBQSxlQUFBLFNBQUEsa0JBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFEQSxpQkFBQTtJQUFjLEVBQUEsQ0FBQTtBQUl2QixRQUFBLFlBQUE7QUFDUyxXQUFBLGVBQUEsU0FBQSxXQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBREEsVUFBQTtJQUFPLEVBQUEsQ0FBQTtBQUdoQixRQUFBLGNBQUE7QUFTRSxXQUFBLGVBQUEsU0FBQSxpQkFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQVJBLFlBQUE7SUFBYSxFQUFBLENBQUE7QUFTYixXQUFBLGVBQUEsU0FBQSx3QkFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQVJBLFlBQUE7SUFBb0IsRUFBQSxDQUFBO0FBU3BCLFdBQUEsZUFBQSxTQUFBLDZCQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBUkEsWUFBQTtJQUF5QixFQUFBLENBQUE7QUFTekIsV0FBQSxlQUFBLFNBQUEsNkJBQUEsRUFBQSxZQUFBLE1BQUEsS0FBQSxXQUFBO0FBQUEsYUFSQSxZQUFBO0lBQXlCLEVBQUEsQ0FBQTtBQVN6QixXQUFBLGVBQUEsU0FBQSw0QkFBQSxFQUFBLFlBQUEsTUFBQSxLQUFBLFdBQUE7QUFBQSxhQVJBLFlBQUE7SUFBd0IsRUFBQSxDQUFBO0FBU3hCLFdBQUEsZUFBQSxTQUFBLDRCQUFBLEVBQUEsWUFBQSxNQUFBLEtBQUEsV0FBQTtBQUFBLGFBUkEsWUFBQTtJQUF3QixFQUFBLENBQUE7Ozs7O0FDckMxQjtBQUFBO0FBQUE7QUFDQSxXQUFPLGVBQWUsU0FBUyxjQUFjLEVBQUUsT0FBTyxLQUFLLENBQUM7QUFDNUQsWUFBUSxlQUFlO0FBZXZCLGFBQVMsYUFBYSxLQUFLLFFBQVEsR0FBRyxXQUFXLENBQUMsR0FBRyxjQUFjLFFBQVc7QUFFMUUsVUFBSSxPQUFPLFFBQVEsWUFDZixRQUFRLFFBQ1IsT0FBTyxvQkFBb0IsR0FBRyxFQUFFLFdBQVcsR0FBRztBQUM5QyxlQUFPO0FBQUEsTUFDWDtBQUVBLFlBQU0sWUFBWSxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO0FBQzdDLFVBQUksVUFBVSxHQUFHO0FBQ2IsZUFBTyxlQUFlO0FBQUEsTUFDMUI7QUFFQSxpQkFBVyxPQUFPLE9BQU8sS0FBSyxHQUFHLEdBQUc7QUFDaEMsWUFBSSxTQUFTLFNBQVMsR0FBRyxHQUFHO0FBQ3hCLG9CQUFVLEdBQUcsSUFBSSxnQkFBZ0IsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztBQUFBLFFBQ2hFLFdBQ1MsT0FBTyxVQUFVLGVBQWUsS0FBSyxLQUFLLEdBQUcsR0FBRztBQUNyRCxvQkFBVSxHQUFHLElBQUksYUFBYSxJQUFJLEdBQUcsR0FBRyxRQUFRLEdBQUcsVUFBVSxXQUFXO0FBQUEsUUFDNUU7QUFBQSxNQUNKO0FBQ0EsYUFBTztBQUFBLElBQ1g7QUFDQSxZQUFRLGVBQWU7QUFBQTtBQUFBOzs7QUN4Q3ZCO0FBQUEsNENBQUFBLFNBQUE7QUFBQTtBQU1BLFFBQU0scUJBQU4sY0FBaUMsTUFBTTtBQUFBLE1BQ3JDLFlBQVksVUFBVTtBQUNwQixjQUFNO0FBQUEsU0FDRCxTQUFTLFNBQVMsRUFBRSxNQUFNLElBQUksRUFBRSxDQUFDO0FBQUEsQ0FBSztBQUUzQyxjQUFNLGtCQUFrQixNQUFNLGtCQUFrQjtBQUFBLE1BQ2xEO0FBQUEsSUFDRjtBQU1BLElBQUFBLFFBQU8sVUFBVSxjQUFZO0FBQzNCLFVBQUksU0FBUyxTQUFTLEdBQUc7QUFDdkIsY0FBTSxJQUFJLG1CQUFtQixRQUFRO0FBQUEsTUFDdkM7QUFPQSxlQUFTLE9BQU8sVUFBVSxDQUFDLEdBQUc7QUFDNUIsYUFBSyxVQUFVO0FBQUEsTUFDakI7QUFFQSxhQUFPLFVBQVUsWUFBWTtBQVE3QixlQUFTLGlCQUFpQixNQUFNO0FBQzlCLGVBQU8sSUFBSSxPQUFPLElBQUk7QUFBQSxNQUN4QjtBQU1BLHVCQUFpQixTQUFTO0FBQzFCLGFBQU87QUFBQSxJQUNUO0FBQUE7QUFBQTs7O0FDbkRBO0FBQUEsdURBQUFDLFNBQUE7QUF5QkEsUUFBSSxTQUFTLENBQUM7QUFDZCxJQUFBQSxRQUFPLFNBQVMsSUFBSTtBQUVwQixRQUFJLFFBQVE7QUFBQSxNQUNWLE9BQU8sQ0FBQyxHQUFHLENBQUM7QUFBQSxNQUVaLE1BQU0sQ0FBQyxHQUFHLEVBQUU7QUFBQSxNQUNaLEtBQUssQ0FBQyxHQUFHLEVBQUU7QUFBQSxNQUNYLFFBQVEsQ0FBQyxHQUFHLEVBQUU7QUFBQSxNQUNkLFdBQVcsQ0FBQyxHQUFHLEVBQUU7QUFBQSxNQUNqQixTQUFTLENBQUMsR0FBRyxFQUFFO0FBQUEsTUFDZixRQUFRLENBQUMsR0FBRyxFQUFFO0FBQUEsTUFDZCxlQUFlLENBQUMsR0FBRyxFQUFFO0FBQUEsTUFFckIsT0FBTyxDQUFDLElBQUksRUFBRTtBQUFBLE1BQ2QsS0FBSyxDQUFDLElBQUksRUFBRTtBQUFBLE1BQ1osT0FBTyxDQUFDLElBQUksRUFBRTtBQUFBLE1BQ2QsUUFBUSxDQUFDLElBQUksRUFBRTtBQUFBLE1BQ2YsTUFBTSxDQUFDLElBQUksRUFBRTtBQUFBLE1BQ2IsU0FBUyxDQUFDLElBQUksRUFBRTtBQUFBLE1BQ2hCLE1BQU0sQ0FBQyxJQUFJLEVBQUU7QUFBQSxNQUNiLE9BQU8sQ0FBQyxJQUFJLEVBQUU7QUFBQSxNQUNkLE1BQU0sQ0FBQyxJQUFJLEVBQUU7QUFBQSxNQUNiLE1BQU0sQ0FBQyxJQUFJLEVBQUU7QUFBQSxNQUViLFdBQVcsQ0FBQyxJQUFJLEVBQUU7QUFBQSxNQUNsQixhQUFhLENBQUMsSUFBSSxFQUFFO0FBQUEsTUFDcEIsY0FBYyxDQUFDLElBQUksRUFBRTtBQUFBLE1BQ3JCLFlBQVksQ0FBQyxJQUFJLEVBQUU7QUFBQSxNQUNuQixlQUFlLENBQUMsSUFBSSxFQUFFO0FBQUEsTUFDdEIsWUFBWSxDQUFDLElBQUksRUFBRTtBQUFBLE1BQ25CLGFBQWEsQ0FBQyxJQUFJLEVBQUU7QUFBQSxNQUVwQixTQUFTLENBQUMsSUFBSSxFQUFFO0FBQUEsTUFDaEIsT0FBTyxDQUFDLElBQUksRUFBRTtBQUFBLE1BQ2QsU0FBUyxDQUFDLElBQUksRUFBRTtBQUFBLE1BQ2hCLFVBQVUsQ0FBQyxJQUFJLEVBQUU7QUFBQSxNQUNqQixRQUFRLENBQUMsSUFBSSxFQUFFO0FBQUEsTUFDZixXQUFXLENBQUMsSUFBSSxFQUFFO0FBQUEsTUFDbEIsUUFBUSxDQUFDLElBQUksRUFBRTtBQUFBLE1BQ2YsU0FBUyxDQUFDLElBQUksRUFBRTtBQUFBLE1BQ2hCLFFBQVEsQ0FBQyxLQUFLLEVBQUU7QUFBQSxNQUNoQixRQUFRLENBQUMsS0FBSyxFQUFFO0FBQUEsTUFFaEIsYUFBYSxDQUFDLEtBQUssRUFBRTtBQUFBLE1BQ3JCLGVBQWUsQ0FBQyxLQUFLLEVBQUU7QUFBQSxNQUN2QixnQkFBZ0IsQ0FBQyxLQUFLLEVBQUU7QUFBQSxNQUN4QixjQUFjLENBQUMsS0FBSyxFQUFFO0FBQUEsTUFDdEIsaUJBQWlCLENBQUMsS0FBSyxFQUFFO0FBQUEsTUFDekIsY0FBYyxDQUFDLEtBQUssRUFBRTtBQUFBLE1BQ3RCLGVBQWUsQ0FBQyxLQUFLLEVBQUU7QUFBQTtBQUFBLE1BR3ZCLFNBQVMsQ0FBQyxJQUFJLEVBQUU7QUFBQSxNQUNoQixPQUFPLENBQUMsSUFBSSxFQUFFO0FBQUEsTUFDZCxTQUFTLENBQUMsSUFBSSxFQUFFO0FBQUEsTUFDaEIsVUFBVSxDQUFDLElBQUksRUFBRTtBQUFBLE1BQ2pCLFFBQVEsQ0FBQyxJQUFJLEVBQUU7QUFBQSxNQUNmLFdBQVcsQ0FBQyxJQUFJLEVBQUU7QUFBQSxNQUNsQixRQUFRLENBQUMsSUFBSSxFQUFFO0FBQUEsTUFDZixTQUFTLENBQUMsSUFBSSxFQUFFO0FBQUEsSUFFbEI7QUFFQSxXQUFPLEtBQUssS0FBSyxFQUFFLFFBQVEsU0FBUyxLQUFLO0FBQ3ZDLFVBQUksTUFBTSxNQUFNLEdBQUc7QUFDbkIsVUFBSSxRQUFRLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFDM0IsWUFBTSxPQUFPLFVBQVksSUFBSSxDQUFDLElBQUk7QUFDbEMsWUFBTSxRQUFRLFVBQVksSUFBSSxDQUFDLElBQUk7QUFBQSxJQUNyQyxDQUFDO0FBQUE7QUFBQTs7O0FDOUZEO0FBQUEsZ0VBQUFDLFNBQUE7QUFBQTtBQTBCQSxJQUFBQSxRQUFPLFVBQVUsU0FBUyxNQUFNLE1BQU07QUFDcEMsYUFBTyxRQUFRLFFBQVEsUUFBUSxDQUFDO0FBRWhDLFVBQUksZ0JBQWdCLEtBQUssUUFBUSxJQUFJO0FBQ3JDLFVBQUksU0FBUyxVQUFVLEtBQUssSUFBSSxJQUFJLEtBQUs7QUFDekMsVUFBSSxNQUFNLEtBQUssUUFBUSxTQUFTLElBQUk7QUFFcEMsYUFBTyxRQUFRLE9BQU8sa0JBQWtCLEtBQUssT0FBTyxNQUFNO0FBQUEsSUFDNUQ7QUFBQTtBQUFBOzs7QUNsQ0E7QUFBQSx1RUFBQUMsU0FBQTtBQUFBO0FBMkJBLFFBQUksS0FBSyxRQUFRLElBQUk7QUFDckIsUUFBSSxVQUFVO0FBRWQsUUFBSSxNQUFNLFFBQVE7QUFFbEIsUUFBSSxhQUFhO0FBQ2pCLFFBQUksUUFBUSxVQUFVLEtBQUssUUFBUSxXQUFXLEtBQUssUUFBUSxhQUFhLEdBQUc7QUFDekUsbUJBQWE7QUFBQSxJQUNmLFdBQVcsUUFBUSxPQUFPLEtBQUssUUFBUSxRQUFRLEtBQUssUUFBUSxZQUFZLEtBQzFELFFBQVEsY0FBYyxHQUFHO0FBQ3JDLG1CQUFhO0FBQUEsSUFDZjtBQUNBLFFBQUksaUJBQWlCLEtBQUs7QUFDeEIsbUJBQWEsSUFBSSxZQUFZLFdBQVcsS0FDbkMsU0FBUyxJQUFJLGFBQWEsRUFBRSxNQUFNO0FBQUEsSUFDekM7QUFFQSxhQUFTLGVBQWUsT0FBTztBQUM3QixVQUFJLFVBQVUsR0FBRztBQUNmLGVBQU87QUFBQSxNQUNUO0FBRUEsYUFBTztBQUFBLFFBQ0w7QUFBQSxRQUNBLFVBQVU7QUFBQSxRQUNWLFFBQVEsU0FBUztBQUFBLFFBQ2pCLFFBQVEsU0FBUztBQUFBLE1BQ25CO0FBQUEsSUFDRjtBQUVBLGFBQVMsY0FBYyxRQUFRO0FBQzdCLFVBQUksZUFBZSxPQUFPO0FBQ3hCLGVBQU87QUFBQSxNQUNUO0FBRUEsVUFBSSxRQUFRLFdBQVcsS0FBSyxRQUFRLFlBQVksS0FDekMsUUFBUSxpQkFBaUIsR0FBRztBQUNqQyxlQUFPO0FBQUEsTUFDVDtBQUVBLFVBQUksUUFBUSxXQUFXLEdBQUc7QUFDeEIsZUFBTztBQUFBLE1BQ1Q7QUFFQSxVQUFJLFVBQVUsQ0FBQyxPQUFPLFNBQVMsZUFBZSxNQUFNO0FBQ2xELGVBQU87QUFBQSxNQUNUO0FBRUEsVUFBSSxNQUFNLGFBQWEsSUFBSTtBQUUzQixVQUFJLFFBQVEsYUFBYSxTQUFTO0FBT2hDLFlBQUksWUFBWSxHQUFHLFFBQVEsRUFBRSxNQUFNLEdBQUc7QUFDdEMsWUFBSSxPQUFPLFFBQVEsU0FBUyxLQUFLLE1BQU0sR0FBRyxFQUFFLENBQUMsQ0FBQyxLQUFLLEtBQzVDLE9BQU8sVUFBVSxDQUFDLENBQUMsS0FBSyxNQUFNLE9BQU8sVUFBVSxDQUFDLENBQUMsS0FBSyxPQUFPO0FBQ2xFLGlCQUFPLE9BQU8sVUFBVSxDQUFDLENBQUMsS0FBSyxRQUFRLElBQUk7QUFBQSxRQUM3QztBQUVBLGVBQU87QUFBQSxNQUNUO0FBRUEsVUFBSSxRQUFRLEtBQUs7QUFDZixZQUFJLENBQUMsVUFBVSxZQUFZLFlBQVksV0FBVyxFQUFFLEtBQUssU0FBUyxNQUFNO0FBQ3RFLGlCQUFPLFFBQVE7QUFBQSxRQUNqQixDQUFDLEtBQUssSUFBSSxZQUFZLFlBQVk7QUFDaEMsaUJBQU87QUFBQSxRQUNUO0FBRUEsZUFBTztBQUFBLE1BQ1Q7QUFFQSxVQUFJLHNCQUFzQixLQUFLO0FBQzdCLGVBQVEsZ0NBQWdDLEtBQUssSUFBSSxnQkFBZ0IsSUFBSSxJQUFJO0FBQUEsTUFFM0U7QUFFQSxVQUFJLGtCQUFrQixLQUFLO0FBQ3pCLFlBQUksVUFBVSxVQUFVLElBQUksd0JBQXdCLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUU7QUFFekUsZ0JBQVEsSUFBSSxjQUFjO0FBQUEsVUFDeEIsS0FBSztBQUNILG1CQUFPLFdBQVcsSUFBSSxJQUFJO0FBQUEsVUFDNUIsS0FBSztBQUNILG1CQUFPO0FBQUEsVUFDVCxLQUFLO0FBQ0gsbUJBQU87QUFBQSxRQUVYO0FBQUEsTUFDRjtBQUVBLFVBQUksaUJBQWlCLEtBQUssSUFBSSxJQUFJLEdBQUc7QUFDbkMsZUFBTztBQUFBLE1BQ1Q7QUFFQSxVQUFJLHVEQUF1RCxLQUFLLElBQUksSUFBSSxHQUFHO0FBQ3pFLGVBQU87QUFBQSxNQUNUO0FBRUEsVUFBSSxlQUFlLEtBQUs7QUFDdEIsZUFBTztBQUFBLE1BQ1Q7QUFFQSxVQUFJLElBQUksU0FBUyxRQUFRO0FBQ3ZCLGVBQU87QUFBQSxNQUNUO0FBRUEsYUFBTztBQUFBLElBQ1Q7QUFFQSxhQUFTLGdCQUFnQixRQUFRO0FBQy9CLFVBQUksUUFBUSxjQUFjLE1BQU07QUFDaEMsYUFBTyxlQUFlLEtBQUs7QUFBQSxJQUM3QjtBQUVBLElBQUFBLFFBQU8sVUFBVTtBQUFBLE1BQ2YsZUFBZTtBQUFBLE1BQ2YsUUFBUSxnQkFBZ0IsUUFBUSxNQUFNO0FBQUEsTUFDdEMsUUFBUSxnQkFBZ0IsUUFBUSxNQUFNO0FBQUEsSUFDeEM7QUFBQTtBQUFBOzs7QUN0SkE7QUFBQSw0REFBQUMsU0FBQTtBQUFBLElBQUFBLFFBQU8sU0FBUyxJQUFJLFNBQVMsV0FBVyxNQUFNLFNBQVM7QUFDckQsVUFBSSxTQUFTO0FBQ2IsYUFBTyxRQUFRO0FBQ2YsYUFBTyxLQUFLLE1BQU0sRUFBRTtBQUNwQixVQUFJLE9BQU87QUFBQSxRQUNULEdBQUcsQ0FBQyxLQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxRQUFRO0FBQUEsUUFDeEUsR0FBRyxDQUFDLFFBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxRQUFRO0FBQUEsUUFDOUQsR0FBRyxDQUFDLFFBQVUsVUFBVSxRQUFRO0FBQUEsUUFDaEMsR0FBRyxDQUFDLFFBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxRQUFRO0FBQUEsUUFDOUQsR0FBRztBQUFBLFVBQUM7QUFBQSxVQUFVO0FBQUEsVUFBVTtBQUFBLFVBQVU7QUFBQSxVQUFVO0FBQUEsVUFBVTtBQUFBLFVBQVU7QUFBQSxVQUM5RDtBQUFBLFFBQVE7QUFBQSxRQUNWLEdBQUcsQ0FBQyxRQUFRO0FBQUEsUUFDWixHQUFHLENBQUMsUUFBUTtBQUFBLFFBQ1osR0FBRyxDQUFDLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxRQUFRO0FBQUEsUUFDOUQsR0FBRyxDQUFDLFFBQVE7QUFBQSxRQUNaLEdBQUcsQ0FBQyxRQUFRO0FBQUEsUUFDWixHQUFHLENBQUMsVUFBVSxVQUFVLFVBQVUsUUFBUTtBQUFBLFFBQzFDLEdBQUcsQ0FBQyxRQUFRO0FBQUEsUUFDWixHQUFHLENBQUMsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFFBQVE7QUFBQSxRQUM5RCxHQUFHLENBQUMsUUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFFBQVE7QUFBQSxRQUM5RCxHQUFHO0FBQUEsVUFBQztBQUFBLFVBQVU7QUFBQSxVQUFVO0FBQUEsVUFBVTtBQUFBLFVBQVU7QUFBQSxVQUFVO0FBQUEsVUFBVTtBQUFBLFVBQzlEO0FBQUEsVUFBVTtBQUFBLFFBQVE7QUFBQSxRQUNwQixHQUFHLENBQUMsVUFBVSxRQUFRO0FBQUEsUUFDdEIsR0FBRyxDQUFDLFFBQVE7QUFBQSxRQUNaLEdBQUcsQ0FBQyxRQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsUUFBUTtBQUFBLFFBQzlELEdBQUcsQ0FBQyxRQUFVLFVBQVUsVUFBVSxRQUFRO0FBQUEsUUFDMUMsR0FBRyxDQUFDLFVBQVUsVUFBVSxRQUFRO0FBQUEsUUFDaEMsR0FBRyxDQUFDLFVBQVUsUUFBUTtBQUFBLFFBQ3RCLEdBQUcsQ0FBQyxRQUFRO0FBQUEsUUFDWixHQUFHLENBQUMsVUFBVSxVQUFVLFVBQVUsUUFBUTtBQUFBLFFBQzFDLEdBQUcsQ0FBQyxVQUFVLFVBQVUsVUFBVSxRQUFRO0FBQUEsUUFDMUMsR0FBRyxDQUFDLFFBQVUsVUFBVSxRQUFRO0FBQUEsUUFDaEMsR0FBRyxDQUFDLFVBQVUsUUFBUTtBQUFBLE1BQ3hCO0FBQ0EsV0FBSyxRQUFRLFNBQVMsR0FBRztBQUN2QixZQUFJLEVBQUUsWUFBWTtBQUNsQixZQUFJLFFBQVEsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHO0FBQzNCLFlBQUksT0FBTyxLQUFLLE1BQU0sS0FBSyxPQUFPLElBQUksTUFBTSxNQUFNO0FBQ2xELFlBQUksT0FBTyxLQUFLLENBQUMsTUFBTSxhQUFhO0FBQ2xDLG9CQUFVLEtBQUssQ0FBQyxFQUFFLElBQUk7QUFBQSxRQUN4QixPQUFPO0FBQ0wsb0JBQVU7QUFBQSxRQUNaO0FBQUEsTUFDRixDQUFDO0FBQ0QsYUFBTztBQUFBLElBQ1Q7QUFBQTtBQUFBOzs7QUM3Q0E7QUFBQSw2REFBQUMsU0FBQTtBQUNBLElBQUFBLFFBQU8sU0FBUyxJQUFJLFNBQVMsTUFBTSxNQUFNLFNBQVM7QUFDaEQsYUFBTyxRQUFRO0FBQ2YsVUFBSSxPQUFPO0FBQUEsUUFDVCxNQUFNO0FBQUEsVUFDSjtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQ2Y7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUNmO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDZjtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQ2Y7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUNmO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDZjtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQ2Y7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUNmO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDZjtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQ2Y7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUNmO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDZjtBQUFBLFVBQUs7QUFBQSxRQUNQO0FBQUEsUUFDQSxRQUFRO0FBQUEsVUFDTjtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQ2Y7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUNmO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDZjtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQ2Y7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUNmO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDZjtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQ2Y7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUNmO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDZjtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFFBQ2pCO0FBQUEsUUFDQSxPQUFPO0FBQUEsVUFDTDtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQ2Y7QUFBQSxVQUFLO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUNmO0FBQUEsVUFBSztBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDZjtBQUFBLFVBQUs7QUFBQSxVQUFLO0FBQUEsVUFDVjtBQUFBLFVBQUs7QUFBQSxVQUFL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R0FBRztBQUFBLE1BQ3hCLGNBQWMsQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUFBLE1BQzNCLFlBQVksQ0FBQyxJQUFJLEtBQUssRUFBRTtBQUFBLE1BQ3hCLFlBQVksQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzFCLFVBQVUsQ0FBQyxLQUFLLElBQUksRUFBRTtBQUFBLE1BQ3RCLFVBQVUsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3hCLFdBQVcsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3pCLGFBQWEsQ0FBQyxLQUFLLElBQUksR0FBRztBQUFBLE1BQzFCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLFFBQVEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3RCLGVBQWUsQ0FBQyxHQUFHLEtBQUssR0FBRztBQUFBLE1BQzNCLGFBQWEsQ0FBQyxJQUFJLEtBQUssR0FBRztBQUFBLE1BQzFCLE9BQU8sQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3JCLFFBQVEsQ0FBQyxHQUFHLEtBQUssR0FBRztBQUFBLE1BQ3BCLFdBQVcsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3pCLFVBQVUsQ0FBQyxLQUFLLElBQUksRUFBRTtBQUFBLE1BQ3RCLGFBQWEsQ0FBQyxJQUFJLEtBQUssR0FBRztBQUFBLE1BQzFCLFVBQVUsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3hCLFNBQVMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3ZCLFNBQVMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3ZCLGNBQWMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzVCLFVBQVUsQ0FBQyxLQUFLLEtBQUssQ0FBQztBQUFBLE1BQ3RCLGVBQWUsQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUFBLElBQzdCO0FBQUE7QUFBQTs7O0FDdkpBO0FBQUEsK0NBQUFDLFNBQUE7QUFBQSxJQUFBQSxRQUFPLFVBQVUs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QU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxDQUFDLElBQUksT0FBTyxLQUFLLE1BQU0sS0FBSyxDQUFDLENBQUMsSUFBSSxNQUN6RixVQUFVLEtBQUssTUFBTSxLQUFLLENBQUMsQ0FBQyxJQUFJLE9BQU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxDQUFDLElBQUksT0FBTyxLQUFLLE1BQU0sS0FBSyxDQUFDLENBQUMsSUFBSSxPQUFPLEtBQUssQ0FBQyxJQUFJO0FBQUEsSUFDL0c7QUFFQSxPQUFHLEdBQUcsSUFBSSxVQUFVLFdBQVk7QUFDL0IsVUFBSSxPQUFPLFFBQVEsU0FBUztBQUU1QixVQUFJLElBQUksS0FBSyxNQUFNLEtBQUssQ0FBQyxJQUFJLE1BQU0sR0FBRztBQUN0QyxVQUFJLElBQUksS0FBSyxNQUFNLEtBQUssQ0FBQyxJQUFJLE1BQU0sR0FBRztBQUN0QyxVQUFJLElBQUksS0FBSyxNQUFNLEtBQUssQ0FBQyxJQUFJLE1BQU0sR0FBRztBQUV0QyxhQUFPLEtBQUssU0FBUyxLQUFLLEtBQUssQ0FBQyxNQUFNLElBQ25DLFNBQVMsSUFBSSxRQUFRLElBQUksUUFBUSxJQUFJLE9BQ3JDLFVBQVUsSUFBSSxRQUFRLElBQUksUUFBUSxJQUFJLFFBQVEsS0FBSyxDQUFDLElBQUk7QUFBQSxJQUM1RDtBQUVBLE9BQUcsR0FBRyxNQUFNLFdBQVk7QUFDdkIsVUFBSSxPQUFPLFFBQVEsU0FBUztBQUM1QixhQUFPLEtBQUssU0FBUyxLQUFLLEtBQUssQ0FBQyxNQUFNLElBQ25DLFNBQVMsS0FBSyxDQUFDLElBQUksT0FBTyxLQUFLLENBQUMsSUFBSSxRQUFRLEtBQUssQ0FBQyxJQUFJLE9BQ3RELFVBQVUsS0FBSyxDQUFDLElBQUksT0FBTyxLQUFLLENBQUMsSUFBSSxRQUFRLEtBQUssQ0FBQyxJQUFJLFFBQVEsS0FBSyxDQUFDLElBQUk7QUFBQSxJQUM3RTtBQUlBLE9BQUcsR0FBRyxNQUFNLFdBQVk7QUFDdkIsVUFBSSxPQUFPLFFBQVEsU0FBUztBQUU1QixVQUFJLElBQUk7QUFDUixVQUFJLEtBQUss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QUFBQSxNQUM5QixpQkFBaUIsQ0FBQyxJQUFJLElBQUksR0FBRztBQUFBLE1BQzdCLGlCQUFpQixDQUFDLElBQUksSUFBSSxFQUFFO0FBQUEsTUFDNUIsaUJBQWlCLENBQUMsSUFBSSxJQUFJLEVBQUU7QUFBQSxNQUM1QixpQkFBaUIsQ0FBQyxHQUFHLEtBQUssR0FBRztBQUFBLE1BQzdCLGNBQWMsQ0FBQyxLQUFLLEdBQUcsR0FBRztBQUFBLE1BQzFCLFlBQVksQ0FBQyxLQUFLLElBQUksR0FBRztBQUFBLE1BQ3pCLGVBQWUsQ0FBQyxHQUFHLEtBQUssR0FBRztBQUFBLE1BQzNCLFdBQVcsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3pCLFdBQVcsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3pCLGNBQWMsQ0FBQyxJQUFJLEtBQUssR0FBRztBQUFBLE1BQzNCLGFBQWEsQ0FBQyxLQUFLLElBQUksRUFBRTtBQUFBLE1BQ3pCLGVBQWUsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzdCLGVBQWUsQ0FBQyxJQUFJLEtBQUssRUFBRTtBQUFBLE1BQzNCLFdBQVcsQ0FBQyxLQUFLLEdBQUcsR0FBRztBQUFBLE1BQ3ZCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLGNBQWMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzVCLFFBQVEsQ0FBQyxLQUFLLEtBQUssQ0FBQztBQUFBLE1BQ3BCLGFBQWEsQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUFBLE1BQzFCLFFBQVEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3RCLFNBQVMsQ0FBQyxHQUFHLEtBQUssQ0FBQztBQUFBLE1BQ25CLGVBQWUsQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUFBLE1BQzVCLFFBQVEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3RCLFlBQVksQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzFCLFdBQVcsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3pCLGFBQWEsQ0FBQyxLQUFLLElB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QUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDaEMsQ0FBQyxDQUFDO0FBRUosUUFBSSx3QkFBUSxXQUFXLEVBQ3JCLFFBQVEsc0JBQXNCLEVBQzlCLFFBQVEsbUVBQW1FLEVBQzNFLFFBQVEsVUFBUSxLQUNmLGVBQWUseUZBQXlGLEVBQ3hHLFNBQVMsS0FBSyxPQUFPLFNBQVMsbUJBQW1CLEtBQUssR0FBRyxDQUFDLEVBQzFELFNBQVMsT0FBTSxVQUFTO0FBQ3hCLFdBQUssT0FBTyxTQUFTLHFCQUFxQixNQUFNLE1BQU0sR0FBRztBQUN6RCxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDaEMsQ0FBQyxDQUFDO0FBQUEsRUFDTDtBQUNEOyIsCiAgIm5hbWVzIjogWyJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJ0ZXh0IiwgIm9wdGlvbnMiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJzdHlsaXplIiwgImJ1aWxkZXIiLCAiY29sb3JzIiwgInN0eWxlIiwgInNlcXVlbmNlciIsICJtYXAiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAicmVxdWlyZV9jbGkiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAidmFsdWUiLCAidG1wIiwgImtleSIsICJyZXMiLCAiam9pbiIsICJzdHJpbmdpZnkiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJyZXF1aXJlX21zIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAidiIsICJmb3JtYXQiLCAiZmllbGQiLCAicmVxdWlyZV90aW1lc3RhbXAiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgInJlcXVpcmVfc3RyZWFtIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAiZXJyIiwgInNlbGYiLCAicmVxdWlyZV9lcnJvcnMiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJCdWZmZXIiLCAibW9kdWxlIiwgIm9ubGVnYWN5ZmluaXNoIiwgIm9uZmluaXNoIiwgIm9uZW5kIiwgIm9uZXJyb3IiLCAib25jbG9zZSIsICJvbnJlcXVlc3QiLCAibW9kdWxlIiwgImNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciIsICJtb2R1bGUiLCAic2VsZiIsICJtb2R1bGUiLCAiRUVsaXN0ZW5lckNvdW50IiwgIkJ1ZmZlciIsICJkZWJ1ZyIsICJzZWxmIiwgIm4iLCAibW9kdWxlIiwgImtleXMiLCAic2VsZiIsICJtb2R1bGUiLCAiQnVmZmVyIiwgInJlYWxIYXNJbnN0YW5jZSIsICJtb2R1bGUiLCAiVHJhbnNwb3J0U3RyZWFtIiwgIm1vZHVsZSIsICJMZWdhY3lUcmFuc3BvcnRTdHJlYW0iLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJyZXF1aXJlX2VhY2hPZkxpbWl0IiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAicHJvY2VzcyIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAic3dpenpsZSIsICJtb2R1bGUiLCAicmVxdWlyZV9jb2xvcl9uYW1lIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAic2VsZiIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAicmVxdWlyZV9jb25zb2xlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAicmVxdWlyZV9ub2RlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgImJ1ZmYiLCAib3B0aW9ucyIsICJtb2R1bGUiLCAibW9kdWxlIiwgInJlcXVpcmVfc3RyZWFtIiwgIm1vZHVsZSIsICJyZXF1aXJlX2NvbmZpZyIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgImR1bW15T2JqZWN0IiwgInY4U3RhY2tUcmFjZSIsICJzZWxmIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgInNlbGYiLCAibW9kdWxlIiwgInJlcXVpcmVfbG9nZ2VyIiwgIkJ1ZmZlciIsICJFeHRUeXBlIiwgIndpbiIsICJ3aW5kb3ciLCAicmVxdWlyZV9hdHRhY2giLCAicGx1Z2luIiwgInJlcXVpcmVfcGx1Z2luIiwgInJlcXVpcmVfcGx1Z2luIiwgImZpbmROdmltIl0KfQo=

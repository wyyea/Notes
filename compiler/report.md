---
id: report
aliases: []
tags: []
---

<h1><center>编译器中间代码数据流优化的实现和探究</center></h1>

<div align="right"> 211240073 李鸿毅 </div>

## 概要
本文介绍了编译优化中的重要部分——中间代码优化，并针对一个流行且经典的算法——数据流优化进行探究。作者在三地址中间代码上实现了数据流优化中常用的多种优化，包括公共子表达式消除，常量传播，死代码消除，部分冗余消除，并分析了多种优化的不同效果以及组合效果。

## 引入
编译器是计算机和软件领域的重要组成部分，源代码通过编译后形成机器代码后运行。源代码和机器代码并非一一对应的，对同一份源代码，在保证正确性的情况下，更优秀的机器代码能够使程序执行更加高效（时间/空间等）。针对特定的源代码语言和中间代码格式，寻找一种最佳转换是NP难问题，编译器往往在编译的各个阶段引入优化尝试获得更高效的机器代码。编译过程主要可分为预编译，词法分析，语法分析，语义分析，中间代码生成，中间代码翻译为机器代码这几个阶段，其中在中间代码生成后中间代码翻译为机器代码前可引入一个优化过程，即为中间代码优化。中间代码优化作为编译优化的重要组成部分，已经存在各种各样的效果良好的算法，本文将对其中较为流行且经典的数据流方法进行探究，作者实现了数据流方法中常用的多种优化，包括公共子表达式消除，常量传播，死代码消除，部分冗余消除，另外正在实现数据流方法的一个变种——基于区域分析，并针对已实现的部分做了详细的分析，包括各种优化独立的优化效果，不同优化组合后的效果，重复多次同一种优化的效果。

## 动机
本项目是对《编译原理》课程实验的拓展，针对中间代码优化进行了更加深入的探究。本文作为科研训练实验报告提交，可能有人会认为为何不提交一个科研实践的相关材料。本人其实在大三整年都有进课题组进行实习，但可能由于课题组中各方面原因，老师只安排了一些打下手的工作（如帮助搭建实验环境），过程比较重复和枯燥，成果更是无从谈起。而在大三下学期的《编译原理》课程中，我对其中的数据流优化方法较为感兴趣，于是针对课程实验进行拓展，对常用的数据流优化算法（课本或其他资料中只写出了简单算法原理）进行实现和分析，个人认为极具有项目锻炼价值，且其实现难度远高于在课题组中搭建试验环境此类打下手工作。

## 背景介绍
什么是中间代码？中间代码是程序的一种表现形式，相比于源程序更加接近机器代码，但相比于机器代码又有更高的抽象程度，中间代码只需添加一定的寄存器分配算法即能对应生成机器代码。正因如此，针对机器代码的优化往往更加容易（相比机器代码有一定抽象），且优化程度也足够（基本能一一对应机器代码）。

数据流方法涉及基本块和流图等概念，先对此进行介绍。基本块连续的中间代码序列，从基本块的首条代码执行到最后一条代码的过程不会发生任何跳转，同时执行流只能从基本块的首条代码开始执行，无法直接跳转到中间的代码，一段中间代码可以划分为若干个基本块，基本块可通过简单的基本块划分算法进行生成。流图建立了基本块之间的转移关系，包括跳转，条件跳转，顺序执行，函数调用等，A可以转移到B就建立一条从A到B的边。

数据流方法为流图上进行的优化，每一个基本块的起点和终点都可视为一个程序点，每个程序点会有不同的状态，我们可以根据这些状态对基本块内部的代码进行优化。但这些状态之间存在依赖，受基本块之间转移关系约束（通过流图表示）。数据流方法从流图的某一个点出发，状态在基本块内部和流图中进行传递和改变，试图通过迭代的方法生成状态的一种可行解，针对特定的算法，可以证明迭代过程是收敛的，即经过有限次迭代一定能够生成一组稳定的解。

数据流方法的框架如下：

输入：一个由下列部分组成的数据流框架：
（1）一个数据流图，它有两个被特别标记为ENTRY和EXIT的节点
（2）数据流的方向D
（3）一个值集V（状态的集合）
（4）一个交汇运算 $\land$ , (用于状态在流图中的传递)
（5）一个函数的集合F，其中 $f_B$ 表示基本块B的传递函数（用于状态在基本块内部的传递）
（6）V中的一个常量值$v_{ENTRY}$或者$v_{EXIT}$。它们分别表示前向和逆向框架的边界条件

输出：上述数据流图中各个基本块B的IN[B]和OUT[B]的值，这些值在V中

算法：
前向数据流：
```
OUT[ENTRY] = v_{ENTRY}
for (除ENTRY之外的每个基本块B) OUT[B] = T;
while (某个OUT值发生了改变)
	for (除ENTRY之外的每个基本块B)｛
		IN[B] = B的所有前驱P的OUT[P]的交汇运算结果
		OUT[B] = f_{B}(IN[B])
	｝
```
逆向数据流：
```
IN[ENTRY] = v_{EXIT}
for (除EXIT之外的每个基本块B) IN[B] = T;
while (某个IN值发生了改变)
	for (除EXIT之外的每个基本块B)｛
		OUT[B] = B的所有后继P的IN[P]的交汇运算结果
		IN[B] = f_{B}(OUT[B])
	｝
```

## 代码实现
### 说明

该项目在某位学长所写的框架代码下改进实现，其中划分基本块，数据流的基本框架等基础工作在框架代码中已完成，作者完成了可用表达式，常量传播，活跃变量分析的核心部分，以及自行构建了部分冗余分析（包括四个数据流分析）和基于区域的符号分析的全部，在此对该学长表示感谢
### 公共子表达式消除
公共子表达式消除通过对每个程序点上的可用表达式进行分析完成，伪代码如下：(还使用了复制传播进行后续优化，此处不赘述)

```
OUT[ENTRY] = {}
for (除ENTRY之外的每个基本块B) OUT[B] = U;
while (某个OUT值发生了改变)
	for (除ENTRY之外的每个基本块B)｛
		IN[B] = B的所有前驱P的OUT[P]的交集
		OUT[B] = e_gen[B] + (IN[B] - e_kill[B])
	｝
```

IN, OUT的取值集合为所有表达式的全集的子集

其中$e\_gen[B]$表示该基本块新生成且在块内未被杀死的表达式，$e\_kill[B]$表示该基本块杀死的表达式集合，杀死指的是在t=a+b后重新对ａ进行定值，从而ｔ被杀死（a+b无法被ｔ表示，即ｔ无法复用）

该问题是一个前向数据流问题，一个基本块头部的表达式可用当且仅当从所有该基本块的前驱传递过来的表达式集合中都包含该表达式，于是```IN[B] = B的所有前驱P的OUT[P]的交集```

代码实现中每个基本块内部的传递实现为依次对每条语句进行传递，而非直接计算出$e\_gen[B]$和$e_kill[B]$

![[Pasted image 20240629213323.png|500]]

分析得到可用表达式后会在所有存在可用且重复表达式的节点上，将重复计算替换为一次复制
### 常量传播
常量传播使用类似到达定值的分析完成，伪代码如下：

```
OUT[ENTRY]将所有变量都映射为UNDEF
for (除ENTRY之外的每个基本块B) OUT[B]将所有变量都映射为UNDEF
while (某个OUT值发生了改变)
	for (除ENTRY之外的每个基本块B)｛
		IN[B] = B的所有前驱P的OUT[P]的交汇运算
		OUT[B] = f_{B}[IN[B]]
	｝
```

IN, OUT的取值为对所有变量到{UNDEF, NAC, c}（未定义变量，非常量，某常量）的任一映射

其中交汇运算定义如下：（两个映射$f,\ g$在同一变量 $v$ 上, $f(v)$， $g(v)$可取UNDEF, NAC, c的任意取值）
UNDEF $\land\ v = v$ ，NAC $\land\ v = v$
$c_1\land c_1 = c_1, c_1\land c_2 =$ NAC  （两个相同常量交汇后仍为自身，不同常量交汇得到NAC）

传递函数定义如下：（传递前后两个映射$f,\ g$）
（1）s不是赋值语句，$f_{s}$为单元函数
（2）s未对变量$v$赋值，$f(v) = g(v)$

（3）s对变量$v$通过二元运算赋值，$v = a + b$：
$f(a), f(b)$为常量：$g(v) = f(a) + f(b)$
$f(a), f(b)$之一为NAC：$g(v) =$ NAC
其余情况：$g(v) =$ UNDEF

（4）s使用常量$c$对$v$赋值，$g(v) = c$
（5）s使用函数或指针对$v$赋值，$g(v) =$ UNDEF

该问题是前向数据流问题，上述交汇运算和传递函数保守地对每个程序点上的变量的取值情况进行了估计

代码实现中每个基本块内部的传递实现为依次对每条语句进行传递，即直接使用上述传递函数的定义，对数据流分析框架进行了改造
![[Pasted image 20240629215632.png|500]]

分析得到每个程序点上变量取值情况后，将取值为常量且被当前语句使用的变量替换为对应常量
### 死代码消除：
死代码即无用代码，某一赋值代码，赋值号左边变量永不可能被后续使用，该赋值代码为死代码。程序员一般不会写出死代码，是经过前面的优化步骤对代码进行变换后产生的

死代码消除通过活跃变量分析来完成，即分析变量的后续使用情况，伪代码如下：
```
IN[ENTRY] = {}
for (除EXIT之外的每个基本块B) IN[B] = {};
while (某个IN值发生了改变)
	for (除EXIT之外的每个基本块B)｛
		OUT[B] = B的所有后继P的IN[P]的并集
		IN[B] = use[B] + (OUT[B] - def[B])
	｝
```

IN, OUT的取值集合的所有变量的集合，表示当前程序点上活跃变量的集合

use[B]为基本块中使用先于定义的变量，def[B]为基本块中定义先于使用的变量，一个变量使用先于定义，则在基本块头部一定是活跃的，反之则被先出现的定义杀死，在基本块头部不活跃

该问题是逆向数据流问题，一个基本块尾部的变量活跃当且仅当其该变量在其中一个后继块中活跃，于是代码中有```B的所有后继P的IN[P]的并集```

![[Pasted image 20240629221450.png|500]]

分析得到每个程序点上活跃变量集合后，可以将对不活跃变量的赋值代码删去

### 部分冗余分析

部分冗余分析能够对冗余计算的表达式进行消除，此优化相较于前面基于可用表达式的公共子表达式优化更加激进，同时还能额外完成循环不变计算的外提

部分冗余分析包括四部分，预期执行表达式分析，可用表达式分析，可后延表达式分析，被使用的表达式分析，此处不再列出伪代码，以表格形式列出每种分析的（方向，交汇运算，传递函数，边界条件）
![[Pasted image 20240629222205.png|500]]
优化过程：对表达式 x + y

若基本块Ｂ, x + y在latest[B] $\cap$  used[B].out中，则将t = x + y 提到Ｂ的开头进行计算（后续可使用ｔ替换某些x + y）

若基本块Ｂ, x + y在$e\_use_{B}\cap (\neg latest[B]\cup\ used.out[B])$中，则用ｔ来替换Ｂ中所有x + y

此部分包含四个数据流分析，且其中的earliest[B]，latest[B]的计算较为复杂。

作者在尝试使用课本提供的原方案进行实现时，发现使用原有的数据块划分方式会出现错误，具体来说就是可能出现“使用＋定义＋使用“交替的情况，此时难以确定$e\_use[B]$和$e\_kill[B]$的值，且若将t = x + y提至开头再使用ｔ替换两次使用后第一次使用会出现错误，其他交替情况也可能导致类似的问题。作者于是将单条语句划分为一个数据块，加细了分析的粒度，对原方案进行相应的改造后能够得到转换正确且得到优化的代码

实现代码在```anticipated_analysis.c, available_expr_pre.c, postponable_expressions.c,
used_expressions.c```中

### 基于区域的归纳变量强度削减

基于区域的分析是数据流分析的变种，将若干个基本块划分为循环，将多个循环构造成多个区域嵌套形成的区域图，该分析方法较适用于循环的优化分析

循环的优化一直是编译优化的经典课题，归纳变量强度削减是其中重要部分。所谓归纳变量，即一个循环中有若干变量是依赖于循环变量，是循环变量的一次函数，如循环变量为ｉ，归纳变量为$x = 4 * i$，若一次循环后 $i = i + 1$, 则可以将$x = 4 * i$ 替换为$x = 4 + x$, 并在循环开始前计算一次$x = 4 * i$ 即可。该替换将强度较高的乘法替换为加法，虽然没有减少中间代码的语句条数，但有效提高了代码的效率

基于区域的分析算法框架如下：
（1）构造一个自底向上的区域序列，$R_1, R_2, \cdots, R_n$ , $R_n$是最顶层的区域
（2）按照自底向上的顺序，进行下列计算
+ 如果Ｒ是一个叶子区域，令$f_{R,IN[B]} = I, f_{R, OUT[B]} = f_{B}$
+ 如果Ｒ是一个循环体区域，执行如下计算

![[Pasted image 20240629225739.png|400]]

+ 如果Ｒ是一个循环区域，执行如下计算

![[Pasted image 20240629225811.png|400]]

（3）进行自顶向下的扫描，找出各个区域开始处的数据流值
+ $IN[R_n] = IN[ENTRY]$ 
+ 按照自顶向下的顺序，对$R_1, R_2, \cdots, R_{n-1}$计算
	$IN[R] = f_{R', IN[R]}(IN[R'])$, 　R'是直接包含区域Ｒ的区域

符号分析算法简单描述如下：
IN, OUT集合的取值为从所有变量到所有仿射表达式（即已有变量的线性组合）的任一映射
交汇运算为两个变量的映射相等时任取其一，否则映射为非法映射
复合运算为一次映射对其仿射表达式使用另一次映射进行展开，若展开中涉及非法映射，则结果为非法映射，否则为展开结果

归纳变量强度削减算法是作者根据基于区域的符号分析算法改造得到的，在得到每一个区域头部的所有变量对应的仿射表达式后，可进一步得到在每一条语句上的状态，然后可对仅依赖于循环变量的仿射表达式进行强度削减。此种削减仅对循环中必须经过的基本块上的代码进行，即只对支配所有循环出口的代码进行强度削减，从而在最坏情况下也不会增加额外的计算

该算法工程量较大，作者已经完成了构造自底向上的区域序列，计算每个叶子区域的传递函数，正在调试循环体和循环的计算过程，实现代码在```region_graph.c, range_analysis.c, dom_analysis.c```中

## 结果分析

该部分统计优化前后执行的中间代码条数（优化后/优化前），从而分析优化的效果

### 常量传播：
![[Pasted image 20240629231842.png|450]]

代码条数没有减少，反而增加，常量传播只会对确定值的变量进行常量替换，并未能减少执行代码条数，但在分析过程中会增加一定量的代码

### 可用表达式分析：
![[Pasted image 20240629232256.png|450]]

可用表达式消除了一部分重复计算，结果显示减少了一定量的执行代码条数

### 死代码消除：
![[Pasted image 20240629232609.png|450]]

由于未经过变换的代码基本不存在死代码，而分析过程中有增加了一定量的代码，于是执行代码条数不降反增

### 常量传播＋可用表达式：
![[Pasted image 20240630004954.png|450]]

相比于只使用可用表达式未有明显的减少

### 常量传播＋可用表达式＋死代码消除：

![[Pasted image 20240629233024.png|450]]

此时死代码消除在常量传播＋可用表达式优化后有了较大的优化空间，取得了较好的优化效果
### 进行多次(常量传播＋可用表达式) + 死代码消除：

![[Pasted image 20240629233300.png|450]]

相比与仅进行一次，进行多次可得到小幅的进步，这可能是多次可用表达式＋常量传播减少了深层的公共子表达式
### 常量传播＋部分冗余消除＋死代码消除：

![[Pasted image 20240629233835.png|450]]

将可用表达式替换为部分冗余消除，取得了更好的效果，这可能是部分冗余消除在公共子表达式上优化更加激进，也可能是部分冗余消除会对循环不变计算进行外提，减少了更多的代码执行

### 进行多次(常量传播＋部分冗余消除) + 死代码消除：

![[Pasted image 20240629234259.png|450]]

此时代码条数进一步减少，可见部分冗余消除相比可用表达式而言，对深层公共子表达式的优化效果更好

## 总结

本文对数据流方法进行中间代码优化的多种常用方法进行了实现和探究分析，突出工作为实现了较为困难的部分冗余分析，而归纳变量强度削减则有待完成，而且相应的符号分析算法还可进行额外一些优化。通过本次对数据流方法的探究，我的工程能力得到了一定的提高，而且对于编译优化尤其是中间代码优化有了更深的了解，相信这对于我以后从事软件相关领域的研究会起到一定帮助

## 附录

所有代码在Code文件夹中，使用make即可构建可执行文件parser, 命令为```./parser a.ir b.ir```，其中```a.ir```为待优化中间代码，```b.ir```为优化后代码存放位置, 其中```IR_optimize.c```中可选择不同的编译优化组合

实验中使用的中间代码格式如下
![[Pasted image 20240630000941.png|500]]

## 参考文献

Compilers: Principles, Techniques and Tools (Second Edition);    Alfred V.aho, Monica S.Lam etc.
Global optimization by suppression of partial redundancies;      Morel, E. and C.Renvoise
The Design of an Optimizing Computer;                                      Ｗulf, W. A. R. K. Johnson etc.
